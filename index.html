<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Texas Hold'em (Online)</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♠️</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Black+Ops+One&family=Noto+Sans+JP:wght@500;700&family=Noto+Sans+SC:wght@500;700&display=swap");

    body {
      font-family: "Inter", "Noto Sans JP", "Noto Sans SC", "Microsoft YaHei", sans-serif;
      background-color: #111827;
      color: white;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      height: 100dvh;
      width: 100vw;
    }

    /* --- 3D Card Animation Styles --- */
    .card-scene {
      width: 42px;
      height: 60px;
      perspective: 600px; /* 3D perspective */
      display: inline-block;
    }

    @media (min-width: 768px) {
      .card-scene {
        width: 56px;
        height: 78px;
      }
    }

    .card-obj {
      width: 100%;
      height: 100%;
      position: relative;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border-radius: 4px;
    }

    /* Flip class applied via JS */
    .card-obj.is-flipped {
      transform: rotateY(180deg);
    }

    .card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden; /* Hide back when facing away */
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #e5e7eb;
    }

    @media (min-width: 768px) {
      .card-face { border-radius: 6px; }
      .card-obj { border-radius: 6px; }
    }

    /* Front (Face value) - Initially rotated 180deg (hidden) if dealt face down */
    .card-face.face-front {
      background-color: white;
      transform: rotateY(180deg);
      font-weight: bold;
      font-size: 16px;
      flex-direction: column;
    }
    
    @media (min-width: 768px) {
      .card-face.face-front { font-size: 20px; }
    }

    /* Back (Pattern) - Initially at 0deg */
    .card-face.face-back {
      background: repeating-linear-gradient(45deg, #1e3a8a, #1e3a8a 10px, #172554 10px, #172554 20px);
      border: 2px solid #e2e8f0;
      transform: rotateY(0deg);
    }

    .card-face.red { color: #dc2626; }
    .card-face.black { color: #1f2937; }

    .card-face.winning-card {
      box-shadow: 0 0 15px 5px rgba(251, 191, 36, 0.9);
      border: 3px solid #fbbf24;
      z-index: 100;
    }

    /* Flying Card (Ghost) */
    .flying-card {
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      transition: top 0.5s ease-out, left 0.5s ease-out, transform 0.5s;
    }

    /* --- Placeholders --- */
    .card-placeholder {
      width: 42px;
      height: 60px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      border: none;
      background: transparent;
    }
    .card-placeholder:empty {
      border: 2px dashed rgba(255, 255, 255, 0.2);
      background-color: rgba(0, 0, 0, 0.2);
      box-sizing: border-box;
    }
    @media (min-width: 768px) {
      .card-placeholder { width: 56px; height: 78px; border-radius: 6px; }
    }

    /* --- Table --- */
    .poker-table {
      background: radial-gradient(circle, #15803d 0%, #064e3b 90%, #022c22 100%);
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.9), 0 0 0 12px #374151, 0 0 0 16px #1f2937;
      position: relative;
      border-radius: 180px;
      transform: translateY(0px);
      will-change: transform;
    }
    @media (min-width: 768px) { .poker-table { transform: translateY(30px); } }

    .cursor-grab { cursor: grab; }
    .cursor-grabbing { cursor: grabbing; }

    .player-seat {
      position: absolute;
      transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.6s, top 0.6s;
      width: 120px;
      height: 110px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transform-origin: center center;
      pointer-events: none;
    }
    .player-seat > * { pointer-events: auto; }

    .player-info-box {
      background: linear-gradient(180deg, rgba(31, 41, 55, 0.95) 0%, rgba(17, 24, 39, 0.98) 100%);
      border: 1px solid #4b5563;
      border-radius: 6px;
      padding: 4px 2px;
      width: 100%;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
      transition: all 0.3s ease;
      position: relative;
    }

    .dealer-btn {
      width: 20px; height: 20px;
      background: radial-gradient(circle at 30% 30%, #fff, #cbd5e0);
      color: #1a202c; border-radius: 50%; font-size: 12px; font-weight: 900;
      display: flex; align-items: center; justify-content: center;
      position: absolute; top: -8px; right: -6px;
      border: 1px solid #9ca3af; z-index: 30;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
    }

    .active-player .player-info-box {
      box-shadow: 0 0 0 2px #fbbf24, 0 0 20px rgba(251, 191, 36, 0.4);
      border-color: #f59e0b;
      background: linear-gradient(180deg, #374151 0%, #1f2937 100%);
      transform: translateY(-2px); z-index: 40;
    }
    .winner-highlight .player-info-box {
      box-shadow: 0 0 0 3px #22c55e, 0 0 30px rgba(34, 197, 94, 0.6);
      border-color: #22c55e;
      background: linear-gradient(180deg, #064e3b 0%, #065f46 100%);
      z-index: 50;
    }

    /* --- All-in & VFX --- */
    .all-in-fullscreen-overlay {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      display: flex; align-items: center; justify-content: center;
      z-index: 9999; pointer-events: none; background: rgba(0, 0, 0, 0.3);
      animation: fadeIn 0.2s ease-out;
    }
    .all-in-bar {
      position: absolute; top: 50%; left: 0; width: 100%; height: 140px;
      background: rgba(0, 0, 0, 0.95);
      transform: translateY(-50%) translateX(-100%);
      animation: barSlideIn 0.4s cubic-bezier(0.05, 0.7, 0.1, 1) forwards;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
      border-top: 2px solid rgba(234, 179, 8, 0.6);
      border-bottom: 2px solid rgba(234, 179, 8, 0.6);
      display: flex; align-items: center; justify-content: center; overflow: hidden;
    }
    @keyframes barSlideIn { from { transform: translateY(-50%) translateX(-100%); } to { transform: translateY(-50%) translateX(0%); } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .all-in-text {
      position: relative; font-family: "Black Ops One", system-ui, sans-serif; font-size: 90px;
      white-space: nowrap; text-transform: uppercase; letter-spacing: 4px;
      background: linear-gradient(to bottom, #fef08a 0%, #eab308 45%, #a16207 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 5px 3px rgba(0, 0, 0, 0.5)); text-shadow: 0 0 30px rgba(234, 179, 8, 0.6);
      opacity: 0; transform: scale(2);
      animation: textImpact 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards 0.2s;
    }
    @keyframes textImpact { 0% { opacity: 0; transform: scale(2); filter: blur(10px); } 100% { opacity: 1; transform: scale(1); filter: blur(0px); } }
    .all-in-bar::after {
      content: ""; position: absolute; top: 0; left: -100%; width: 30%; height: 100%;
      background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.4), transparent);
      transform: skewX(-25deg); animation: shine 1s infinite 0.5s;
    }
    @keyframes shine { 0% { left: -50%; } 100% { left: 150%; } }

    input[type="range"]::-webkit-slider-thumb { background: #fbbf24; }
    .adjust-btn:active { transform: scale(0.95); background-color: #4b5563; }
    .smart-transparent { opacity: 0.15 !important; transition: opacity 0.2s ease-out; pointer-events: none; }

    /* --- Loader & Screens --- */
    .firebase-loader {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #111827; z-index: 10000;
    }
    .spinner {
      width: 48px; height: 48px; border: 4px solid #4b5563; border-top-color: #f59e0b; border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #room-screen { z-index: 50; background: rgba(17, 24, 39, 0.95); backdrop-filter: blur(10px); }
    .btn-disabled {
      background-color: #4b5563 !important; border-color: #374151 !important; color: #9ca3af !important;
      cursor: not-allowed !important; transform: none !important;
    }
    #bottom-bar { padding-bottom: calc(0.5rem + env(safe-area-inset-bottom)); }
  </style>
</head>

<body class="h-[100dvh] w-screen flex flex-col items-center justify-center bg-gray-950">
  <div id="firebase-loader" class="firebase-loader">
    <div class="spinner"></div>
    <p class="text-gray-400 mt-4 text-sm font-medium" data-i18n="connecting">Connecting to server...</p>
  </div>

  <!-- Room Screen -->
  <div id="room-screen" class="hidden absolute z-50 bg-gray-900 p-8 rounded-xl shadow-2xl border border-gray-700 w-11/12 max-w-md">
    <div class="absolute top-4 right-4">
      <select id="language-selector" onchange="updateLanguage(this.value)"
        class="bg-gray-800 text-gray-300 text-xs rounded px-2 py-1 border border-gray-600 focus:outline-none focus:border-yellow-500">
        <option value="en" selected>English</option>
        <option value="ja">日本語</option>
        <option value="zh">中文</option>
      </select>
    </div>
    <h1 class="text-3xl font-bold text-yellow-500 mb-6 tracking-tight text-center" data-i18n="gameTitle">Texas Hold'em</h1>
    <div class="mb-4">
      <label class="block text-gray-400 mb-2 text-sm font-bold" for="player-name-input" data-i18n="nicknameLabel">Your Nickname</label>
      <input type="text" id="player-name-input" class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500" placeholder="" />
    </div>
    <div class="mb-6">
      <label class="block text-gray-400 mb-2 text-sm font-bold" for="room-id-input" data-i18n="roomIdLabel">Room ID</label>
      <input type="text" id="room-id-input" class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500" placeholder="" />
    </div>
    <div class="flex space-x-4 mb-4">
      <button onclick="network.joinRoom()" id="btn-join-room" data-i18n="joinRoomBtn" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">Join Room</button>
      <button onclick="network.createRoom()" id="btn-create-room" data-i18n="createRoomBtn" class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1">Create Room</button>
    </div>
    <p id="room-error" class="text-red-400 text-sm h-5 text-center"></p>
    <p class="text-gray-500 text-xs mt-4 text-center">User ID: <span id="user-id-display">...</span></p>
  </div>

  <!-- Game Area -->
  <div id="game-area" class="hidden w-full h-full relative flex flex-col">
    <div id="top-bar" class="h-16 bg-gray-900 w-full flex items-center justify-between px-6 shadow-lg z-10 border-b border-gray-800 relative z-50">
      <div class="flex items-center space-x-2">
        <div class="text-yellow-500 font-black text-2xl tracking-tight"><span data-i18n="pot">Pot</span>: $<span id="pot-display">0</span></div>
      </div>
      <div class="flex items-center space-x-4">
        <div class="flex flex-col items-center mr-1 bg-gray-800 px-2 py-1 rounded border border-gray-700">
          <span class="text-gray-500 text-[10px] font-bold leading-none mb-1" data-i18n="room">Room</span>
          <span id="display-room-id" class="text-yellow-500 font-mono font-bold text-sm leading-none">---</span>
        </div>
        <div class="text-right hidden sm:block">
          <div id="blinds-display" class="text-gray-400 text-xs font-bold tracking-wider">Blinds $10/$20</div>
          <div class="text-gray-600 text-[10px]"><span data-i18n="online">Online</span>: <span id="active-players-count">0</span></div>
        </div>
        <button id="btn-leave-room" onclick="network.leaveRoom()" data-i18n="leaveRoomBtn" class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-2 px-4 rounded-lg text-xs shadow-md">Leave</button>
      </div>
    </div>

    <div id="table-area" class="flex-grow relative overflow-hidden flex items-center justify-center bg-gray-950 cursor-grab active:cursor-grabbing">
      <div id="table" class="poker-table w-[95vw] h-[55vh] md:w-[800px] md:h-[450px] max-w-full relative transition-all duration-500">
        <div id="community-area" class="absolute top-[42%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 flex flex-col items-center z-20 transition-opacity duration-200">
          <div id="community-cards" class="flex flex-wrap justify-center items-center gap-1 sm:gap-2 max-w-[150px] md:max-w-none transition-all duration-300">
            <div id="comm-slot-0" class="card-placeholder"></div>
            <div id="comm-slot-1" class="card-placeholder"></div>
            <div id="comm-slot-2" class="card-placeholder"></div>
            <div id="comm-slot-3" class="card-placeholder"></div>
            <div id="comm-slot-4" class="card-placeholder"></div>
          </div>
        </div>
        <div id="game-message" class="absolute top-[23%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-yellow-100 font-bold text-xl text-center z-30 pointer-events-none drop-shadow-lg px-4 py-2 rounded whitespace-nowrap transition-opacity duration-300 opacity-0"></div>
        <div id="seats-container" class="w-full h-full relative"></div>
        <!-- Animation Layer -->
        <div id="animation-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none z-50"></div>
      </div>
    </div>

    <div id="bottom-bar" class="bg-gray-900 p-4 shadow-[0_-5px_15px_rgba(0,0,0,0.5)] z-20 border-t border-gray-800 relative z-50">
      <div id="game-log" class="h-16 overflow-y-auto text-xs text-gray-500 mb-3 font-mono bg-gray-950 p-2 rounded border border-gray-800 scroll-smooth leading-5">
        <div data-i18n="log_welcome">System: Welcome to Texas Hold'em.</div>
      </div>
      <div id="player-controls" class="flex flex-col items-center opacity-50 pointer-events-none transition-all duration-300 transform translate-y-2">
        <div id="raise-slider-container" class="w-full max-w-md mb-4 flex items-center space-x-2 px-2">
          <span class="text-xs text-gray-500 font-bold tracking-wider w-8 text-center" data-i18n="raiseLabel">Bet</span>
          <button onclick="gameUI.adjustRaise(-1)" class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700">-</button>
          <input type="range" id="raise-slider" step="1" class="flex-grow h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mx-2" />
          <button onclick="gameUI.adjustRaise(1)" class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700">+</button>
          <span id="raise-val-display" class="text-sm text-yellow-400 w-14 text-right font-mono font-bold">$0</span>
        </div>
        <div class="flex justify-center space-x-3 w-full max-w-lg">
          <button onclick="network.handleHumanAction('fold')" data-i18n="foldBtn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">Fold</button>
          <button onclick="network.handleHumanAction('check')" id="btn-check" data-i18n="checkBtn" class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1">Check</button>
          <button onclick="network.handleHumanAction('call')" id="btn-call" data-i18n="callBtn" class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1 hidden">Call</button>
          <button onclick="network.handleHumanAction('raise')" id="btn-raise" data-i18n="raiseBtn" class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1">Raise</button>
        </div>
      </div>
      <div class="text-center mt-2 text-gray-700 text-[10px] font-mono tracking-wider">
        <span data-i18n="phaseLabel">Phase</span>: <span id="phase-display" class="text-gray-500" data-i18n="waiting">Waiting</span>
      </div>
    </div>

    <div id="waiting-room-overlay" class="hidden absolute top-0 left-0 w-full h-full z-40 flex flex-col items-center justify-center pointer-events-none">
      <div id="wait-host-controls" class="hidden pointer-events-auto flex flex-col items-center gap-4 transition-transform duration-300 mb-28">
        <div id="host-settings-panel" class="bg-gray-800/80 p-4 rounded-lg border border-gray-600 w-72 backdrop-blur-sm shadow-lg">
          <div class="mb-3">
            <div class="flex justify-between items-center mb-1">
              <label class="block text-yellow-500 text-xs font-bold" data-i18n="initialChips">Initial Chips</label>
              <span id="error-chips-inline" class="text-red-500 text-[10px] font-bold animate-pulse"></span>
            </div>
            <input type="number" id="setting-initial-chips" value="2000" step="100" class="w-full bg-gray-900 text-white border border-gray-600 rounded px-2 py-1 text-sm focus:border-yellow-500 outline-none font-mono">
          </div>
          <div>
            <div class="flex justify-between items-center mb-1">
              <label class="block text-yellow-500 text-xs font-bold" data-i18n="bigBlind">Big Blind</label>
              <span id="error-blind-inline" class="text-red-500 text-[10px] font-bold animate-pulse"></span>
            </div>
            <input type="number" id="setting-big-blind" value="20" step="2" min="2" class="w-full bg-gray-900 text-white border border-gray-600 rounded px-2 py-1 text-sm focus:border-yellow-500 outline-none font-mono">
            <p class="text-gray-400 text-[10px] mt-1 text-right"><span data-i18n="smallBlindAuto">SB Auto</span>: <span id="setting-sb-display" class="text-white font-bold">10</span></p>
          </div>
        </div>
        <div id="host-start-btn-container"></div>
      </div>
      <p id="wait-message" class="mt-8 text-yellow-400 font-bold text-xl drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)] pointer-events-auto bg-black/40 px-6 py-2 rounded-lg backdrop-blur-sm border border-white/10" data-i18n="waitForHost">Waiting for host to start...</p>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction, deleteDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firestoreUpdateDoc = updateDoc;

    const TRANSLATIONS = {
      en: {
        connecting: "Connecting to server...", gameTitle: "Texas Hold'em", nicknameLabel: "Your Nickname", roomIdLabel: "Room ID", joinRoomBtn: "Join Room", createRoomBtn: "Create Room", pot: "Pot", room: "Room", online: "Players", leaveRoomBtn: "Leave", raiseLabel: "Bet", foldBtn: "Fold", checkBtn: "Check", callBtn: "Call", raiseBtn: "Raise", allInBtn: "All-in", phaseLabel: "Phase", waiting: "Waiting", initialChips: "Initial Chips", bigBlind: "Big Blind", smallBlindAuto: "SB Auto", waitForHost: "Waiting for host...", startGameBtn: "Start Game", waitPlayerBtn: "Waiting Players", status_fold: "Fold", status_check: "Check", status_call: "Call", status_raise: "Raise", status_all_in: "All-in", status_small_blind: "Small Blind", status_big_blind: "Big Blind", status_eliminated: "Eliminated", status_won: "Won", phase_preflop: "Preflop", phase_flop: "Flop", phase_turn: "Turn", phase_river: "River", phase_showdown: "Showdown", hand_high_card: "High Card", hand_pair: "Pair", hand_two_pairs: "Two Pairs", hand_three_of_a_kind: "Three of a Kind", hand_straight: "Straight", hand_flush: "Flush", hand_full_house: "Full House", hand_four_of_a_kind: "Four of a Kind", hand_straight_flush: "Straight Flush", msg_your_turn: "Your Turn", msg_thinking: " Thinking", msg_winner: "Winner!", msg_bankruptcy: "You are bankrupt. Spectating.", msg_game_reset: "Game resetting...", error_nickname: "Nickname 2-10 chars", error_room_id: "Room ID required", error_room_dead: "Room expired/dead", error_room_full: "Room full", error_game_started: "Game already started", error_join_fail: "Join Failed", bet_prefix: "Bet", call_prefix: "Call", log_welcome: "System: Welcome to Texas Hold'em.", log_join: "{name} joined.", log_leave: "{name} left.", log_create: "{name} created room.", log_fold: "{name} Folded", log_check: "{name} Checked", log_call: "{name} Called ${amount}", log_raise: "{name} Raised to ${amount}", log_all_in: "{name} All-in ${amount}", log_phase_flop: "--- Flop ---", log_phase_turn: "--- Turn ---", log_phase_river: "--- River ---", log_refund: "Refunding ${amount} to {name}", log_win_sole: "--- {name} Wins ${amount} ---", log_round_end_no_winner: "--- Round End (No Winner?) ---", log_showdown_result: "{potName}(${amount}): {winners} Wins", log_game_over: "--- Game Over! {name} Wins! ---", log_auto_all_in: "--- Auto All-in (Blinds) ---", log_new_round: "--- New Round ---", log_host_change: "Host is now {name}.", main_pot: "Main Pot", side_pot: "Side Pot"
      },
      ja: {
        connecting: "サーバーに接続中...", gameTitle: "テキサスホールデム", nicknameLabel: "ニックネーム", roomIdLabel: "ルームID", joinRoomBtn: "参加する", createRoomBtn: "作成する", pot: "ポット", room: "部屋", online: "人数", leaveRoomBtn: "退出", raiseLabel: "額", foldBtn: "降りる", checkBtn: "チェック", callBtn: "コール", raiseBtn: "レイズ", allInBtn: "オールイン", phaseLabel: "フェーズ", waiting: "待機中", initialChips: "初期チップ", bigBlind: "ビッグブラインド", smallBlindAuto: "SB自動", waitForHost: "ホストの開始待ち...", startGameBtn: "ゲーム開始", waitPlayerBtn: "参加者待ち", status_fold: "フォールド", status_check: "チェック", status_call: "コール", status_raise: "レイズ", status_all_in: "オールイン", status_small_blind: "SB", status_big_blind: "BB", status_eliminated: "敗退", status_won: "勝利", phase_preflop: "プリフロップ", phase_flop: "フロップ", phase_turn: "ターン", phase_river: "リバー", phase_showdown: "ショーダウン", hand_high_card: "ハイカード", hand_pair: "ワンペア", hand_two_pairs: "ツーペア", hand_three_of_a_kind: "スリーカード", hand_straight: "ストレート", hand_flush: "フラッシュ", hand_full_house: "フルハウス", hand_four_of_a_kind: "フォーカード", hand_straight_flush: "ストレートフラッシュ", msg_your_turn: "あなたの番です", msg_thinking: " 思考中...", msg_winner: "優勝！", msg_bankruptcy: "破産しました。観戦モードへ。", msg_game_reset: "リセット中...", error_nickname: "名前は2〜10文字", error_room_id: "IDを入力してください", error_room_dead: "部屋が無効です", error_room_full: "満員です", error_game_started: "ゲーム進行中", error_join_fail: "参加失敗", bet_prefix: "ベット", call_prefix: "コール", log_welcome: "システム: テキサスホールデムへようこそ。", log_join: "{name} が参加しました。", log_leave: "{name} が退出しました。", log_create: "{name} が部屋を作成しました。", log_fold: "{name} 降りる", log_check: "{name} チェック", log_call: "{name} コール ${amount}", log_raise: "{name} レイズ ${amount}", log_all_in: "{name} オールイン ${amount}", log_phase_flop: "--- フロップ ---", log_phase_turn: "--- ターン ---", log_phase_river: "--- リバー ---", log_refund: "{name}に ${amount} を返却", log_win_sole: "--- {name} が ${amount} を獲得 ---", log_round_end_no_winner: "--- 勝者なし？終了 ---", log_showdown_result: "{potName}(${amount}): {winners} 勝利", log_game_over: "--- ゲーム終了! 優勝は {name}! ---", log_auto_all_in: "--- 自動オールイン ---", log_new_round: "--- 新しいラウンド ---", log_host_change: "ホストが {name} になりました。", main_pot: "メインポット", side_pot: "サイドポット"
      },
      zh: {
        connecting: "连接服务器中...", gameTitle: "德州扑克 (联机版)", nicknameLabel: "你的昵称", roomIdLabel: "房间 ID", joinRoomBtn: "加入房间", createRoomBtn: "创建房间", pot: "底池", room: "房间", online: "在线", leaveRoomBtn: "退出", raiseLabel: "加注", foldBtn: "弃牌", checkBtn: "过牌", callBtn: "跟注", raiseBtn: "加注", allInBtn: "全押", phaseLabel: "阶段", waiting: "等待中", initialChips: "初始筹码", bigBlind: "大盲注", smallBlindAuto: "小盲自动", waitForHost: "等待房主开始...", startGameBtn: "开始游戏", waitPlayerBtn: "等待玩家", status_fold: "弃牌", status_check: "过牌", status_call: "跟注", status_raise: "加注", status_all_in: "全押", status_small_blind: "小盲", status_big_blind: "大盲", status_eliminated: "淘汰", status_won: "获胜", phase_preflop: "翻牌前", phase_flop: "翻牌", phase_turn: "转牌", phase_river: "河牌", phase_showdown: "摊牌", hand_high_card: "高牌", hand_pair: "一对", hand_two_pairs: "两对", hand_three_of_a_kind: "三条", hand_straight: "顺子", hand_flush: "同花", hand_full_house: "葫芦", hand_four_of_a_kind: "四条", hand_straight_flush: "同花顺", msg_your_turn: "你的回合", msg_thinking: " 思考中", msg_winner: "你是冠军！", msg_bankruptcy: "你已破产，进入观战模式", msg_game_reset: "游戏即将重置...", error_nickname: "昵称必须2-10字符", error_room_id: "请输入房间ID", error_room_dead: "房间已失效", error_room_full: "房间已满", error_game_started: "游戏已开始", error_join_fail: "加入失败", bet_prefix: "下注", call_prefix: "跟注", log_welcome: "系统: 欢迎游玩德州扑克。", log_join: "{name} 加入了房间。", log_leave: "{name} 离开了房间。", log_create: "{name} 创建了房间。", log_fold: "{name} 弃牌", log_check: "{name} 过牌", log_call: "{name} 跟注 ${amount}", log_raise: "{name} 加注至 ${amount}", log_all_in: "{name} 全押 ${amount}", log_phase_flop: "--- 翻牌 ---", log_phase_turn: "--- 转牌 ---", log_phase_river: "--- 河牌 ---", log_refund: "退还 ${amount} 给 {name}", log_win_sole: "--- {name} 获胜, 赢得 ${amount} ---", log_round_end_no_winner: "--- 无人获胜？回合结束 ---", log_showdown_result: "{potName}(${amount}): {winners} 获胜", log_game_over: "--- 游戏结束! {name} 获胜! ---", log_auto_all_in: "--- 盲注导致全押 ---", log_new_round: "--- 新回合开始 ---", log_host_change: "房主移交给 {name}。", main_pot: "主池", side_pot: "边池"
      }
    };

    let currentLang = "en";
    const t = (key, args = {}) => {
      let text = TRANSLATIONS[currentLang][key] || key;
      Object.keys(args).forEach(argKey => { text = text.replace(`{${argKey}}`, args[argKey]); });
      return text;
    };
    const createLog = (key, args = {}) => JSON.stringify({ key, args });

    window.updateLanguage = (lang) => {
      currentLang = lang; document.documentElement.lang = lang;
      document.querySelectorAll("[data-i18n]").forEach(el => { el.innerText = t(el.getAttribute("data-i18n")); });
      if (gameUI && gameUI.lastState) gameUI.renderGameState(gameUI.lastState, network.localUserId);
    };

    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    const SUITS = ["♠", "♥", "♣", "♦"];
    const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    const RANK_VALUES = { 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, J: 11, Q: 12, K: 13, A: 14 };
    const PHASE_KEY_MAP = { waiting: "waiting", preflop: "phase_preflop", flop: "phase_flop", turn: "phase_turn", river: "phase_river", showdown: "phase_showdown" };

    let db, auth, app, localUserId = null, localPlayerName = "Guest", sound;
    const firebaseConfig = typeof __firebase_config !== "undefined" ? JSON.parse(__firebase_config) : { apiKey: "AIzaSyBX_mHFj3VHsx6U38Ib9pDJWCrnlSlR_g4", authDomain: "texas-hold-em-poker-1.firebaseapp.com", projectId: "texas-hold-em-poker-1", storageBucket: "texas-hold-em-poker-1.firebasestorage.app", messagingSenderId: "401916350194", appId: "1:401916350194:web:2b38d3da714968c8cd0a6b" };
    const appId = typeof __app_id !== "undefined" ? __app_id : "poker-game-test";
    const initialAuthToken = typeof __initial_auth_token !== "undefined" ? __initial_auth_token : null;

    // --- GAME LOGIC (PURE) ---
    function processAction(currentState, actingUserId, action, amount = 0) {
      let newState = JSON.parse(JSON.stringify(currentState));
      const config = newState.config || { bigBlind: 20 };
      let player = newState.players[actingUserId];
      if (newState.playerOrder[newState.currentPlayerIndex] !== actingUserId) return currentState;
      if (player.folded || (player.chips === 0 && newState.phase !== "waiting")) {
        newState.currentPlayerIndex = (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
        return newState;
      }
      const diff = newState.currentMaxBet - player.currentBet;
      let triggerAllIn = false, logJson = "";
      if (action === "fold") { player.folded = true; player.status = "status_fold"; logJson = createLog("log_fold", { name: player.name }); }
      else if (action === "check") { if (diff > 0) return currentState; player.status = "status_check"; logJson = createLog("log_check", { name: player.name }); }
      else if (action === "call") {
        let callAmt = Math.min(diff, player.chips); let isAllIn = callAmt === player.chips && diff > 0;
        player.chips -= callAmt; player.currentBet += callAmt; newState.pot += callAmt; player.status = isAllIn ? "status_all_in" : "status_call";
        logJson = createLog(isAllIn ? "log_all_in" : "log_call", { name: player.name, amount: callAmt }); if (isAllIn) triggerAllIn = true;
      } else if (action === "raise") {
        let actualAmt = amount; if (actualAmt <= newState.currentMaxBet && actualAmt < player.chips) return currentState;
        if (actualAmt - newState.currentMaxBet < newState.lastRaiseAmount && actualAmt < player.chips) return currentState;
        let raiseAmt = actualAmt - player.currentBet; let isAllIn = raiseAmt >= player.chips;
        if (isAllIn) { actualAmt = player.chips + player.currentBet; raiseAmt = player.chips; triggerAllIn = true; }
        player.chips -= raiseAmt; player.currentBet = actualAmt; newState.pot += raiseAmt;
        if (!isAllIn || actualAmt - newState.currentMaxBet >= newState.lastRaiseAmount) newState.lastRaiseAmount = actualAmt - newState.currentMaxBet;
        newState.currentMaxBet = actualAmt; newState.playersActed.length = 0;
        player.status = isAllIn ? "status_all_in" : "status_raise";
        logJson = createLog(isAllIn ? "log_all_in" : "log_raise", { name: player.name, amount: actualAmt });
      }
      if (logJson) { newState.logs.push(logJson); if (newState.logs.length > 20) newState.logs.shift(); }
      if (!newState.playersActed.includes(actingUserId)) newState.playersActed.push(actingUserId);
      
      const active = newState.playerOrder.map(uid => newState.players[uid]).filter(p => !p.folded);
      const withChips = active.filter(p => p.chips > 0);
      const isRoundComp = active.every(p => {
        const isAllIn = p.chips === 0 && !p.folded; const match = p.currentBet === newState.currentMaxBet; const acted = newState.playersActed.includes(p.uid);
        if (isAllIn) return true;
        if (newState.phase === 'preflop' && newState.currentMaxBet === config.bigBlind) {
          if (p.uid === newState.playerOrder[(newState.dealerIndex + 2) % newState.playerOrder.length] && !acted) return false;
        }
        return acted && match;
      });

      if (active.length === 1) newState = advanceToShowdown(newState, active[0]);
      else if (isRoundComp && withChips.length <= 1 && newState.phase !== "showdown") newState = runAutoShowdown(newState);
      else if (isRoundComp) newState = advanceToNextPhase(newState);
      else {
        let loops = 0;
        do {
          newState.currentPlayerIndex = (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
          const next = newState.players[newState.playerOrder[newState.currentPlayerIndex]];
          if (next.folded || next.chips === 0) { loops++; continue; } break;
        } while (loops <= newState.playerOrder.length * 2);
      }
      if (triggerAllIn) newState.lastAllInPlayer = player.name;
      return newState;
    }

    function advanceToNextPhase(state) {
      let ns = JSON.parse(JSON.stringify(state)); ns = returnExcessBets(ns);
      ns.playerOrder.forEach(uid => { ns.players[uid].accumulatedBet += ns.players[uid].currentBet; ns.players[uid].currentBet = 0; ns.players[uid].status = ""; });
      ns.currentMaxBet = 0; ns.lastRaiseAmount = ns.config.bigBlind; ns.playersActed = [];
      if (ns.phase === "preflop") { ns.phase = "flop"; ns.communityCards.push(ns.deck.pop(), ns.deck.pop(), ns.deck.pop()); ns.logs.push(createLog("log_phase_flop")); }
      else if (ns.phase === "flop") { ns.phase = "turn"; ns.communityCards.push(ns.deck.pop()); ns.logs.push(createLog("log_phase_turn")); }
      else if (ns.phase === "turn") { ns.phase = "river"; ns.communityCards.push(ns.deck.pop()); ns.logs.push(createLog("log_phase_river")); }
      else if (ns.phase === "river") { return advanceToShowdown(ns); }
      let next = (ns.dealerIndex + 1) % ns.playerOrder.length;
      while (ns.players[ns.playerOrder[next]].folded || ns.players[ns.playerOrder[next]].chips === 0) next = (next + 1) % ns.playerOrder.length;
      ns.currentPlayerIndex = next;
      return ns;
    }

    function runAutoShowdown(state) {
      let ns = JSON.parse(JSON.stringify(state)); ns = returnExcessBets(ns);
      ns.playerOrder.forEach(uid => { const p = ns.players[uid]; p.accumulatedBet += p.currentBet; p.currentBet = 0; p.status = p.chips === 0 && !p.folded ? "status_all_in" : p.status; });
      ns.currentPlayerIndex = -1;
      if (ns.phase === "preflop") { ns.phase = "flop"; ns.communityCards.push(ns.deck.pop(), ns.deck.pop(), ns.deck.pop()); ns.logs.push(createLog("log_phase_flop")); ns.nextPhaseTimer = 1500; }
      else if (ns.phase === "flop") { ns.phase = "turn"; ns.communityCards.push(ns.deck.pop()); ns.logs.push(createLog("log_phase_turn")); ns.nextPhaseTimer = 1500; }
      else if (ns.phase === "turn") { ns.phase = "river"; ns.communityCards.push(ns.deck.pop()); ns.logs.push(createLog("log_phase_river")); ns.nextPhaseTimer = 1500; }
      else if (ns.phase === "river") { ns.nextPhaseTimer = 0; ns = advanceToShowdown(ns); }
      return ns;
    }

    function returnExcessBets(state) {
      let ns = JSON.parse(JSON.stringify(state));
      const active = ns.playerOrder.map(uid => ns.players[uid]).filter(p => !p.folded).sort((a, b) => b.currentBet - a.currentBet);
      if (active.length < 2) return ns;
      if (active[0].currentBet > active[1].currentBet) {
        const refund = active[0].currentBet - active[1].currentBet;
        const p = ns.players[active[0].uid]; p.chips += refund; p.currentBet -= refund; ns.pot -= refund;
        ns.logs.push(createLog("log_refund", { amount: refund, name: p.name }));
      }
      return ns;
    }

    function advanceToShowdown(state, soleWinner = null) {
      let ns = JSON.parse(JSON.stringify(state)); ns.phase = "showdown"; ns.currentPlayerIndex = -1;
      if (soleWinner) {
        const w = ns.players[soleWinner.uid]; ns.playerOrder.forEach(uid => ns.players[uid].currentBet = 0);
        w.chips += ns.pot; ns.logs.push(createLog("log_win_sole", { name: w.name, amount: ns.pot })); ns.highlightWinner = w.uid;
      } else {
        ns.playerOrder.forEach(uid => { const p = ns.players[uid]; p.accumulatedBet += p.currentBet; ns.pot += p.currentBet; p.currentBet = 0; }); // Fix pot calc: accum is total per player
        let finalPot = 0; ns.playerOrder.forEach(uid => finalPot += ns.players[uid].accumulatedBet); ns.pot = finalPot;
        const active = ns.playerOrder.map(uid => ns.players[uid]).filter(p => !p.folded);
        if (active.length === 0) ns.logs.push(createLog("log_round_end_no_winner"));
        else {
          active.forEach(p => p.bestHand = HandEvaluator.evaluate(p.holeCards, ns.communityCards));
          const bets = [...new Set(active.map(p => p.accumulatedBet))].filter(b => b > 0).sort((a, b) => a - b);
          let prevBet = 0, winnerLogs = []; ns.highlightCards = new Set();
          bets.forEach((lvl, idx) => {
            let potAmt = 0; ns.playerOrder.forEach(uid => { const p = ns.players[uid]; if (p.accumulatedBet >= lvl) potAmt += lvl - prevBet; else if (p.accumulatedBet > prevBet) potAmt += p.accumulatedBet - prevBet; });
            const contrib = active.filter(p => p.accumulatedBet >= lvl);
            if (potAmt > 0 && contrib.length > 0) {
              let bestScore = -1, winners = [];
              contrib.forEach(p => { if (p.bestHand.score > bestScore) { bestScore = p.bestHand.score; winners = [p]; } else if (Math.abs(p.bestHand.score - bestScore) < 0.1) winners.push(p); });
              const winPer = Math.floor(potAmt / winners.length); let rem = potAmt % winners.length;
              const potName = idx === 0 ? "Main" : `Side ${idx}`;
              winnerLogs.push(createLog("log_showdown_result", { potName, amount: potAmt, winners: winners.map(w => w.name).join(", ") }));
              winners.forEach(w => { let gain = winPer + (rem-- > 0 ? 1 : 0); ns.players[w.uid].chips += gain; ns.highlightWinner = w.uid; w.bestHand.bestCards.forEach(c => ns.highlightCards.add(c.id)); });
            }
            prevBet = lvl;
          });
          ns.highlightCards = Array.from(ns.highlightCards); ns.logs.push(...winnerLogs);
        }
      }
      ns.nextRoundTimer = 6000; sound.playHandEnd(); return ns;
    }

    function startNewRound(state) {
      let ns = JSON.parse(JSON.stringify(state));
      const conf = ns.config || { initialChips: 2000, smallBlind: 10, bigBlind: 20 };
      let activeIds = Object.keys(ns.players).filter(uid => ns.players[uid].chips > 0);
      // If eliminated, mark status
      Object.keys(ns.players).forEach(uid => { if (ns.players[uid].chips <= 0) { ns.players[uid].folded = true; ns.players[uid].status = "status_eliminated"; } });
      
      if (activeIds.length < 2) {
        const wId = activeIds[0]; let logs = [...ns.logs, createLog("log_game_over", { name: wId ? ns.players[wId].name : "None" })];
        const resetP = {}; Object.keys(ns.players).forEach(uid => resetP[uid] = { ...ns.players[uid], chips: conf.initialChips, holeCards: [], folded: false, currentBet: 0, accumulatedBet: 0, status: "waiting", bestHand: null });
        return { status: "waiting", hostId: ns.hostId, config: conf, players: resetP, playerOrder: Object.keys(ns.players), communityCards: [], pot: 0, dealerIndex: 0, currentPlayerIndex: -1, currentMaxBet: 0, phase: "waiting", lastRaiseAmount: conf.bigBlind, deck: [], logs, highlightWinner: wId, highlightCards: [], nextRoundTimer: 0, nextPhaseTimer: 0 };
      }
      
      ns.playerOrder = activeIds; ns.communityCards = []; ns.pot = 0; ns.currentMaxBet = 0; ns.lastRaiseAmount = conf.bigBlind; ns.phase = "preflop"; ns.playersActed = []; ns.highlightWinner = null; ns.highlightCards = []; ns.nextRoundTimer = 0; ns.nextPhaseTimer = 0;
      ns.playerOrder.forEach(uid => { const p = ns.players[uid]; p.holeCards = []; p.folded = false; p.currentBet = 0; p.accumulatedBet = 0; p.status = ""; p.bestHand = null; });
      
      let deck = [];
      for (let s of SUITS) for (let r of RANKS) deck.push({ suit: s, rank: r, value: RANK_VALUES[r], color: "♥♦".includes(s) ? "red" : "black", id: Math.random().toString(36).substr(2, 9) });
      for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; }
      ns.deck = deck;

      ns.dealerIndex = (ns.dealerIndex + 1) % ns.playerOrder.length;
      const sbIdx = (ns.dealerIndex + 1) % ns.playerOrder.length; const bbIdx = (ns.dealerIndex + 2) % ns.playerOrder.length;
      const sb = ns.players[ns.playerOrder[sbIdx]]; const bb = ns.players[ns.playerOrder[bbIdx]];
      const sbAmt = Math.min(conf.smallBlind, sb.chips); sb.chips -= sbAmt; sb.currentBet = sbAmt; sb.status = sb.chips === 0 ? "status_all_in" : "status_small_blind";
      const bbAmt = Math.min(conf.bigBlind, bb.chips); bb.chips -= bbAmt; bb.currentBet = bbAmt; bb.status = bb.chips === 0 ? "status_all_in" : "status_big_blind";
      ns.pot = sbAmt + bbAmt; ns.currentMaxBet = conf.bigBlind;

      for (let i = 0; i < 2; i++) for (let uid of ns.playerOrder) ns.players[uid].holeCards.push(ns.deck.pop());
      
      let next = (bbIdx + 1) % ns.playerOrder.length;
      while (ns.players[ns.playerOrder[next]].chips === 0) next = (next + 1) % ns.playerOrder.length;
      ns.currentPlayerIndex = next;

      const wChips = ns.playerOrder.filter(uid => ns.players[uid].chips > 0);
      if (wChips.length <= 1) { ns.logs.push(createLog("log_auto_all_in")); return runAutoShowdown(ns); }
      ns.logs.push(createLog("log_new_round"));
      return ns;
    }

    // --- ANIMATION MANAGER ---
    class AnimationManager {
      constructor(gameUI) {
        this.gameUI = gameUI;
        this.layer = document.getElementById('animation-layer');
        this.isAnimating = false;
      }

      async playDealHoleCards(players, dealerIndex, localId) {
        this.isAnimating = true;
        const totalTime = 1000; // 1 second total deal time
        // Get dealer position (or default center top)
        const dealerSeat = document.getElementById(`dealer-${players[dealerIndex]}`);
        const startRect = dealerSeat ? dealerSeat.getBoundingClientRect() : { top: window.innerHeight/2, left: window.innerWidth/2 };
        
        // Identify target seats
        const targets = players.map(uid => {
          const el = document.getElementById(`cards-${uid}`);
          return el ? el.getBoundingClientRect() : null;
        });

        // Determine order starting left of dealer
        const num = players.length;
        const dealOrder = [];
        for(let k=0; k<2; k++) { // 2 cards
          for(let i=1; i<=num; i++) {
            const idx = (dealerIndex + i) % num;
            if(targets[idx]) dealOrder.push({ uid: players[idx], rect: targets[idx] });
          }
        }

        const delayPerCard = totalTime / dealOrder.length;

        // Play dealing sounds and animation
        for (let i = 0; i < dealOrder.length; i++) {
          const target = dealOrder[i];
          this.spawnFlyingCard(startRect, target.rect, i * delayPerCard);
          setTimeout(() => sound.playCard(), i * delayPerCard);
        }

        await sleep(totalTime + 500);
        
        // Flip local player cards
        const localCardsDiv = document.getElementById(`cards-${localId}`);
        if(localCardsDiv) {
          const cards = localCardsDiv.querySelectorAll('.card-obj');
          cards.forEach(c => c.classList.remove('is-flipped')); // Remove flipped (back visible) -> front visible
          sound.playCard();
        }
        this.isAnimating = false;
      }

      async playCommunityCards(newCards, startIndex) {
        this.isAnimating = true;
        const startEl = document.getElementById('table');
        const startRect = startEl ? { top: startEl.getBoundingClientRect().top + 50, left: window.innerWidth/2 } : { top: 0, left: 0 };
        
        // Flop case: 3 cards
        if (newCards.length === 3) {
          const flyers = [];
          for(let i=0; i<3; i++) {
            const slot = document.getElementById(`comm-slot-${i}`);
            if(slot) {
              const target = slot.getBoundingClientRect();
              // Spawn face down
              const el = this.spawnFlyingCard(startRect, target, i * 100, true); 
              flyers.push(el);
              setTimeout(() => sound.playCard(), i * 100);
            }
          }
          await sleep(600);
          // Flip all 3
          flyers.forEach(el => {
             // The flying card is a clone. We rely on the REAL card being rendered underneath.
             // But wait, real cards are hidden by opacity logic in render.
             // Actually, let's just flip the real cards now.
             const realSlot = document.getElementById(`comm-slot-${startIndex+flyers.indexOf(el)}`);
             if(realSlot && realSlot.firstChild) {
               realSlot.firstChild.classList.remove('is-flipped'); // Reveal
             }
             el.remove(); // Remove ghost
          });
          sound.playCard();
        } else {
          // Turn/River
          const i = startIndex; // 3 or 4
          const slot = document.getElementById(`comm-slot-${i}`);
          if(slot) {
            const target = slot.getBoundingClientRect();
            const el = this.spawnFlyingCard(startRect, target, 0, true);
            sound.playCard();
            await sleep(500);
            const realSlot = document.getElementById(`comm-slot-${i}`);
            if(realSlot && realSlot.firstChild) realSlot.firstChild.classList.remove('is-flipped');
            el.remove();
          }
        }
        this.isAnimating = false;
      }

      playFoldAnimation(uid) {
        const cardsDiv = document.getElementById(`cards-${uid}`);
        const infoBox = document.querySelector(`#seat-${uid} .player-info-box`);
        if(cardsDiv && infoBox) {
          const rectStart = cardsDiv.getBoundingClientRect();
          const rectEnd = infoBox.getBoundingClientRect();
          
          const ghost = document.createElement('div');
          ghost.className = 'card card-back flying-card';
          ghost.style.width = '42px'; ghost.style.height = '60px';
          if(window.innerWidth >= 768) { ghost.style.width = '56px'; ghost.style.height = '78px'; }
          ghost.style.left = rectStart.left + 'px';
          ghost.style.top = rectStart.top + 'px';
          document.body.appendChild(ghost);

          requestAnimationFrame(() => {
            ghost.style.left = rectEnd.left + (rectEnd.width/2 - 20) + 'px';
            ghost.style.top = rectEnd.top + 'px';
            ghost.style.opacity = '0';
            ghost.style.transform = 'scale(0.5)';
          });
          
          sound.playFold();
          setTimeout(() => ghost.remove(), 500);
        }
      }

      flipAllShowdown(players) {
        Object.keys(players).forEach(uid => {
          const div = document.getElementById(`cards-${uid}`);
          if(div) {
            const cards = div.querySelectorAll('.card-obj');
            cards.forEach((c, i) => {
              setTimeout(() => c.classList.remove('is-flipped'), i * 100);
            });
          }
        });
      }

      spawnFlyingCard(startRect, targetRect, delay, stay = false) {
        const card = document.createElement('div');
        card.className = 'card card-back flying-card';
        // Match dimensions
        card.style.width = '42px'; card.style.height = '60px';
        if(window.innerWidth >= 768) { card.style.width = '56px'; card.style.height = '78px'; }
        
        card.style.left = startRect.left + 'px';
        card.style.top = startRect.top + 'px';
        document.body.appendChild(card);

        setTimeout(() => {
          card.style.left = targetRect.left + 'px';
          card.style.top = targetRect.top + 'px';
        }, delay);

        if(!stay) setTimeout(() => card.remove(), delay + 500);
        return card;
      }
    }

    // --- UI MANAGER ---
    class GameUIManager {
      constructor() {
        this.sound = new SoundManager();
        this.dragSystem = new TableDragSystem();
        this.occlusionManager = new OcclusionManager();
        this.animator = new AnimationManager(this);
        this.lastState = null; this.localPlayerId = null; this.lastActivePlayerId = null;
        this.highlightCards = new Set(); this.bankruptcyScreenShown = false; this.lastAllInPlayerTriggered = null;
        document.getElementById("raise-slider").oninput = () => {
          const s = document.getElementById("raise-slider"), b = document.getElementById("btn-raise"), v = document.getElementById("raise-val-display");
          if(s && b && v && !s.disabled) { v.innerText = `$${s.value}`; b.innerText = parseInt(s.value) === parseInt(s.max) ? t("allInBtn") : `${t("raiseBtn")} $${s.value}`; }
        };
      }

      initSound() { this.sound.init(); sound = this.sound; }

      renderGameState(state, localId) {
        if (!state) return;
        this.initSound();
        const lastPhase = this.lastState ? this.lastState.phase : null;
        const currentPhase = state.phase;

        // Detect Phase Changes for Animation
        if(lastPhase !== currentPhase) {
          if(lastPhase === 'waiting' && currentPhase === 'preflop') {
            // Deal Animation
            this.animator.playDealHoleCards(state.playerOrder, state.dealerIndex, localId);
          } else if (currentPhase === 'flop') {
            this.animator.playCommunityCards(state.communityCards, 0);
          } else if (currentPhase === 'turn') {
            this.animator.playCommunityCards(state.communityCards, 3);
          } else if (currentPhase === 'river') {
            this.animator.playCommunityCards(state.communityCards, 4);
          } else if (currentPhase === 'showdown') {
            setTimeout(() => this.animator.flipAllShowdown(state.players), 500);
          }
        }

        // Detect Folds
        if(this.lastState) {
          state.playerOrder.forEach(uid => {
            if(!this.lastState.players[uid].folded && state.players[uid].folded) {
              this.animator.playFoldAnimation(uid);
            }
          });
        }

        // Standard Log Sound
        const lastLogStr = state.logs.length > 0 ? state.logs[state.logs.length - 1] : "";
        const prevLogStr = (this.lastState && this.lastState.logs.length > 0) ? this.lastState.logs[this.lastState.logs.length - 1] : "";
        if (this.lastState && (state.logs.length > this.lastState.logs.length || (state.logs.length > 0 && lastLogStr !== prevLogStr))) {
          let logKey = ""; try { logKey = JSON.parse(lastLogStr).key; } catch(e) { logKey = lastLogStr; }
          if (logKey === "log_check") this.sound.playCheck();
          else if (logKey === "log_call") this.sound.playChip();
          else if (logKey === "log_raise") this.sound.playRaise();
        }

        this.highlightCards = new Set(state.highlightCards || []);
        document.getElementById("active-players-count").innerText = state.playerOrder.length;

        if (state.lastAllInPlayer && (!this.lastState || state.lastAllInPlayer !== this.lastState.lastAllInPlayer)) {
          if (state.lastAllInPlayer !== this.lastAllInPlayerTriggered) { this.showAllInEffect(state.lastAllInPlayer); this.lastAllInPlayerTriggered = state.lastAllInPlayer; }
        }
        if (state.phase === "showdown") this.lastAllInPlayerTriggered = null;

        this.lastState = state; this.localPlayerId = localId;
        const localPlayer = state.players[localId];

        document.getElementById("pot-display").innerText = state.pot;
        document.getElementById("phase-display").innerText = t(PHASE_KEY_MAP[state.phase] || state.phase);
        if (state.config) document.getElementById("blinds-display").innerText = `${t("bigBlind")} $${state.config.bigBlind}`;

        this.renderTableLayout(state, localId); // Smart render (reuses elements)

        // Community Cards Render
        for (let i = 0; i < 5; i++) {
          const slot = document.getElementById(`comm-slot-${i}`);
          if (!slot) continue;
          const cData = state.communityCards[i];
          if (cData) {
            let cardEl = slot.firstElementChild;
            if (!cardEl) {
              // Newly created cards start flipped (back visible) if triggered by phase change logic above
              // EXCEPT if we are just loading the page and the game is already in river.
              // Simple logic: Create flipped, remove flip class if it's old.
              cardEl = this.createCardObj(cData);
              // If this card is brand new (not in lastState), start flipped
              const isNew = !this.lastState || !this.lastState.communityCards[i];
              if(isNew) cardEl.classList.add('is-flipped'); 
              else cardEl.classList.remove('is-flipped');
              slot.appendChild(cardEl);
            } else {
              // Update existing
              if(this.highlightCards.has(cData.id)) cardEl.querySelector('.card-face.face-front').classList.add('winning-card');
              else cardEl.querySelector('.card-face.face-front').classList.remove('winning-card');
            }
          } else { slot.innerHTML = ""; }
        }

        // Logs
        const logDiv = document.getElementById("game-log");
        logDiv.innerHTML = state.logs.map((logStr) => {
          let msg = logStr; try { const o = JSON.parse(logStr); if (o.key) { msg = t(o.key, o.args); if (o.key === "log_showdown_result") { const raw = o.args.potName; msg = msg.replace(raw, raw === "Main" ? t("main_pot") : raw.startsWith("Side") ? t("side_pot") + " " + raw.split(" ")[1] : raw); } } } catch (e) {}
          return `<div>> ${msg}</div>`;
        }).join("");
        logDiv.scrollTop = logDiv.scrollHeight;

        this.updateControls(state);
        // Winner/Loss Logic
        if (localPlayer) {
          const lastLog = state.logs.length > 0 ? state.logs[state.logs.length - 1] : "";
          const isChamp = state.status === "waiting" && state.highlightWinner === localId && lastLog.includes("log_game_over");
          const isElim = localPlayer.status === "status_eliminated" && localPlayer.chips === 0;
          if (isChamp && !this.bankruptcyScreenShown) { this.sound.playWin(); this.showMessage(t("msg_winner")); this.bankruptcyScreenShown = true; }
          else if (isElim && state.status === "playing" && !this.bankruptcyScreenShown) { this.sound.playLose(); this.showMessage(t("msg_bankruptcy")); this.bankruptcyScreenShown = true; }
          else if (state.status === "waiting" && !isChamp) this.bankruptcyScreenShown = false;
        }

        const waitOverlay = document.getElementById("waiting-room-overlay");
        if (state.status === "waiting") { waitOverlay.classList.remove("hidden"); network.updateWaitingRoomUI(state, localId); }
        else waitOverlay.classList.add("hidden");
      }

      // REFACTORED: Updates DOM instead of clearing it
      renderTableLayout(state, localId) {
        const container = document.getElementById("seats-container");
        const players = state.phase === "waiting" ? state.playerOrder : state.playerOrder;
        const num = players.length;
        if (num === 0) { container.innerHTML = ""; return; }

        const w = container.offsetWidth, h = container.offsetHeight;
        const cx = w / 2, cy = h / 2;
        const localIdx = players.indexOf(localId);
        const renderIdx = localIdx === -1 ? 0 : localIdx;
        
        let scale = 1, rx = 0.38, ry = 0.38;
        if (num > 6) { scale = 0.85; rx = 0.42; ry = 0.42; }
        if (num >= 9) { scale = 0.75; rx = 0.44; ry = 0.44; }
        if (w < 768) { if (num > 5) scale = 0.75; if (num > 8) scale = 0.65; rx = 0.4; }
        const rX = w * rx, rY = h * ry;

        // Mark current seats to detect removals
        const activeSeats = new Set();

        players.forEach((uid, i) => {
          const p = state.players[uid]; if (!p) return;
          activeSeats.add(`seat-${uid}`);
          
          const offIdx = (i - renderIdx + num) % num;
          const angle = Math.PI / 2 + (offIdx * (2 * Math.PI)) / num;
          const x = cx + rX * Math.cos(angle) - 60;
          const y = cy + rY * Math.sin(angle) - 55;

          let div = document.getElementById(`seat-${uid}`);
          if (!div) {
            div = document.createElement("div"); div.id = `seat-${uid}`; div.className = "player-seat";
            div.innerHTML = `<div id="cards-${uid}" class="absolute flex space-x-1 z-10 transition-all" style="top:-50px;"></div><div class="player-info-box relative z-20"></div>`;
            container.appendChild(div);
          }
          div.style.left = `${x}px`; div.style.top = `${y}px`; div.style.transform = `scale(${scale})`;
          
          // Update Info Box
          const box = div.querySelector('.player-info-box');
          let statusText = p.currentBet > 0 ? `${t("bet_prefix")} $${p.currentBet}` : (p.status ? (p.status.startsWith("hand_") ? t(p.status) : t(p.status)) : "");
          box.innerHTML = `
            <div id="dealer-${uid}" class="dealer-btn ${i === state.dealerIndex ? "" : "hidden"}">D</div>
            <div class="font-bold text-yellow-400 truncate text-sm tracking-wide">${p.name}</div>
            <div class="text-white text-xs font-mono">$<span id="chips-${uid}">${p.chips}</span></div>
            <div class="text-gray-400 text-[10px] h-4 truncate font-bold uppercase mt-1">${statusText}</div>`;

          // Update Cards (3D)
          const cardCont = div.querySelector(`#cards-${uid}`);
          if (!p.folded && p.holeCards.length > 0) {
            // Only rebuild if count changed or showdown reveals
            // Check if we need to show back or front
            const activeCount = Object.values(state.players).filter(pl => !pl.folded).length;
            const showFront = (p.uid === localId) || (state.phase === "showdown" && activeCount > 1);
            
            // Sync cards
            if(cardCont.children.length !== p.holeCards.length) {
              cardCont.innerHTML = "";
              p.holeCards.forEach(c => {
                const cObj = this.createCardObj(c);
                // If just dealt (preflop), local player sees back initially, then flip animation handles it
                // But here we are in render loop.
                // If showFront is true, ensure class 'is-flipped' is REMOVED.
                // If showFront is false, ensure class 'is-flipped' is ADDED.
                if(!showFront) cObj.classList.add('is-flipped');
                else cObj.classList.remove('is-flipped'); 
                
                // Special case: Preflop just started, local player.
                // The AnimationManager handles the initial "flipped" state and transition.
                // Here we just enforce final state.
                if(state.phase === 'preflop' && p.uid === localId && this.animator.isAnimating) {
                   cObj.classList.add('is-flipped'); // Force back during deal animation
                }

                cardCont.appendChild(cObj);
              });
            } else {
              // Update existing cards flip state
              Array.from(cardCont.children).forEach((cObj, idx) => {
                 if(!showFront) cObj.classList.add('is-flipped');
                 else if(!this.animator.isAnimating) cObj.classList.remove('is-flipped');
                 
                 // Update highlight
                 const cData = p.holeCards[idx];
                 if(state.highlightWinner === p.uid && this.highlightCards.has(cData.id)) 
                    cObj.querySelector('.face-front').classList.add('winning-card');
                 else 
                    cObj.querySelector('.face-front').classList.remove('winning-card');
              });
            }
          } else {
            cardCont.innerHTML = ""; // Folded
          }

          // Highlights
          if (state.playerOrder[state.currentPlayerIndex] === uid && state.phase !== "showdown") div.classList.add("active-player"); else div.classList.remove("active-player");
          if (state.highlightWinner === uid) div.classList.add("winner-highlight"); else div.classList.remove("winner-highlight");
          div.style.opacity = p.folded ? 0.4 : 1;
        });

        // Cleanup left players
        Array.from(container.children).forEach(child => { if (!activeSeats.has(child.id)) child.remove(); });
      }

      updateControls(state) {
        if (!state || !state.players || !this.localPlayerId) return;
        const lp = state.players[this.localPlayerId];
        const curId = state.playerOrder[state.currentPlayerIndex];
        const curP = state.players[curId];
        if (state.status === "playing" && state.phase !== "showdown" && state.phase !== "waiting") {
          if (this.lastActivePlayerId !== curId) {
            this.lastActivePlayerId = curId;
            if (curId === this.localPlayerId) this.showMessage(t("msg_your_turn"));
            else this.showMessage(`${curP ? curP.name : "Player"} ${t("msg_thinking")}`);
          }
        } else this.lastActivePlayerId = null;

        const c = document.getElementById("player-controls");
        const canAct = (curId === this.localPlayerId) && !lp.folded && lp.chips > 0 && state.phase !== "showdown";
        if (!canAct) { c.classList.add("opacity-50", "pointer-events-none", "translate-y-2"); return; }
        c.classList.remove("opacity-50", "pointer-events-none", "translate-y-2");

        const diff = state.currentMaxBet - lp.currentBet;
        const bCheck = document.getElementById("btn-check"), bCall = document.getElementById("btn-call"), bRaise = document.getElementById("btn-raise"), sl = document.getElementById("raise-slider"), slC = document.getElementById("raise-slider-container");
        bCheck.innerText = t("checkBtn"); bCall.innerText = t("callBtn"); bRaise.innerText = t("raiseBtn"); document.querySelector('[data-i18n="foldBtn"]').innerText = t("foldBtn");

        if (diff === 0) { bCheck.classList.remove("hidden"); bCall.classList.add("hidden"); }
        else { bCheck.classList.add("hidden"); bCall.classList.remove("hidden"); bCall.innerText = lp.chips <= diff ? t("allInBtn") : `${t("callBtn")} $${diff}`; }

        const minR = state.lastRaiseAmount, minAct = diff + minR, maxAct = lp.chips;
        if (lp.chips <= diff) { bRaise.classList.add("hidden"); slC.classList.add("hidden"); }
        else if (maxAct < minAct) { bRaise.classList.remove("hidden"); bRaise.innerText = t("allInBtn"); slC.classList.remove("hidden"); sl.min = maxAct; sl.max = maxAct; sl.value = maxAct; sl.disabled = true; document.getElementById("raise-val-display").innerText = `$${maxAct}`; }
        else { bRaise.classList.remove("hidden"); slC.classList.remove("hidden"); sl.min = minAct; sl.max = maxAct; sl.step = 1; if (sl.value < minAct) sl.value = minAct; sl.disabled = false; sl.dispatchEvent(new Event("input")); }
      }

      adjustRaise(dir) { const s = document.getElementById("raise-slider"); if (!s || s.disabled) return; let v = parseInt(s.value) + dir; if (v >= s.min && v <= s.max) { s.value = v; s.dispatchEvent(new Event("input")); } }
      showMessage(msg) { const el = document.getElementById("game-message"); if(!el)return; el.innerText = msg; el.style.opacity = 1; clearTimeout(this.msgTimeout); this.msgTimeout = setTimeout(() => el.style.opacity = 0, 3000); }
      showAllInEffect(name) {
        return new Promise(r => {
          const ov = document.createElement("div"); ov.className = "all-in-fullscreen-overlay";
          ov.innerHTML = `<div class="all-in-bar"><div class="all-in-text">ALL-IN</div></div>`;
          document.body.appendChild(ov); this.sound.playAllIn();
          setTimeout(() => { ov.style.transition = "opacity 0.3s"; ov.style.opacity = "0"; setTimeout(() => { ov.remove(); r(); }, 300); }, 1250);
        });
      }

      // Create 3D Card Object
      createCardObj(c) {
        const scene = document.createElement("div"); scene.className = "card-scene";
        const obj = document.createElement("div"); obj.className = `card-obj ${c.color}`;
        // Front Face
        const front = document.createElement("div"); front.className = `card-face face-front ${c.color}`;
        if(this.highlightCards.has(c.id)) front.classList.add("winning-card");
        front.innerHTML = `<span class="absolute top-0 left-1 text-xs">${c.rank}</span><span class="text-2xl">${c.suit}</span>`;
        // Back Face
        const back = document.createElement("div"); back.className = "card-face face-back";
        back.innerHTML = `<span></span>`;
        
        obj.appendChild(front); obj.appendChild(back); scene.appendChild(obj);
        return obj;
      }
    }

    // --- NETWORK & SOUND ---
    class NetworkManager {
      constructor(gameUI) { this.gameUI = gameUI; this.db = null; this.auth = null; this.appId = appId; this.localUserId = null; this.currentRoomId = null; this.unsubscribeRoom = null; this.nextRoundTimeout = null; this.nextPhaseTimeout = null; this.heartbeatInterval = null; }
      async init() {
        try { setLogLevel("Debug"); this.app = initializeApp(firebaseConfig); this.db = getFirestore(this.app); this.auth = getAuth(this.app); onAuthStateChanged(this.auth, async (u) => { if (u) { this.localUserId = u.uid; document.getElementById("user-id-display").innerText = this.localUserId; document.getElementById("firebase-loader").classList.add("hidden"); document.getElementById("room-screen").classList.remove("hidden"); } else await this.signIn(); }); } catch (e) {}
      }
      updateWaitingRoomUI(s, lid) {
        const hostC = document.getElementById("wait-host-controls"), btnC = document.getElementById("host-start-btn-container");
        if (s.hostId === lid) {
          hostC.classList.remove("hidden"); document.getElementById("wait-message").classList.add("hidden");
          const cIn = document.getElementById("setting-initial-chips"), bIn = document.getElementById("setting-big-blind");
          if(cIn && !cIn.oninput) cIn.oninput = () => cIn.value = cIn.value.replace(/[^\d]/g, '');
          if(bIn && !bIn.oninput) bIn.oninput = () => { bIn.value = bIn.value.replace(/[^\d]/g, ''); document.getElementById("setting-sb-display").innerText = Math.floor((parseInt(bIn.value)||0)/2); };
          if (s.playerOrder.length < 2) btnC.innerHTML = `<button disabled class="bg-gray-500 text-gray-300 font-black text-2xl py-4 px-12 rounded-full shadow-none border-b-4 border-gray-700 cursor-not-allowed opacity-50">${t("waitPlayerBtn")} (${s.playerOrder.length}/10)</button>`;
          else btnC.innerHTML = `<button onclick="network.startGame()" class="bg-red-600 hover:bg-red-500 text-white font-black text-2xl py-4 px-12 rounded-full shadow-xl border-b-4 border-red-800 active:border-b-0 active:translate-y-1 transition-all">${t("startGameBtn")} (${s.playerOrder.length}/10)</button>`;
        } else { hostC.classList.add("hidden"); document.getElementById("wait-message").classList.remove("hidden"); document.getElementById("wait-message").innerText = `${t("waitForHost")} (${s.players[s.hostId]?.name || "Host"})`; }
      }
      async signIn() { try { if (initialAuthToken) await signInWithCustomToken(this.auth, initialAuthToken); else await signInAnonymously(this.auth); } catch (e) {} }
      getRoomRef(id) { return doc(this.db, "artifacts", this.appId, "public/data/poker-rooms", id); }
      validateInputs() { const n = document.getElementById("player-name-input").value.trim(), r = document.getElementById("room-id-input").value.trim(); if (n.length < 2 || n.length > 10) { document.getElementById("room-error").innerText = t("error_nickname"); return null; } if (r.length < 1) { document.getElementById("room-error").innerText = t("error_room_id"); return null; } localPlayerName = n; return r; }
      async createRoom() {
        const rId = this.validateInputs(); if (!rId) return; this.disableRoomButtons(true); const ref = this.getRoomRef(rId);
        try { const s = await getDoc(ref); if (s.exists() && s.data().lastActive && Date.now() - s.data().lastActive < 30000) { document.getElementById("room-error").innerText = t("error_game_started"); this.disableRoomButtons(false); return; } else if(s.exists()) await deleteDoc(ref);
          const p = { uid: this.localUserId, id: 0, name: localPlayerName, chips: 2000, holeCards: [], folded: false, currentBet: 0, accumulatedBet: 0, status: "waiting" };
          await setDoc(ref, { status: "waiting", hostId: this.localUserId, lastActive: Date.now(), config: { initialChips: 2000, smallBlind: 10, bigBlind: 20 }, players: { [this.localUserId]: p }, playerOrder: [this.localUserId], communityCards: [], pot: 0, dealerIndex: 0, currentPlayerIndex: -1, currentMaxBet: 0, phase: "waiting", lastRaiseAmount: 20, deck: [], logs: [createLog("log_create", { name: localPlayerName })], highlightWinner: null, highlightCards: [], nextRoundTimer: 0, nextPhaseTimer: 0 });
          this.subscribeToRoom(rId);
        } catch (e) { this.disableRoomButtons(false); }
      }
      async joinRoom() {
        const rId = this.validateInputs(); if (!rId) return; this.disableRoomButtons(true); const ref = this.getRoomRef(rId);
        try { await runTransaction(this.db, async (t) => {
          const d = await t.get(ref); if (!d.exists()) throw "Room not found"; const s = d.data();
          if (s.lastActive && Date.now() - s.lastActive > 30000) throw "ROOM_IS_DEAD";
          if (s.players[this.localUserId]) { if (s.status === "waiting") { s.players[this.localUserId].chips = 2000; s.players[this.localUserId].status = "waiting"; } t.set(ref, s); return; }
          if (s.status !== "waiting") throw t("error_game_started"); if (Object.keys(s.players).length >= 10) throw t("error_room_full");
          s.players[this.localUserId] = { uid: this.localUserId, id: Object.keys(s.players).length, name: localPlayerName, chips: 2000, holeCards: [], folded: false, currentBet: 0, accumulatedBet: 0, status: "waiting" };
          s.playerOrder.push(this.localUserId); s.logs.push(createLog("log_join", { name: localPlayerName })); t.set(ref, s);
        }); this.subscribeToRoom(rId); } catch (e) { if(e==="ROOM_IS_DEAD") await deleteDoc(ref); document.getElementById("room-error").innerText = e.message || e; this.disableRoomButtons(false); }
      }
      async leaveRoom() {
        this.stopHeartbeat(); if (this.unsubscribeRoom) { this.unsubscribeRoom(); this.unsubscribeRoom = null; }
        const rId = this.currentRoomId, uId = this.localUserId;
        if (rId && uId) { const ref = this.getRoomRef(rId); try { await runTransaction(this.db, async (t) => {
          const d = await t.get(ref); if (!d.exists()) return; const s = d.data();
          if (s.players[uId]) { delete s.players[uId]; s.playerOrder = s.playerOrder.filter(id => id !== uId); s.logs.push(createLog("log_leave", { name: localPlayerName })); }
          if (s.playerOrder.length === 0) { t.delete(ref); return; }
          if (s.status === 'playing' && s.playerOrder.length < 2) {
             s.status = 'waiting'; s.phase = 'waiting'; s.pot = 0; s.communityCards = []; s.currentMaxBet = 0; s.currentPlayerIndex = -1;
             s.logs.push(createLog("log_round_end_no_winner")); s.playerOrder.forEach(id => { s.players[id].chips = 2000; s.players[id].holeCards = []; s.players[id].folded = false; s.players[id].currentBet = 0; s.players[id].accumulatedBet = 0; s.players[id].status = "waiting"; });
          }
          if (s.hostId === uId) { s.hostId = s.playerOrder[0]; s.logs.push(createLog("log_host_change", { name: s.players[s.hostId].name })); }
          t.set(ref, s);
        }); } catch (e) {} }
        this.currentRoomId = null; clearTimeout(this.nextRoundTimeout); clearTimeout(this.nextPhaseTimeout);
        document.getElementById("game-area").classList.add("hidden"); document.getElementById("room-screen").classList.remove("hidden"); this.disableRoomButtons(false);
      }
      startHeartbeat(rId) { this.stopHeartbeat(); this.heartbeatInterval = setInterval(async () => { if (this.currentRoomId && this.localUserId && this.gameUI.lastState?.hostId === this.localUserId) try { await window.firestoreUpdateDoc(this.getRoomRef(rId), { lastActive: Date.now() }); } catch(e){} }, 5000); }
      stopHeartbeat() { clearInterval(this.heartbeatInterval); }
      subscribeToRoom(rId) {
        this.currentRoomId = rId; document.getElementById("display-room-id").innerText = rId; document.getElementById("room-screen").classList.add("hidden"); document.getElementById("game-area").classList.remove("hidden");
        this.gameUI.initSound(); this.gameUI.occlusionManager.start(); this.startHeartbeat(rId);
        this.unsubscribeRoom = onSnapshot(this.getRoomRef(rId), (d) => { if (!d.exists()) { this.gameUI.showMessage("Room closed"); setTimeout(() => this.leaveRoom(), 2000); return; } this.gameUI.renderGameState(d.data(), this.localUserId); this.runHostTimerController(d.data()); }, () => this.leaveRoom());
      }
      runHostTimerController(s) {
        if (s.hostId !== this.localUserId) return;
        if (s.nextPhaseTimer > 0 && !this.nextPhaseTimeout) this.nextPhaseTimeout = setTimeout(async () => { this.nextPhaseTimeout = null; const ref = this.getRoomRef(this.currentRoomId); try { const cur = (await getDoc(ref)).data(); if (cur.nextPhaseTimer > 0) { cur.nextPhaseTimer = 0; await setDoc(ref, runAutoShowdown(cur)); } } catch (e) {} }, s.nextPhaseTimer);
        else if (s.nextPhaseTimer === 0) { clearTimeout(this.nextPhaseTimeout); this.nextPhaseTimeout = null; }
        if (s.phase === "showdown" && s.nextRoundTimer > 0 && !this.nextRoundTimeout) this.nextRoundTimeout = setTimeout(async () => { this.nextRoundTimeout = null; const ref = this.getRoomRef(this.currentRoomId); try { const cur = (await getDoc(ref)).data(); if (cur.phase === "showdown") await setDoc(ref, startNewRound(cur)); } catch (e) {} }, s.nextRoundTimer);
      }
      async startGame() {
        if (!this.currentRoomId || !this.gameUI.lastState || this.localUserId !== this.gameUI.lastState.hostId) return;
        const ic = parseInt(document.getElementById("setting-initial-chips").value), bb = parseInt(document.getElementById("setting-big-blind").value);
        if (bb < 2 || bb % 2 !== 0 || ic <= bb) return;
        document.getElementById("btn-start-game").disabled = true;
        try { const s = this.gameUI.lastState; s.config = { initialChips: ic, bigBlind: bb, smallBlind: bb/2 }; Object.keys(s.players).forEach(id => { s.players[id].chips = ic; s.players[id].currentBet = 0; }); s.status = "playing"; await setDoc(this.getRoomRef(this.currentRoomId), startNewRound(s)); } catch (e) { document.getElementById("btn-start-game").disabled = false; }
      }
      async handleHumanAction(act) {
        const s = this.gameUI.lastState; if (!s || s.playerOrder[s.currentPlayerIndex] !== this.localUserId) return;
        this.gameUI.updateControls({ ...s, currentPlayerIndex: -1 });
        let amt = 0; if (act === "raise") amt = parseInt(document.getElementById("raise-slider").value);
        try { await runTransaction(this.db, async (t) => { const ref = this.getRoomRef(this.currentRoomId); const cur = (await t.get(ref)).data(); const p = cur.players[this.localUserId]; t.set(ref, processAction(cur, this.localUserId, act, act === "raise" ? p.currentBet + amt : 0)); }); } catch (e) { this.gameUI.updateControls(this.gameUI.lastState); }
      }
      disableRoomButtons(d) { const b1 = document.getElementById("btn-join-room"), b2 = document.getElementById("btn-create-room"); b1.disabled = d; b2.disabled = d; if(d) { b1.classList.add("btn-disabled"); b2.classList.add("btn-disabled"); } else { b1.classList.remove("btn-disabled"); b2.classList.remove("btn-disabled"); } }
    }

    class SoundManager {
      constructor() { this.ctx = null; this.enabled = false; }
      init() { if (!this.ctx) { this.ctx = new (window.AudioContext||window.webkitAudioContext)(); this.enabled = true; const r = () => { if (this.ctx.state === "suspended") this.ctx.resume(); }; document.addEventListener("click", r); document.addEventListener("touchstart", r); } if(this.ctx.state === "suspended") this.ctx.resume(); }
      playTone(f, t, d, v=0.1, w=0) { if(!this.enabled) return; const o = this.ctx.createOscillator(), g = this.ctx.createGain(); o.type = t; o.frequency.setValueAtTime(f, this.ctx.currentTime + w); g.gain.setValueAtTime(v, this.ctx.currentTime + w); g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + w + d); o.connect(g); g.connect(this.ctx.destination); o.start(this.ctx.currentTime + w); o.stop(this.ctx.currentTime + w + d); }
      playChip() { this.playTone(2000, "square", 0.05, 0.03); }
      playCard() { this.playTone(800, "sine", 0.1, 0.02); }
      playCheck() { this.playTone(300, "sine", 0.05, 0.1); this.playTone(300, "sine", 0.05, 0.1, 0.1); }
      playFold() { this.playTone(150, "triangle", 0.3, 0.1); }
      playAllIn() { if(!this.enabled) return; const t = this.ctx.currentTime; this.playTone(100, "sawtooth", 0.4, 0.4, 0); this.playTone(50, "square", 1.0, 0.5, 0.1); const o = this.ctx.createOscillator(), g = this.ctx.createGain(); o.type = "triangle"; o.frequency.setValueAtTime(800, t); o.frequency.exponentialRampToValueAtTime(100, t+0.3); g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+0.3); o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(t+0.3); }
      playRaise() { this.playTone(1500, "square", 0.08, 0.04); this.playTone(1000, "square", 0.08, 0.04, 0.05); }
      playHandEnd() { this.playTone(440, "sine", 0.2, 0.1); }
      playWin() { [523, 659, 784, 1046].forEach((f, i) => this.playTone(f, "triangle", 0.4, 0.15, i * 0.15)); }
      playLose() { this.playTone(100, "sawtooth", 1.0, 0.2); this.playTone(80, "sawtooth", 1.0, 0.2, 0.3); }
    }

    class OcclusionManager {
      constructor() { this.ca = document.getElementById("community-area"); this.gm = document.getElementById("game-message"); this.r = false; this.l = null; }
      start() { if (this.r) return; this.r = true; this.l = setInterval(() => this.check(), 100); }
      stop() { this.r = false; clearInterval(this.l); }
      getOverlap(r1, r2) { if (!r1 || !r2 || Math.max(r1.left, r2.left) >= Math.min(r1.right, r2.right) || Math.max(r1.top, r2.top) >= Math.min(r1.bottom, r2.bottom)) return 0; return ((Math.min(r1.right, r2.right)-Math.max(r1.left, r2.left))*(Math.min(r1.bottom, r2.bottom)-Math.max(r1.top, r2.top))) / Math.min(r1.width*r1.height, r2.width*r2.height); }
      check() {
        const seats = document.querySelectorAll(".player-seat"), targets = [];
        seats.forEach(s => { const c = s.querySelector('div[id^="cards-"]'); if (c && c.children.length) targets.push(c.getBoundingClientRect()); });
        const cr = this.ca.getBoundingClientRect(); let co = false;
        for (const t of targets) if (this.getOverlap(t, cr) > 0.2) { co = true; break; }
        if (!co) seats.forEach(s => { const i = s.querySelector(".player-info-box"); if (i && this.getOverlap(i.getBoundingClientRect(), cr) > 0.2) co = true; });
        this.apply(this.ca, co);
        if (this.gm && this.gm.style.opacity !== "0") { let mo = false; const mr = this.gm.getBoundingClientRect(); if (this.getOverlap(mr, cr) > 0.2) mo = true; if (!mo) for (const t of targets) if (this.getOverlap(mr, t) > 0.2) { mo = true; break; } this.apply(this.gm, mo); }
      }
      apply(e, t) { if(t) { if(!e.classList.contains("smart-transparent")) e.classList.add("smart-transparent"); } else { if(e.classList.contains("smart-transparent")) e.classList.remove("smart-transparent"); } }
    }

    class TableDragSystem {
      constructor() { this.c = document.getElementById("table-area"); this.t = document.getElementById("table"); this.d = false; this.sy = 0; this.cy = 30; this.iy = 0; this.init(); }
      init() { this.c.addEventListener("mousedown", this.s.bind(this)); window.addEventListener("mousemove", this.m.bind(this)); window.addEventListener("mouseup", this.e.bind(this)); this.c.addEventListener("touchstart", this.s.bind(this), {passive:false}); window.addEventListener("touchmove", this.m.bind(this), {passive:false}); window.addEventListener("touchend", this.e.bind(this)); this.u(); }
      s(e) { if(e.target.closest("button")||e.target.closest("input"))return; this.d=true; this.sy=this.gy(e); this.iy=this.cy; this.t.classList.remove("duration-500"); this.t.classList.add("duration-0"); this.c.classList.add("cursor-grabbing"); this.c.classList.remove("cursor-grab"); }
      m(e) { if(!this.d)return; e.preventDefault(); const y=this.gy(e), diff=y-this.sy; this.cy=this.iy+diff; if(this.cy>180)this.cy=180; if(this.cy<-120)this.cy=-120; this.u(); if(window.gameUI)window.gameUI.occlusionManager.check(); }
      e() { if(!this.d)return; this.d=false; this.t.classList.remove("duration-0"); this.t.classList.add("duration-500"); this.c.classList.remove("cursor-grabbing"); this.c.classList.add("cursor-grab"); }
      gy(e) { return e.touches?e.touches[0].clientY:e.clientY; }
      u() { this.t.style.transform=`translateY(${this.cy}px)`; }
    }

    class HandEvaluator {
      static evaluate(hc, cc) {
        if (!hc || !hc.length) return { score: 0, name: "hand_high_card", bestCards: [] };
        const all = [...hc.map(c=>({...c, isHole:true})), ...cc.map(c=>({...c, isHole:false}))].sort((a,b) => (b.value!==a.value ? b.value-a.value : b.isHole-a.isHole));
        const getK = (exc, n) => { const k=[]; const exIds=new Set(exc.map(c=>c.id)); for(const c of all) { if(!exIds.has(c.id)) { k.push(c); if(k.length===n) break; } } return k; };
        const cScore = (r, m, k) => { let s = r * Math.pow(100, 5); m.forEach((c, i) => s += c.value * Math.pow(100, 4-i)); k.forEach((c, i) => s += c.value * Math.pow(100, 4-m.length-i)); return s; };
        const suits = {}; all.forEach(c => { if(!suits[c.suit]) suits[c.suit]=[]; suits[c.suit].push(c); });
        let flush = null; for(let s in suits) if(suits[s].length>=5) { flush=suits[s].slice(0,5); break; }
        const getStr = (cards) => {
          const vals = [...new Set(cards.map(c=>c.value))].sort((a,b)=>b-a);
          if(vals.includes(14)&&vals.includes(5)&&vals.includes(4)&&vals.includes(3)&&vals.includes(2)) {
            const req=[5,4,3,2,14], best=[], uIds=new Set(); req.forEach(v=>{ const c=cards.find(x=>x.value===v && !uIds.has(x.id)); if(c){ best.push(c); uIds.add(c.id); } }); if(best.length===5) return {cards:best, high:5};
          }
          for(let i=0; i<=vals.length-5; i++) {
            if(vals[i]-vals[i+4]===4) {
              const req=vals.slice(i, i+5), best=[], uIds=new Set(); req.forEach(v=>{ const c=cards.find(x=>x.value===v && !uIds.has(x.id)); if(c){ best.push(c); uIds.add(c.id); } }); if(best.length===5) return {cards:best, high:vals[i]};
            }
          } return null;
        };
        if(flush) { const sf = getStr(flush); if(sf) return { score: cScore(9, [sf.cards[0]], []), name: "hand_straight_flush", bestCards: sf.cards }; }
        const counts={}; all.forEach(c => counts[c.value]=(counts[c.value]||0)+1);
        const f=Object.keys(counts).filter(v=>counts[v]===4).map(Number).sort((a,b)=>b-a), t=Object.keys(counts).filter(v=>counts[v]===3).map(Number).sort((a,b)=>b-a), p=Object.keys(counts).filter(v=>counts[v]===2).map(Number).sort((a,b)=>b-a);
        if(f.length) { const q=all.filter(c=>c.value===f[0]), k=getK(q,1); return { score: cScore(8, [q[0]], k), name: "hand_four_of_a_kind", bestCards: [...q, ...k] }; }
        if(t.length && (t.length>1||p.length)) { const tc=all.filter(c=>c.value===t[0]).slice(0,3), pc=all.filter(c=>c.value===(t.length>1?t[1]:p[0])).slice(0,2); return { score: cScore(7, [tc[0], pc[0]], []), name: "hand_full_house", bestCards: [...tc, ...pc] }; }
        if(flush) return { score: cScore(6, flush, []), name: "hand_flush", bestCards: flush };
        const str = getStr(all); if(str) return { score: cScore(5, [str.cards[0]], []), name: "hand_straight", bestCards: str.cards };
        if(t.length) { const tc=all.filter(c=>c.value===t[0]).slice(0,3), k=getK(tc,2); return { score: cScore(4, [tc[0]], k), name: "hand_three_of_a_kind", bestCards: [...tc, ...k] }; }
        if(p.length>=2) { const p1=all.filter(c=>c.value===p[0]).slice(0,2), p2=all.filter(c=>c.value===p[1]).slice(0,2), k=getK([...p1, ...p2], 1); return { score: cScore(3, [p1[0], p2[0]], k), name: "hand_two_pairs", bestCards: [...p1, ...p2, ...k] }; }
        if(p.length) { const pc=all.filter(c=>c.value===p[0]).slice(0,2), k=getK(pc,3); return { score: cScore(2, [pc[0]], k), name: "hand_pair", bestCards: [...pc, ...k] }; }
        const h=all.slice(0,5); return { score: cScore(1, h, []), name: "hand_high_card", bestCards: h };
      }
    }

    const gameUI = new GameUIManager(); const network = new NetworkManager(gameUI);
    window.network = network; window.gameUI = gameUI; network.init();
  </script>
</body>
</html>
