<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <!-- *** 修正: 改为 UTF-8 *** -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>德州扑克 (联机版)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♠️</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* ... existing styles ... */
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Black+Ops+One&family=Noto+Sans+JP:wght@500;700&display=swap");

      body {
        font-family: "Inter", "Noto Sans JP", "Microsoft YaHei", sans-serif;
        background-color: #111827;
        color: white;
        overflow: hidden;
        touch-action: none;
        user-select: none;
      }

      /* --- 卡牌样式 --- */
      .card {
        width: 42px;
        height: 60px;
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        position: relative;
        transition: transform 0.3s, box-shadow 0.3s;
        z-index: 10;
        border: 1px solid #e5e7eb;
      }
      @media (min-width: 768px) {
        .card {
          width: 56px;
          height: 78px;
          font-size: 20px;
          border-radius: 6px;
        }
      }
      .card.red {
        color: #dc2626;
      }
      .card.black {
        color: #1f2937;
      }
      .card-back {
        background: repeating-linear-gradient(
          45deg,
          #1e3a8a,
          #1e3a8a 10px,
          #172554 10px,
          #172554 20px
        );
        border: 2px solid #e2e8f0;
      }
      .card-back span {
        display: none;
      }

      /* --- 获胜牌高亮特效 --- */
      .card.winning-card {
        box-shadow: 0 0 15px 5px rgba(251, 191, 36, 0.9);
        border: 3px solid #fbbf24;
        z-index: 100;
      }

      /* --- 牌桌 --- */
      .poker-table {
        background: radial-gradient(
          circle,
          #15803d 0%,
          #064e3b 90%,
          #022c22 100%
        );
        box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.9), 0 0 0 12px #374151,
          0 0 0 16px #1f2937;
        position: relative;
        border-radius: 180px;
        transform: translateY(30px);
        will-change: transform;
      }

      .cursor-grab {
        cursor: grab;
      }
      .cursor-grabbing {
        cursor: grabbing;
      }

      .player-seat {
        position: absolute;
        transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.6s,
          top 0.6s;
        width: 120px;
        height: 110px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transform-origin: center center;
        pointer-events: none;
      }
      .player-seat > * {
        pointer-events: auto;
      }

      .player-info-box {
        background: linear-gradient(
          180deg,
          rgba(31, 41, 55, 0.95) 0%,
          rgba(17, 24, 39, 0.98) 100%
        );
        border: 1px solid #4b5563;
        border-radius: 6px;
        padding: 4px 2px;
        width: 100%;
        text-align: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
        position: relative;
      }

      .dealer-btn {
        width: 20px;
        height: 20px;
        background: radial-gradient(circle at 30% 30%, #fff, #cbd5e0);
        color: #1a202c;
        border-radius: 50%;
        font-size: 12px;
        font-weight: 900;
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: -8px;
        right: -6px;
        border: 1px solid #9ca3af;
        z-index: 30;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
      }

      .active-player .player-info-box {
        box-shadow: 0 0 0 2px #fbbf24, 0 0 20px rgba(251, 191, 36, 0.4);
        border-color: #f59e0b;
        background: linear-gradient(180deg, #374151 0%, #1f2937 100%);
        transform: translateY(-2px);
        z-index: 40;
      }

      .winner-highlight .player-info-box {
        box-shadow: 0 0 0 3px #22c55e, 0 0 30px rgba(34, 197, 94, 0.6);
        border-color: #22c55e;
        background: linear-gradient(180deg, #064e3b 0%, #065f46 100%);
        z-index: 50;
      }

      /* --- 聊天气泡样式 (移除) --- */

      /* --- All-in 特效 --- */
      .all-in-fullscreen-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.3);
        animation: fadeIn 0.2s ease-out;
      }
      .all-in-bar {
        position: absolute;
        top: 50%;
        left: 0;
        width: 100%;
        height: 140px;
        background: rgba(0, 0, 0, 0.95);
        transform: translateY(-50%) translateX(-100%);
        animation: barSlideIn 0.4s cubic-bezier(0.05, 0.7, 0.1, 1) forwards;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        border-top: 2px solid rgba(234, 179, 8, 0.6);
        border-bottom: 2px solid rgba(234, 179, 8, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      @keyframes barSlideIn {
        from {
          transform: translateY(-50%) translateX(-100%);
        }
        to {
          transform: translateY(-50%) translateX(0%);
        }
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .all-in-text {
        position: relative;
        font-family: "Black Ops One", system-ui, sans-serif;
        font-size: 90px;
        white-space: nowrap;
        text-transform: uppercase;
        letter-spacing: 4px;
        background: linear-gradient(
          to bottom,
          #fef08a 0%,
          #eab308 45%,
          #a16207 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        filter: drop-shadow(0 5px 3px rgba(0, 0, 0, 0.5));
        text-shadow: 0 0 30px rgba(234, 179, 8, 0.6);
        opacity: 0;
        transform: scale(2);
        animation: textImpact 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
          forwards 0.2s;
      }
      @keyframes textImpact {
        0% {
          opacity: 0;
          transform: scale(2);
          filter: blur(10px);
        }
        100% {
          opacity: 1;
          transform: scale(1);
          filter: blur(0px);
        }
      }
      .all-in-bar::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 30%;
        height: 100%;
        background: linear-gradient(
          to right,
          transparent,
          rgba(255, 255, 255, 0.4),
          transparent
        );
        transform: skewX(-25deg);
        animation: shine 1s infinite 0.5s;
      }
      @keyframes shine {
        0% {
          left: -50%;
        }
        100% {
          left: 150%;
        }
      }

      input[type="range"]::-webkit-slider-thumb {
        background: #fbbf24;
      }
      .adjust-btn:active {
        transform: scale(0.95);
        background-color: #4b5563;
      }

      /* 智能透明类 */
      .smart-transparent {
        opacity: 0.15 !important;
        transition: opacity 0.2s ease-out;
        pointer-events: none;
      }

      /* --- 新增: Firebase 加载和房间选择界面 --- */
      .firebase-loader {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #111827;
        z-index: 10000;
      }
      .spinner {
        width: 48px;
        height: 48px;
        border: 4px solid #4b5563;
        border-top-color: #f59e0b;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #room-screen {
        z-index: 50;
        background: rgba(17, 24, 39, 0.95);
        backdrop-filter: blur(10px);
      }

      /* 按钮禁用样式 */
      .btn-disabled {
        background-color: #4b5563 !important;
        border-color: #374151 !important;
        color: #9ca3af !important;
        cursor: not-allowed !important;
        transform: none !important;
      }
    </style>
  </head>
  <body
    class="h-screen w-screen flex flex-col items-center justify-center bg-gray-950"
  >
    <!-- *** 新增: Firebase 加载动画 *** -->
    <div id="firebase-loader" class="firebase-loader">
      <div class="spinner"></div>
      <p class="text-gray-400 mt-4 text-sm font-medium">连接到游戏服务器...</p>
    </div>

    <!-- *** 修改: 启动页改为房间选择页 *** -->
    <div
      id="room-screen"
      class="hidden absolute z-50 bg-gray-900 p-8 rounded-xl shadow-2xl border border-gray-700 w-11/12 max-w-md"
    >
      <h1 class="text-3xl font-bold text-yellow-500 mb-6 tracking-tight text-center">
        德州扑克
      </h1>

      <!-- *** 修复: 移除了 AI 玩家列表 (它们现在在等待室) *** -->

      <div class="mb-4">
        <label
          class="block text-gray-400 mb-2 text-sm font-bold"
          for="player-name-input"
          >你的昵称</label
        >
        <input
          type="text"
          id="player-name-input"
          class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
          placeholder="例如: 赌神"
        />
      </div>
      <div class="mb-6">
        <label
          class="block text-gray-400 mb-2 text-sm font-bold"
          for="room-id-input"
          >房间 ID</label
        >
        <input
          type="text"
          id="room-id-input"
          class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
          placeholder="输入房间ID (例如: 888)"
        />
      </div>
      <div class="flex space-x-4 mb-4">
        <button
          onclick="network.joinRoom()"
          id="btn-join-room"
          class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1"
        >
          加入房间
        </button>
        <button
          onclick="network.createRoom()"
          id="btn-create-room"
          class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1"
        >
          创建房间
        </button>
      </div>
      <p id="room-error" class="text-red-400 text-sm h-5"></p>
      <p class="text-gray-500 text-xs mt-4">
        你的 User ID: <span id="user-id-display">...</span>
      </p>
    </div>

    <!-- 结束页 -->
    <div
      id="game-over-screen"
      class="hidden absolute z-[60] bg-black bg-opacity-95 w-full h-full flex flex-col items-center justify-center text-center"
    >
      <h2 id="game-over-title" class="text-6xl font-black mb-4 text-white">
        游戏结束
      </h2>
      <p id="game-over-msg" class="text-xl text-gray-400 mb-8">...</p>
      <!-- *** 修改: 按钮改为 "返回大厅" *** -->
      <!-- *** 再次修改: 变为按钮容器 (请求 #3) *** -->
      <div id="game-over-buttons" class="flex space-x-4">
        <button
          onclick="network.leaveRoom()"
          class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg"
        >
          返回大厅
        </button>
        <!-- 观战按钮将由JS动态添加 -->
      </div>
    </div>

    <!-- 游戏主界面 -->
    <div id="game-area" class="hidden w-full h-full relative flex flex-col">
      <!-- *** 修改: 恢复了盲注和玩家计数UI *** -->
      <div
        id="top-bar"
        class="h-16 bg-gray-900 w-full flex items-center justify-between px-6 shadow-lg z-10 border-b border-gray-800 relative z-50"
      >
        <div class="flex items-center space-x-2">
          <div class="text-yellow-500 font-black text-2xl tracking-tight">
            底池: $<span id="pot-display">0</span>
          </div>
        </div>

        <div class="flex items-center space-x-4">
          
          <div class="flex flex-col items-center mr-1 bg-gray-800 px-2 py-1 rounded border border-gray-700">
            <span class="text-gray-500 text-[10px] font-bold leading-none mb-1">房间号</span>
            <span id="display-room-id" class="text-yellow-500 font-mono font-bold text-sm leading-none">---</span>
          </div>
          <div class="text-right hidden sm:block">
            <div id="blinds-display" class="text-gray-400 text-xs font-bold tracking-wider">
              盲注 $10/$20
            </div>
            <div class="text-gray-600 text-[10px]">
              在线玩家: <span id="active-players-count">0</span>
            </div>
          </div>
          
          <button
            id="btn-leave-room"
            onclick="network.leaveRoom()"
            class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-2 px-4 rounded-lg text-xs shadow-md"
          >
            退出房间
          </button>
        </div>
      </div>
      <!-- *** 结束修改 *** -->

      <div
        id="table-area"
        class="flex-grow relative overflow-hidden flex items-center justify-center bg-gray-950 cursor-grab active:cursor-grabbing"
      >
        <div
          id="table"
          class="poker-table w-[95vw] h-[55vh] md:w-[800px] md:h-[450px] max-w-full relative transition-all duration-500"
        >
          <div
            id="community-area"
            class="absolute top-[42%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 flex flex-col items-center space-y-2 z-20 transition-opacity duration-200"
          >
            <div
              id="community-cards"
              class="flex flex-col items-center space-y-2"
            ></div>
          </div>
          <div
            id="game-message"
            class="absolute top-[23%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-yellow-100 font-bold text-xl text-center z-30 pointer-events-none drop-shadow-lg px-4 py-2 rounded whitespace-nowrap transition-opacity duration-300 opacity-0"
          ></div>
          <div id="seats-container" class="w-full h-full relative"></div>
        </div>
      </div>

      <div
        id="bottom-bar"
        class="bg-gray-900 p-4 shadow-[0_-5px_15px_rgba(0,0,0,0.5)] z-20 border-t border-gray-800 relative z-50"
      >
        <div
          id="game-log"
          class="h-16 overflow-y-auto text-xs text-gray-500 mb-3 font-mono bg-gray-950 p-2 rounded border border-gray-800 scroll-smooth leading-5"
        >
          <div class="text-green-600">系统: 欢迎游玩德州扑克。</div>
        </div>
        <div
          id="player-controls"
          class="flex flex-col items-center opacity-50 pointer-events-none transition-all duration-300 transform translate-y-2"
        >
          <div
            id="raise-slider-container"
            class="w-full max-w-md mb-4 flex items-center space-x-2 px-2"
          >
            <span
              class="text-xs text-gray-500 font-bold tracking-wider w-8 text-center"
              >加注</span
            >
            <button
              onclick="gameUI.adjustRaise(-1)"
              class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700"
            >
              -
            </button>
            <input
              type="range"
              id="raise-slider"
              step="1"
              class="flex-grow h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mx-2"
            />
            <button
              onclick="gameUI.adjustRaise(1)"
              class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700"
            >
              +
            </button>
            <span
              id="raise-val-display"
              class="text-sm text-yellow-400 w-14 text-right font-mono font-bold"
              >$0</span
            >
          </div>
          <div class="flex justify-center space-x-3 w-full max-w-lg">
            <!-- *** 修改: onclick 事件 *** -->
            <button
              onclick="network.handleHumanAction('fold')"
              class="flex-1 bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-gray-900 active:border-b-0 active:translate-y-1"
            >
              弃牌
            </button>
            <button
              onclick="network.handleHumanAction('check')"
              id="btn-check"
              class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1"
            >
              过牌
            </button>
            <button
              onclick="network.handleHumanAction('call')"
              id="btn-call"
              class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1 hidden"
            >
              跟注
            </button>
            <button
              onclick="network.handleHumanAction('raise')"
              id="btn-raise"
              class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1"
            >
              加注
            </button>
          </div>
        </div>
        <div
          class="text-center mt-2 text-gray-700 text-[10px] font-mono tracking-wider"
        >
          阶段: <span id="phase-display" class="text-gray-500">等待中</span>
        </div>
      </div>

      <div
        id="waiting-room-overlay"
        class="hidden absolute top-0 left-0 w-full h-full z-40 flex flex-col items-center justify-center pointer-events-none"
      >
      <div id="wait-host-controls" class="hidden pointer-events-auto flex flex-col items-center gap-4 transition-transform duration-300 mb-28">
          
            <div id="host-settings-panel" class="bg-gray-800/80 p-4 rounded-lg border border-gray-600 w-72 backdrop-blur-sm shadow-lg">
              
              <div class="mb-3">
                <div class="flex justify-between items-center mb-1">
                    <label class="block text-yellow-500 text-xs font-bold">初始筹码</label>
                    <span id="error-chips-inline" class="text-red-500 text-[10px] font-bold animate-pulse"></span>
                </div>
                <input 
                    type="number" 
                    id="setting-initial-chips" 
                    value="2000" 
                    step="100" 
                    onkeydown="if(['.','e','E','+','-'].includes(event.key)) event.preventDefault()"
                    class="w-full bg-gray-900 text-white border border-gray-600 rounded px-2 py-1 text-sm focus:border-yellow-500 outline-none font-mono"
                >
              </div>

              <div>
                <div class="flex justify-between items-center mb-1">
                    <label class="block text-yellow-500 text-xs font-bold">大盲注</label>
                    <span id="error-blind-inline" class="text-red-500 text-[10px] font-bold animate-pulse"></span>
                </div>
                <input 
                    type="number" 
                    id="setting-big-blind" 
                    value="20" 
                    step="2" 
                    min="2" 
                    onkeydown="if(['.','e','E','+','-'].includes(event.key)) event.preventDefault()"
                    class="w-full bg-gray-900 text-white border border-gray-600 rounded px-2 py-1 text-sm focus:border-yellow-500 outline-none font-mono"
                >
                <p class="text-gray-400 text-[10px] mt-1 text-right">小盲注自动设为: <span id="setting-sb-display" class="text-white font-bold">10</span></p>
              </div>
            </div>
        
            <div id="host-start-btn-container"></div>
        </div>

        <p 
            id="wait-message" 
            class="mt-8 text-yellow-400 font-bold text-xl drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)] pointer-events-auto bg-black/40 px-6 py-2 rounded-lg backdrop-blur-sm border border-white/10"
        >
            等待房主开始...
        </p>

        <div id="wait-player-list" class="hidden"></div>
        <span id="wait-player-count" class="hidden"></span>
      </div>
      <!-- *** 结束新增 *** -->
    </div>

    <!-- *** Firebase 模块导入
        *** -->
    <script type="module">
      // --- 导入 Firebase SDK ---
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
        onAuthStateChanged,
        signInWithCustomToken, // 确保导入
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        onSnapshot,
        runTransaction,
        deleteDoc,
        setLogLevel, // 导入 setLogLevel
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      // --- 游戏常量和工具函数 ---
      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
      const getRandomInt = (min, max) =>
        Math.floor(Math.random() * (max - min + 1)) + min;
      const SUITS = ["♠", "♥", "♣", "♦"];
      const RANKS = [
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "J",
        "Q",
        "K",
        "A",
      ];
      const RANK_VALUES = {
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        10: 10,
        J: 11,
        Q: 12,
        K: 13,
        A: 14,
      };
      const PHASE_NAME_MAP = {
        waiting: "等待中",
        preflop: "翻牌前",
        flop: "翻牌",
        turn: "转牌",
        river: "河牌",
        showdown: "摊牌",
      };

      // --- 移除: AI 姓名库 ---

      // --- 移除: AI 台词库 ---

      // --- Firebase 全局变量 ---
      let db, auth, app;
      let localUserId = null;
      let localPlayerName = "玩家";
      let currentRoomId = null;
      let unsubscribeRoom = null; // 用于取消 Firestore 监听
      let sound; // 音效管理器

      // --- 你的 Firebase 配置 (已修改为使用环境变量) ---
      const firebaseConfig =
        typeof __firebase_config !== "undefined"
          ? JSON.parse(__firebase_config)
          : {
              // 本地测试的回退 (使用你之前提供的配置)
              apiKey: "AIzaSyBX_mHFj3VHsx6U38Ib9pDJWCrnlSlR_g4",
              authDomain: "texas-hold-em-poker-1.firebaseapp.com",
              projectId: "texas-hold-em-poker-1",
              storageBucket: "texas-hold-em-poker-1.firebasestorage.app",
              messagingSenderId: "401916350194",
              appId: "1:401916350194:web:2b38d3da714968c8cd0a6b",
              measurementId: "G-HRQ5N6G7KD",
            };

      // --- Canvas 运行环境特定的全局变量 (用于本地测试的回退) ---
      const appId =
        typeof __app_id !== "undefined" ? __app_id : "poker-game-test";
      const initialAuthToken =
        typeof __initial_auth_token !== "undefined"
          ? __initial_auth_token
          : null;

      // --- 核心：游戏逻辑处理器 (纯函数) ---
      // 这是一个纯函数，接收当前状态和动作，返回新状态
      // 这是联机版的核心，所有客户端都依赖这个函数来同步游戏状态
      function processAction(currentState, actingUserId, action, amount = 0) {
        // 复制一份新状态，避免修改原状态
        let newState = JSON.parse(JSON.stringify(currentState));
        const config = newState.config || { bigBlind: 20 };
        let player = newState.players[actingUserId];

        // 1. 检查是否轮到该玩家
        const currentPlayerId =
          newState.playerOrder[newState.currentPlayerIndex];
        if (currentPlayerId !== actingUserId) {
          console.warn(
            `非法操作: ${actingUserId} 试图在 ${currentPlayerId} 的回合行动`
          );
          return currentState; // 返回原状态
        }

        // 2. 玩家已弃牌或All-in，不能行动
        if (
          player.folded ||
          (player.chips === 0 && newState.phase !== "waiting")
        ) {
          console.warn(`非法操作: ${actingUserId} 已经弃牌或All-in`);
          // 自动跳到下一位
          newState.currentPlayerIndex =
            (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
          return newState; // 返回跳过后的状态
        }

        const diff = newState.currentMaxBet - player.currentBet;
        let triggerAllInEffect = false;
        let logMsg = "";
        let actionContext = action; // 用于AI语音

        // 3. 处理玩家动作
        if (action === "fold") {
          player.folded = true;
          player.status = "弃牌";
          logMsg = `${player.name} 弃牌`;
          // *** 移除: sound.playFold() (请求 #1) ***
        } else if (action === "check") {
          // 只有在 diff 为 0 时才能 check
          if (diff > 0) {
            console.warn(`非法操作: ${player.name} 试图在需要跟注时过牌`);
            return currentState; // 非法操作，返回原状态
          }
          player.status = "过牌";
          logMsg = `${player.name} 过牌`;
          // *** 移除: sound.playCheck() (请求 #1) ***
        } else if (action === "call") {
          let callAmount = Math.min(diff, player.chips);
          let isAllIn = callAmount === player.chips && diff > 0;

          player.chips -= callAmount;
          player.currentBet += callAmount;
          newState.pot += callAmount;

          player.status = isAllIn ? "全押" : "跟注";
          logMsg = `${player.name} ${isAllIn ? "全押" : "跟注"} $${callAmount}`;
          if (isAllIn) {
            triggerAllInEffect = true;
            actionContext = "all_in";
          } else {
            // *** 移除: sound.playChip() (请求 #1) ***
          }
        } else if (action === "raise") {
          // amount 是玩家 *总共* 投入的金额
          let raiseAmount = amount - player.currentBet; // 本次额外投入的
          let actualAmount = amount; // 本次动作的总支付额

          // 验证加注
          // 1. 支付额必须 > 当前最大下注
          if (
            actualAmount <= newState.currentMaxBet &&
            actualAmount < player.chips
          ) {
            console.warn(
              `非法加注: $${actualAmount} 小于等于 $${newState.currentMaxBet}`
            );
            return currentState;
          }
          // 2. 加注额必须 >= 上次加注额 (除非是All-in)
          const extraRaise = actualAmount - newState.currentMaxBet;
          if (
            extraRaise < newState.lastRaiseAmount &&
            actualAmount < player.chips
          ) {
            console.warn(
              `非法加注: 额外加注 $${extraRaise} 小于最小加注 $${newState.lastRaiseAmount}`
            );
            return currentState;
          }

          // *** 错误修复:
          // *** 原始错误逻辑: let isAllIn = (actualAmount >= player.chips);
          // *** (actualAmount 是总下注额, player.chips 是剩余筹码, 导致在筹码和总下注额相等时错误触发All-in)
          // *** 正确逻辑: 检查 "本次支付的金额" 是否大于或等于 "剩余筹码"
          let isAllIn = raiseAmount >= player.chips;
          // *** 错误修复结束 ***

          if (isAllIn) {
            actualAmount = player.chips + player.currentBet; // 总投入等于所有筹码
            raiseAmount = player.chips; // 额外投入等于剩余筹码
            triggerAllInEffect = true;
            actionContext = "all_in";
          }

          // 更新玩家状态
          player.chips -= raiseAmount;
          player.currentBet = actualAmount; // 总投入
          newState.pot += raiseAmount;

          // 更新公共状态
          const newRaiseAmount = actualAmount - newState.currentMaxBet; // 新的 *额外* 加注额
          // 只有当不是 "小于最小加注的all-in" 时，才更新 lastRaiseAmount
          if (!isAllIn || newRaiseAmount >= newState.lastRaiseAmount) {
            newState.lastRaiseAmount = newRaiseAmount;
          }
          newState.currentMaxBet = actualAmount;
          newState.playersActed.length = 0; // 重置已行动玩家

          player.status = isAllIn ? "全押" : "加注";
          logMsg = `${player.name} ${
            isAllIn ? "全押" : "加注"
          } $${raiseAmount}`;

          if (!isAllIn) {
            // *** 移除: sound.playRaise() (请求 #1) ***
            actionContext = `${newState.phase}_raise`;
          }
        }

        // 4. 记录日志和AI语音
        if (logMsg) {
          newState.logs.push(logMsg);
          if (newState.logs.length > 20) newState.logs.shift(); // 保持日志简洁

          // *** 移除: AI 语音触发 ***
        }

        // 5. 标记玩家已行动
        if (!newState.playersActed.includes(actingUserId)) {
          newState.playersActed.push(actingUserId);
        }

        // 6. 检查回合是否结束，或进入下一阶段

        const activePlayers = newState.playerOrder
          .map((uid) => newState.players[uid])
          .filter((p) => !p.folded);

        const playersWithChips = activePlayers.filter((p) => p.chips > 0);

        // --- 修复: 移植 读博.html 的 "isRoundComplete" 逻辑 ---
        // (删除旧的 isBetsMatched, allActed, bigBlindHadOption)
        const isRoundComplete = activePlayers.every(p => {
            const isAllIn = p.chips === 0 && !p.folded; // 必须是 all-in 且未弃牌
            const matchBet = p.currentBet === newState.currentMaxBet; 
            const hasActed = newState.playersActed.includes(p.uid);

            if (isAllIn) return true; // All-in 玩家被视为 "已完成"
            
            // 检查大盲注 'option'
            if (newState.phase === 'preflop' && newState.currentMaxBet === config.bigBlind) {
                const bbIndex = (newState.dealerIndex + 2) % newState.playerOrder.length;
                const bbPlayerId = newState.playerOrder[bbIndex];
                if (p.uid === bbPlayerId && !hasActed) {
                     return false; // 大盲注玩家尚未行动
                }
            }
            return hasActed && matchBet; // 其他玩家必须已行动且匹配
        });
        // --- 修复结束 ---

        // --- 检查1: 是否只剩一个赢家 (其他人全弃牌) ---
        if (activePlayers.length === 1) {
          newState = advanceToShowdown(newState, activePlayers[0]); // 传入唯一赢家
        }
        // --- 检查3: 是否自动摊牌 (多人All-in) ---
        // (playersWithChips <= 1 确保了 all-in)
        else if (
          isRoundComplete && // 使用新逻辑
          playersWithChips.length <= 1 &&
          newState.phase !== "showdown"
        ) {
          // 所有人都跟了, 且只有0或1个玩家还有筹码
          newState = runAutoShowdown(newState);
        }
        // --- 检查2: 是否进入下一阶段 ---
        else if (isRoundComplete) {
          // 回合结束，进入下一阶段 (flop, turn, river, showdown)
          newState = advanceToNextPhase(newState);
        }
        // --- 检查4: 轮到下一个人 ---
        else {
          // 循环找到下一个未弃牌、未All-in的玩家
          // (移植 读博.html 的 nextTurn 查找逻辑)
          let loops = 0;
          do {
            newState.currentPlayerIndex =
              (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
            
            const nextPlayerId =
              newState.playerOrder[newState.currentPlayerIndex];
            const nextPlayer = newState.players[nextPlayerId];
            
            // 不需要检查 hasActed，因为 All-in 玩家在任何情况下都不可能再行动
            const isAllIn = nextPlayer.chips === 0;

            if (nextPlayer.folded || isAllIn) {
                loops++;
                continue; // 跳过这个玩家
            }
            // *** 修复结束 ***

            break; // 找到了
            
          } while (loops <= newState.playerOrder.length * 2); // 增加循环保护
        }

        // 7. 处理 All-in 特效 (注意：这是客户端逻辑，但我们需要一个标记)
        if (triggerAllInEffect) {
          newState.lastAllInPlayer = player.name; // 标记谁触发了All-in
        }

        return newState;
      }

      // --- 游戏逻辑：进入下一阶段 ---
      function advanceToNextPhase(currentState) {
        let newState = JSON.parse(JSON.stringify(currentState));

        const config = newState.config || { bigBlind: 20 };
        // --- 新增: 立即退还多余的下注 ---
        newState = returnExcessBets(newState);
        // --- 结束新增 ---

        // 1. 结算本轮下注 (移入 accumulatedBet)
        let totalPotForThisRound = 0;
        newState.playerOrder.forEach((uid) => {
          const p = newState.players[uid];
          p.accumulatedBet += p.currentBet;
          totalPotForThisRound += p.currentBet;
          p.currentBet = 0; // 清空当前轮下注
          p.status = ""; // 清空状态
        });

        // 2. 重置下注状态
        newState.currentMaxBet = 0;
        newState.lastRaiseAmount = config.bigBlind; // 重置最小加注额
        newState.playersActed = [];

        // 3. 推进阶段
        if (newState.phase === "preflop") {
          newState.phase = "flop";
          newState.communityCards.push(
            newState.deck.pop(),
            newState.deck.pop(),
            newState.deck.pop()
          );
          newState.logs.push("--- 翻牌 ---"); // *** 修复: 移除 "圈" ***
          // *** 移除: sound.playCard() (请求 #1) ***
        } else if (newState.phase === "flop") {
          newState.phase = "turn";
          newState.communityCards.push(newState.deck.pop());
          newState.logs.push("--- 转牌 ---"); // *** 修复: 移除 "圈" ***
          // *** 移除: sound.playCard() (请求 #1) ***
        } else if (newState.phase === "turn") {
          newState.phase = "river";
          newState.communityCards.push(newState.deck.pop());
          newState.logs.push("--- 河牌 ---"); // *** 修复: 移除 "圈" ***
          // *** 移除: sound.playCard() (请求 #1) ***
        } else if (newState.phase === "river") {
          // 进入摊牌
          newState = advanceToShowdown(newState);
          return newState; // 摊牌逻辑会处理后续
        }

        // 4. 找到下一个行动的玩家 (从庄家左侧开始)
        let nextIdx = (newState.dealerIndex + 1) % newState.playerOrder.length;
        let loops = 0;
        while (loops <= newState.playerOrder.length) {
          const pId = newState.playerOrder[nextIdx];
          const p = newState.players[pId];
          if (!p.folded && p.chips > 0) {
            break; // 找到了
          }
          nextIdx = (nextIdx + 1) % newState.playerOrder.length;
          loops++;
        }
        newState.currentPlayerIndex = nextIdx;

        return newState;
      }

      // --- 游戏逻辑：自动发完所有牌 (多人All-in) ---
      function runAutoShowdown(currentState) {
        let newState = JSON.parse(JSON.stringify(currentState));

        // --- 新增: 立即退还多余的下注 (来自 读博.html) ---
        newState = returnExcessBets(newState);
        // --- 结束新增 ---

        // 1. 结算当前轮
        newState.playerOrder.forEach((uid) => {
          const p = newState.players[uid];
          p.accumulatedBet += p.currentBet;
          p.currentBet = 0;
          p.status = p.chips === 0 && !p.folded ? "All-in" : p.status;
        });

        newState.currentPlayerIndex = -1; // 停止所有玩家行动

        // 2. 推进到下一个发牌阶段
        if (newState.phase === "preflop") {
          newState.phase = "flop";
          newState.communityCards.push(
            newState.deck.pop(),
            newState.deck.pop(),
            newState.deck.pop()
          );
          newState.logs.push("--- 翻牌 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
          newState.nextPhaseTimer = 1500; // 设置1.5秒计时器
        } else if (newState.phase === "flop") {
          newState.phase = "turn";
          newState.communityCards.push(newState.deck.pop());
          newState.logs.push("--- 转牌 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
          newState.nextPhaseTimer = 1500; // 设置1.5秒计时器
        } else if (newState.phase === "turn") {
          newState.phase = "river";
          newState.communityCards.push(newState.deck.pop());
          newState.logs.push("--- 河牌 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
          newState.nextPhaseTimer = 1500; // 设置1.5秒计时器
        } else if (newState.phase === "river") {
          // 牌已发完, 立即进入摊牌
          newState.nextPhaseTimer = 0; // 确保清除计时器
          newState = advanceToShowdown(newState);
        }

        return newState;
      }

      // --- 新增: 移植自 读博.html 的退款逻辑 ---
      function returnExcessBets(currentState) {
        let newState = JSON.parse(JSON.stringify(currentState));
        const activePlayers = newState.playerOrder
          .map((uid) => newState.players[uid])
          .filter((p) => !p.folded);

        if (activePlayers.length < 2) return newState;

        // 复制一份用于排序，不修改原始 players 对象
        const sortedPlayers = [...activePlayers].sort(
          (a, b) => b.currentBet - a.currentBet
        );

        const highest = sortedPlayers[0];
        const secondHighest = sortedPlayers[1];

        if (highest.currentBet > secondHighest.currentBet) {
          const refund = highest.currentBet - secondHighest.currentBet;
          const playerToRefund = newState.players[highest.uid]; // 获取原始对象

          playerToRefund.chips += refund;
          playerToRefund.currentBet -= refund;
          newState.pot -= refund;

          newState.logs.push(
            `退还 $${refund} 给 ${playerToRefund.name} (无人跟注)`
          );
        }
        return newState;
      }
      // --- 结束新增 ---

      // --- 游戏逻辑：摊牌或结算 ---
      function advanceToShowdown(currentState, soleWinner = null) {
        let newState = JSON.parse(JSON.stringify(currentState)); // *** 修复: 必须克隆 ***
        newState.phase = "showdown";
        newState.currentPlayerIndex = -1; // 停止行动

        // 1. 结算最后一轮下注 (不再需要, pot 在 processAction 中已更新)
        // let finalPot = 0; ... (旧的错误逻辑已移除)

        // 2. 退还多余的下注 (不再需要, 已在 advanceToNextPhase 中处理)

        // 3. 情况A: 只有一个赢家 (其他人都弃牌了)
        if (soleWinner) {
          const winnerPlayer = newState.players[soleWinner.uid];

          // *** 修复: 不再重新计算底池 ***
          // `newState.pot` 已经是正确的了 (来自 processAction)
          // 我们只需要清空桌上的 'currentBet'
          newState.playerOrder.forEach((uid) => {
            newState.players[uid].currentBet = 0;
          });

          winnerPlayer.chips += newState.pot;
          newState.logs.push(
            `--- ${winnerPlayer.name} 获胜, 赢得 $${newState.pot} ---`
          );
          newState.highlightWinner = winnerPlayer.uid; // 标记赢家高亮
        }
        // 4. 情况B: 多人摊牌 (*** 升级: 完整的边池计算逻辑 ***)
        else {
          // *** 修复: 将 'currentBet' 移入 'accumulatedBet' 的逻辑移到这里 ***
          let finalPot = 0;
          newState.playerOrder.forEach((uid) => {
            const p = newState.players[uid];
            // if (!soleWinner) 总是 true
            p.accumulatedBet += p.currentBet;
            finalPot += p.accumulatedBet; // 累加总底池
            p.currentBet = 0;
          });
          newState.pot = finalPot; // 确保底池金额正确
          // *** 修复结束 ***

          // *** 修复: 必须先获取所有玩家, 再筛选 activePlayers ***
          const allPlayers = newState.playerOrder.map(
            (uid) => newState.players[uid]
          );
          const activePlayers = allPlayers.filter((p) => !p.folded);

          if (activePlayers.length === 0) {
            newState.logs.push("--- 无人获胜？回合结束 ---");
          } else {
            // 4a. 计算每个人的最佳手牌
            activePlayers.forEach((p) => {
              p.bestHand = HandEvaluator.evaluate(
                p.holeCards,
                newState.communityCards
              );
              p.status = p.bestHand.name; // 显示牌型
            });

            // 4b. 找出所有不同的下注额 (边池级别)
            // *** (还原为 读博.html 逻辑) ***
            let distinctBets = [
              ...new Set(activePlayers.map((p) => p.accumulatedBet)), // *** 修复: 必须使用 activePlayers, 而不是 allPlayers ***
            ]
              .filter((bet) => bet > 0) // (保留) 移除 0 赌注
              .sort((a, b) => a - b);

            // (不再需要 0 级别, 读博.html 的逻辑是从 prevBet=0 开始)

            let winnerLogs = [];
            newState.highlightCards = new Set(); // 用于高亮获胜卡牌

            // 4c. 逐级计算边池
            // --- 还原为 读博.html 的边池逻辑 ---
            let prevBet = 0;

            distinctBets.forEach((betLevel, index) => {
              let potAmount = 0;

              // 1. 从 *所有* 玩家那里计算这个池的钱
              allPlayers.forEach((p) => {
                if (p.accumulatedBet >= betLevel) {
                  potAmount += betLevel - prevBet;
                } else if (p.accumulatedBet > prevBet) {
                  potAmount += p.accumulatedBet - prevBet;
                }
              });

              // 2. 找出有资格赢这个池的玩家 (未弃牌 且 赌注足够)
              let contributors = activePlayers.filter(
                (p) => p.accumulatedBet >= betLevel
              );

              if (potAmount > 0 && contributors.length > 0) {
                // 3. 找出赢家
                let bestScore = -1;
                let winners = [];
                let winHandName = "";

                contributors.forEach((p) => {
                  if (p.bestHand.score > bestScore) {
                    bestScore = p.bestHand.score;
                    winners = [p];
                    winHandName = p.bestHand.name;
                  } else if (Math.abs(p.bestHand.score - bestScore) < 0.1) {
                    winners.push(p);
                  }
                });

                // 4. 分钱
                const winPer = Math.floor(potAmount / winners.length);
                let remainder = potAmount % winners.length;

                // 5. 正确命名 "主池" 和 "边池"
                const potName = index === 0 ? "主池" : `边池${index}`;
                let winnerNames = winners.map((w) => w.name).join(", ");
                winnerLogs.push(
                  `${potName}($${potAmount}): ${winnerNames} 获胜 (${winHandName})`
                );

                winners.forEach((w, idx) => {
                  let winnings = winPer;
                  if (remainder > 0) {
                    winnings++;
                    remainder--;
                  }
                  newState.players[w.uid].chips += winnings;
                  newState.highlightWinner = w.uid; // 高亮
                  // 高亮获胜牌
                  if (w.bestHand.bestCards) {
                    w.bestHand.bestCards.forEach((c) =>
                      newState.highlightCards.add(c.id)
                    );
                  }
                });

                // 6. AI 语音 (输家)
                let losers = contributors.filter((p) => !winners.includes(p));
                losers.forEach((l) => {
                  // *** 移除: AI 语音触发 ***
                });
              }
              prevBet = betLevel;
            });
            // --- 边池逻辑结束 ---

            // 将 Set 转换为数组以便
            newState.highlightCards = Array.from(newState.highlightCards);
            newState.logs.push("--- 摊牌结果 ---", ...winnerLogs);
          }
        }
        // (*** 结束修改 ***)

        // 5. 标记回合结束，准备下一轮
        newState.nextRoundTimer = 6000; // 6秒后开始新回合

        // --- 恢复的逻辑: 播放局结束音效 ---
        sound.playHandEnd();
        // --- 结束 ---

        return newState;
      }

// --- 游戏逻辑：房主开始新回合 ---
      function startNewRound(currentState) {
        let newState = JSON.parse(JSON.stringify(currentState));

        // *** 修改 1: 获取配置 (如果有)，否则使用默认值 ***
        const config = newState.config || {
          initialChips: 2000,
          smallBlind: 10,
          bigBlind: 20
        };
        // *** 结束修改 ***

        // 1. 淘汰筹码为 0 的玩家
        let activePlayerIds = [];
        const allPlayerIds = Object.keys(newState.players); // 获取所有玩家ID

        allPlayerIds.forEach((uid) => {
          if (newState.players[uid].chips > 0) {
            activePlayerIds.push(uid);
          } else {
            newState.players[uid].folded = true; // 标记为旁观
            newState.players[uid].status = "淘汰";
          }
        });

        // 2. 检查游戏是否结束 (只剩1人或0人)
        if (activePlayerIds.length < 2) {
          const winnerId = activePlayerIds.length > 0 ? activePlayerIds[0] : null;
          const winnerName = winnerId ? newState.players[winnerId].name : "无人";

          let newLogs = [...newState.logs];
          newLogs.push(`--- 游戏结束! ${winnerName} 获胜! ---`);
          newLogs.push("--- 房间已重置, 等待房主重新开始 ---");
          if (newLogs.length > 20) newLogs = newLogs.slice(newLogs.length - 20);

          // *** 修改 2: 游戏结束后，重置筹码为配置的初始值 ***
          const resetPlayers = {};
          allPlayerIds.forEach((uid) => {
            const p = newState.players[uid];
            if (p) {
              resetPlayers[uid] = {
                ...p,
                chips: config.initialChips,
                holeCards: [],
                folded: false,
                currentBet: 0,
                accumulatedBet: 0,
                status: "等待中",
                bestHand: null,
              };
            }
          });

          return {
            status: "waiting", // 回到等待状态
            hostId: newState.hostId,
            config: config, // <--- 确保保留配置
            players: resetPlayers,
            playerOrder: allPlayerIds,
            communityCards: [],
            pot: 0,
            dealerIndex: 0,
            currentPlayerIndex: -1,
            currentMaxBet: 0,
            phase: "waiting",
            lastRaiseAmount: config.bigBlind, // <--- 使用配置值 (原为 BIG_BLIND)
            deck: [],
            logs: newLogs,
            highlightWinner: winnerId,
            highlightCards: [],
            nextRoundTimer: 0,
            nextPhaseTimer: 0,
          };
          // *** 结束修改 ***
        }

        // 如果游戏未结束, 使用活跃玩家列表
        newState.playerOrder = activePlayerIds;

        // 3. 重置状态
        newState.communityCards = [];
        newState.pot = 0;
        newState.currentMaxBet = 0;

        // *** 修改 3: 重置最小加注额为大盲注配置 ***
        newState.lastRaiseAmount = config.bigBlind; // <--- 使用配置值
        // *** 结束修改 ***

        newState.phase = "preflop";
        newState.playersActed = [];
        newState.highlightWinner = null;
        newState.highlightCards = [];
        newState.nextRoundTimer = 0;
        newState.nextPhaseTimer = 0;

        // 4. 重置玩家
        newState.playerOrder.forEach((uid) => {
          const p = newState.players[uid];
          p.holeCards = [];
          p.folded = false;
          p.currentBet = 0;
          p.accumulatedBet = 0;
          p.status = "";
          p.bestHand = null;
        });

        // 5. 洗牌
        let deck = [];
        for (let suit of SUITS) {
          for (let rank of RANKS) {
            deck.push({
              suit,
              rank,
              value: RANK_VALUES[rank],
              color: suit === "♥" || suit === "♦" ? "red" : "black",
              id: Math.random().toString(36).substr(2, 9),
            });
          }
        }
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        newState.deck = deck;

        // 6. 移动庄家
        newState.dealerIndex =
          (newState.dealerIndex + 1) % newState.playerOrder.length;
        const numPlayers = newState.playerOrder.length;

        // 7. 放置盲注
        const sbIndex = (newState.dealerIndex + 1) % numPlayers;
        const bbIndex = (newState.dealerIndex + 2) % numPlayers;

        const sbPlayerId = newState.playerOrder[sbIndex];
        const bbPlayerId = newState.playerOrder[bbIndex];

        // --- 修改开始: 小盲注全押检测 ---
        const sbPlayer = newState.players[sbPlayerId];
        const sbAmount = Math.min(config.smallBlind, sbPlayer.chips);
        sbPlayer.chips -= sbAmount;
        sbPlayer.currentBet = sbAmount;
        // 如果扣完钱筹码为0，状态必须是 "全押"，否则是 "小盲"
        sbPlayer.status = sbPlayer.chips === 0 ? "全押" : "小盲"; 
        // --- 修改结束 ---

        // --- 修改开始: 大盲注全押检测 ---
        const bbPlayer = newState.players[bbPlayerId];
        const bbAmount = Math.min(config.bigBlind, bbPlayer.chips);
        bbPlayer.chips -= bbAmount;
        bbPlayer.currentBet = bbAmount;
        // 如果扣完钱筹码为0，状态必须是 "全押"，否则是 "大盲"
        bbPlayer.status = bbPlayer.chips === 0 ? "全押" : "大盲";
        // --- 修改结束 ---

        newState.pot = sbAmount + bbAmount;
        newState.currentMaxBet = config.bigBlind;

        // 8. 发手牌
        for (let i = 0; i < 2; i++) {
          for (let uid of newState.playerOrder) {
            newState.players[uid].holeCards.push(newState.deck.pop());
          }
        }

        // 9. 设置第一个行动者 (从大盲注左侧开始找)
        // (保留你刚才修好的跳过全押玩家的逻辑)
        let nextIdx = (bbIndex + 1) % numPlayers;
        let loopCount = 0;

        while (loopCount < numPlayers) {
            const pId = newState.playerOrder[nextIdx];
            const p = newState.players[pId];
            if (p.chips > 0) {
                break;
            }
            nextIdx = (nextIdx + 1) % numPlayers;
            loopCount++;
        }
        newState.currentPlayerIndex = nextIdx;

        // *** 新增: 检查盲注阶段是否直接形成 All-in 局面 ***
        // 获取所有正在玩且未弃牌的人
        const activePlayersInGame = newState.playerOrder
            .map(uid => newState.players[uid])
            .filter(p => !p.folded);
        
        // 获取还有筹码的人
        const playersWithChips = activePlayersInGame.filter(p => p.chips > 0);

        // 判定条件: 
        // 1. 游戏里至少有2个人 (activePlayersInGame.length >= 2)
        // 2. 拥有筹码的人数 <= 1 (意味着其他人全押了，或者所有人全押了)
        // 这种情况在单挑时: A(5, All-in), B(10) -> B有筹码, A无 -> count=1 -> 触发
        if (activePlayersInGame.length >= 2 && playersWithChips.length <= 1) {
            newState.logs.push("--- 盲注导致全押，自动进入摊牌 ---");
            
            // 关键: 直接调用自动摊牌函数
            // runAutoShowdown 会自动:
            // 1. 调用 returnExcessBets 退还 B 多下的盲注 (10 - 5 = 5)
            // 2. 发完剩下的公共牌
            // 3. 进入结算
            return runAutoShowdown(newState);
        }
        // *** 新增结束 ***

        newState.logs.push("--- 新回合开始 ---");
        return newState;
      }

      // --- UI 渲染和音效 (客户端) ---
      class GameUIManager {
        constructor() {
          this.sound = new SoundManager();
          this.dragSystem = new TableDragSystem();
          this.occlusionManager = new OcclusionManager();
          this.lastState = null; // 用于比较状态
          this.localPlayerId = null;
          this.highlightCards = new Set();
          this.bankruptcyScreenShown = false; // *** 新增: 破产界面显示标志 ***
          this.lastAllInPlayerTriggered = null; // *** 修复: 移到构造函数 ***

          // 绑定加注滑块
          document.getElementById("raise-slider").oninput = () => {
            const slider = document.getElementById("raise-slider");
            const btnRaise = document.getElementById("btn-raise");
            const valDisplay = document.getElementById("raise-val-display");

            if (slider && btnRaise && valDisplay && !slider.disabled) {
              const raiseVal = parseInt(slider.value);
              const maxVal = parseInt(slider.max);

              valDisplay.innerText = `$${raiseVal}`;
              btnRaise.innerText =
                raiseVal === maxVal ? "全押" : `加注 $${raiseVal}`;
            }
          };
        }

        initSound() {
          this.sound.init();
          sound = this.sound; // 赋值给全局音效
        }

        // --- 移除: showDialogue 函数 ---

        // --- 移除: speak 函数 ---

        // --- 核心渲染函数 ---
        renderGameState(state, localId) {
          if (!state) {
            console.log("Render: state 为空");
            return;
          }

          // *** 新增: 确保音效被激活 (请求 #1) ***
          this.initSound();

          // *** 新增: 客户端音效 (基于日志) (请求 #1) ***
          // *** 修复: 解决日志满20条后音效失效的Bug ***
          const lastLog = state.logs.length > 0 ? state.logs[state.logs.length - 1] : "";
          const prevLog = (this.lastState && this.lastState.logs.length > 0) ? this.lastState.logs[this.lastState.logs.length - 1] : "";
          
          // 判断条件：长度增加 或者 (长度没变但最后一条内容变了)
          const hasNewLog = this.lastState && (
              state.logs.length > this.lastState.logs.length || 
              (state.logs.length > 0 && lastLog !== prevLog)
          );

          if (hasNewLog) {
            const newLog = lastLog; // 使用获取到的最新日志

            if (newLog.includes("弃牌")) {
              this.sound.playFold();
            } else if (newLog.includes("过牌")) {
              this.sound.playCheck();
            } else if (newLog.includes("跟注")) {
              this.sound.playChip();
            } else if (newLog.includes("加注")) {
              this.sound.playRaise();
            }
            // All-in sound is handled by showAllInEffect

            // 牌局音效
            if (
              newLog.includes("--- 翻牌 ---") || 
              newLog.includes("--- 转牌 ---") || 
              newLog.includes("--- 河牌 ---") 
            ) {
              this.sound.playCard();
            }
          }
          // *** 结束新增 ***

          // *** 修复: 将高光列表的更新移至最前方 ***
          this.highlightCards = new Set(state.highlightCards || []);
          // *** 结束修复 ***

          // --- 恢复的逻辑: 更新玩家计数 ---
          // *** 修改: (请求 #1) 计数器现在应该计算 players, 而不是 playerOrder, 因为 playerOrder 在等待时是完整的 ***
          const playerCount = state.playerOrder ? state.playerOrder.length : 0;
          const countEl = document.getElementById("active-players-count");
          if (countEl) countEl.innerText = playerCount;
          // --- 结束 ---

          // --- 修复: 比较 All-in 特效 ---
          // 必须在 this.lastState 被覆盖之前进行比较
          // 修正了之前 (state.lastAllInPlayer !== this.lastState.lastAllInPlayer) 永远为 false 的 bug
          if (
            state.lastAllInPlayer &&
            (!this.lastState ||
              state.lastAllInPlayer !== this.lastState.lastAllInPlayer)
          ) {
            // 确保我们只在 lastAllInPlayer *改变* 时触发
            if (state.lastAllInPlayer !== this.lastAllInPlayerTriggered) {
              this.showAllInEffect(state.lastAllInPlayer);
              this.lastAllInPlayerTriggered = state.lastAllInPlayer; // 标记已触发
            }
          }
          // 回合结束时清除标记
          if (state.phase === "showdown") {
            this.lastAllInPlayerTriggered = null;
          }
          // --- 修复结束 ---

          this.lastState = state; // 现在才更新 lastState
          this.localPlayerId = localId;
          const localPlayer = state.players[localId];

          // 1. 更新顶部信息
          document.getElementById("pot-display").innerText = state.pot;
          document.getElementById("phase-display").innerText =
            PHASE_NAME_MAP[state.phase] || "未知";

          if (state.config) {
              const blindsEl = document.getElementById("blinds-display");
              if (blindsEl) {
                  blindsEl.innerText = `盲注 $${state.config.smallBlind}/$${state.config.bigBlind}`;
              }
          }

          // 2. 渲染牌桌
          this.renderTableLayout(state, localId);

          // 3. 渲染公共牌
          const commDiv = document.getElementById("community-cards");
          commDiv.innerHTML = "";
          const row1 = document.createElement("div");
          row1.className = "flex space-x-2";
          const row2 = document.createElement("div");
          row2.className = "flex space-x-2";

          // *** 修复: 移除了 this.highlightCards 的重复设置 ***

          state.communityCards.forEach((c, i) => {
            const cardEl = this.createCardEl(c);
            if (i < 3) row1.appendChild(cardEl);
            else row2.appendChild(cardEl);
          });
          commDiv.appendChild(row1);
          if (state.communityCards.length > 3) commDiv.appendChild(row2);

          // 4. 更新日志
          const logDiv = document.getElementById("game-log");
          logDiv.innerHTML = state.logs
            .map((msg) => `<div>> ${msg}</div>`)
            .join("");
          logDiv.scrollTop = logDiv.scrollHeight;

          // 5. 更新玩家座位信息 (已在 renderTableLayout 中处理)

          // 6. 更新控制按钮
          this.updateControls(state);

          // *** 修复: 移除了旧的房主控制逻辑 (Section 7) ***

          // 8. All-in 特效 (逻辑已移到本函数开头)

          // 9. 游戏结束画面
          // *** 修复: (请求 #4) 检查逻辑 ***
          const screen = document.getElementById("game-over-screen");
          
          // *** 修复: (请求 #12) 使用 this.bankruptcyScreenShown 标志 ***
          if (localPlayer) {
            const isEliminated =
              localPlayer.status === "淘汰" && localPlayer.chips === 0;

            // 检查是否是冠军 (游戏在 waiting 状态结束)
            const isChampion =
              state.status === "waiting" &&
              state.highlightWinner === localId &&
              state.logs.length > 0 && // 确保日志存在
              state.logs[state.logs.length - 2].includes("游戏结束");

            if (isChampion) {
              // 游戏刚结束, 我是冠军.
              // 只有在屏幕隐藏时才显示
              if (screen.classList.contains("hidden")) {
                this.showGameOver(true, true, localPlayer); // (isWin, isGameFinished, player)
              }
              this.bankruptcyScreenShown = false; // 重置破产标志
            } 
            // 检查是否 *刚刚* 破产 (游戏中)
            else if (isEliminated && state.status === "playing" && !this.bankruptcyScreenShown) {
              // 游戏正在进行, 但我刚破产了, 并且 *还未显示过* 破产界面.
              this.showGameOver(false, false, localPlayer); // (isWin=false, isGameFinished=false, player)
              // *** 关键: 设置标志, 防止重复触发 ***
              this.bankruptcyScreenShown = true; 
            }
            // 检查是否是输家 (游戏在 waiting 状态结束)
            else if (isEliminated && state.status === "waiting") {
              // 游戏结束了, 但我早先就输了.
              // 只有在屏幕隐藏时才显示 (避免覆盖 "观战中" 消息)
              if (screen.classList.contains("hidden") && this.bankruptcyScreenShown) {
                 this.showGameOver(false, true, localPlayer); // (isWin=false, isGameFinished=true, player)
              }
              // 游戏结束, 无论如何都要重置标志
              this.bankruptcyScreenShown = false; 
            }
          }
          // *** 结束修复 ***


          // *** (请求 #1) 如果重置了, 隐藏结束画面 ***
          // *** 修改: 自动隐藏所有人的结束画面 (冠军/输家)，以显示等待室 ***
          if (
            state.status === "waiting" &&
            !screen.classList.contains("hidden")
          ) {
            // 检查是否是由"游戏结束"（即有赢家高亮）触发的
            if (state.highlightWinner) {
              // showGameOver 刚刚被调用, 检查它是否设置了 "isGameFinished" 状态
              // 我们可以通过检查 msg 文本来判断
              const msg = document.getElementById("game-over-msg").innerText;
              if (msg.includes("房间已重置")) {
                
                // *** 新增: 重置标志 ***
                this.bankruptcyScreenShown = false; 
                
                setTimeout(() => {
                  // 确保它仍然没有被用户手动隐藏
                  if (!screen.classList.contains("hidden")) {
                    screen.classList.add("hidden");
                    this.showMessage("游戏结束，等待房主重新开始...");
                  }
                }, 4000); // 延迟4秒隐藏
              }
            } else {
              // 如果不是游戏结束（例如玩家刚加入），立即隐藏
              screen.classList.add("hidden");
              // *** 新增: 重置标志 ***
              this.bankruptcyScreenShown = false; 
            }
          }

          // 10. *** 新增: 等待室 UI ***
          const waitOverlay = document.getElementById("waiting-room-overlay");
          if (state.status === "waiting") {
            waitOverlay.classList.remove("hidden");
            network.updateWaitingRoomUI(state, localId); // *** 修复: 改为调用 network.updateWaitingRoomUI ***
          } else {
            waitOverlay.classList.add("hidden");
          }
        }

        // --- 渲染牌桌布局 (根据状态) ---
        renderTableLayout(state, localId) {
          const container = document.getElementById("seats-container");
          container.innerHTML = ""; // 清空

          // *** 修改: (请求 #1) 在 'waiting' 状态, playerOrder 包含所有人 ***
          // *** 我们只渲染 'playing' 状态下的 playerOrder ***
          const playerIdsToRender =
            state.phase === "waiting" || state.status === "waiting"
              ? state.playerOrder // 在等待时，渲染所有人
              : state.playerOrder; // 在游戏中，playerOrder 已经是 activePlayers

          const num = playerIdsToRender.length;
          if (num === 0) return;

          const w = container.offsetWidth;
          const h = container.offsetHeight;
          const cx = w / 2;
          const cy = h / 2;
          const localIndex = playerIdsToRender.indexOf(localId);

          // 如果找不到本地玩家 (例如观战), 默认 localIndex 为 0
          const renderIndex = localIndex === -1 ? 0 : localIndex;

          // 动态调整半径和缩放
          let scale = 1;
          let radiusX = 0.38;
          let radiusY = 0.38;
          if (num > 6) {
            scale = 0.85;
            radiusX = 0.42;
            radiusY = 0.42;
          }
          if (num >= 9) {
            scale = 0.75;
            radiusX = 0.44;
            radiusY = 0.44;
          }
          if (w < 768) {
            if (num > 5) scale = 0.75;
            if (num > 8) scale = 0.65;
            radiusX = 0.4;
          }
          const rx = w * radiusX;
          const ry = h * radiusY;

          playerIdsToRender.forEach((uid, i) => {
            const p = state.players[uid];
            if (!p) return; // 玩家可能已离开

            // 计算位置，确保本地玩家总在最下方
            const offsetIndex = (i - renderIndex + num) % num;
            const angle = Math.PI / 2 + (offsetIndex * (2 * Math.PI)) / num;
            const x = cx + rx * Math.cos(angle);
            const y = cy + ry * Math.sin(angle);

            const div = document.createElement("div");
            div.id = `seat-${p.uid}`; // *** 修改: ID 匹配 ***
            div.className = "player-seat";
            div.style.left = `${x - 60}px`;
            div.style.top = `${y - 55}px`;
            div.style.transform = `scale(${scale})`;

            // --- 渲染手牌 ---
            let cardsHTML = "";
            if (!p.folded && p.holeCards && p.holeCards.length > 0) {
              
              // *** 修复: 计算当前存活(未弃牌)的玩家数量 ***
              const activePlayersCount = Object.values(state.players).filter(player => !player.folded).length;

              // *** 修复: 只有是自己，或者 (是摊牌阶段 且 存活玩家大于1人) 时才显示正面 ***
              // 这样如果是唯一赢家(其他人全弃牌)，activePlayersCount 为 1，别人就看不到赢家的牌了
              if (p.uid === localId || (state.phase === "showdown" && activePlayersCount > 1)) {
                cardsHTML = p.holeCards
                  .map((c) => this.createCardEl(c).outerHTML)
                  .join("");
              } else {
                cardsHTML =
                  this.createBackEl().outerHTML + this.createBackEl().outerHTML;
              }
            }

            // --- 渲染座位 ---
            div.innerHTML = `
                        <div id="cards-${
                          p.uid
                        }" class="absolute flex space-x-1 z-10 transition-all" style="top:-50px;">
                            ${cardsHTML}
                        </div>
                        
                        <div class="player-info-box relative z-20">
                            <div id="dealer-${p.uid}" class="dealer-btn ${
              i === state.dealerIndex ? "" : "hidden"
            }">D</div>
                            <div class="font-bold text-yellow-400 truncate text-sm tracking-wide">${
                              p.name
                            }</div>
                            <div class="text-white text-xs font-mono">$<span id="chips-${
                              p.uid
                            }">${p.chips}</span></div>
                            <div id="status-${
                              p.uid
                            }" class="text-gray-400 text-[10px] h-4 truncate font-bold uppercase mt-1">
                                ${
                                  p.currentBet > 0
                                    ? `下注 $${p.currentBet}`
                                    : p.status || ""
                                }
                            </div>
                        </div>`;
            container.appendChild(div);

            // --- 应用高亮 ---
            const seat = document.getElementById(`seat-${p.uid}`);
            if (
              state.playerOrder[state.currentPlayerIndex] === p.uid &&
              state.phase !== "showdown"
            ) {
              seat.classList.add("active-player");
            } else {
              seat.classList.remove("active-player");
            }

            if (state.highlightWinner === p.uid) {
              seat.classList.add("winner-highlight");
            } else {
              seat.classList.remove("winner-highlight");
            }

            seat.style.opacity = p.folded ? 0.4 : 1;
          });
        }

        // --- 更新控制按钮 (客户端) ---
        updateControls(state) {
          // *** 修复: 确保在调用前 lastState 和 localPlayerId 已设置 ***
          if (!state || !state.players || !this.localPlayerId) return;
          const localPlayer = state.players[this.localPlayerId];
          if (!localPlayer) return; // 如果玩家数据不存在，则退出
          // *** 结束修复 ***

          const controls = document.getElementById("player-controls");

          // 1. 检查是否轮到本地玩家
          const isMyTurn =
            state.playerOrder[state.currentPlayerIndex] === this.localPlayerId;
          const canAct =
            isMyTurn &&
            !localPlayer.folded &&
            localPlayer.chips > 0 &&
            state.phase !== "showdown";

          if (!canAct) {
            controls.classList.add(
              "opacity-50",
              "pointer-events-none",
              "translate-y-2"
            );
            return;
          }

          controls.classList.remove(
            "opacity-50",
            "pointer-events-none",
            "translate-y-2"
          );
          // this.initSound(); // *** 移除: 已移至 renderGameState (请求 #1) ***
          gameUI.showMessage("你的回合");

          // 2. 计算按钮状态
          const diff = state.currentMaxBet - localPlayer.currentBet;
          const btnCheck = document.getElementById("btn-check");
          const btnCall = document.getElementById("btn-call");
          const btnRaise = document.getElementById("btn-raise");
          const slider = document.getElementById("raise-slider");
          const valDisplay = document.getElementById("raise-val-display");

          // 3. 处理 "过牌" / "跟注"
          if (diff === 0) {
            btnCheck.classList.remove("hidden");
            btnCall.classList.add("hidden");
          } else {
            btnCheck.classList.add("hidden");
            btnCall.classList.remove("hidden");
            if (localPlayer.chips <= diff) btnCall.innerText = "全押";
            else btnCall.innerText = `跟注 $${diff}`;
          }

          // 4. 处理 "加注" (No-Limit 逻辑)
          // *** 修复: 完全还原为 读博.html (原版) 的加注逻辑 ***

          // 2. 计算最小和最大的 *行动* 加注额

          // 最小 *额外* 加注额 (等于上一次的加注差额)
          const minRaiseAmount = state.lastRaiseAmount;

          // 最小合法 *行动* 加注额 (跟注额 + 最小额外加注额)
          // (注意: 这里的 diff 是跟注额, 所以 slider.value 是 *本次行动* 的总支付额)
          const minPossibleActionRaise = diff + minRaiseAmount;

          // 玩家能下注的最大 *行动* 额 (即全押, 支付所有剩余筹码)
          const maxPossibleActionRaise = localPlayer.chips;

          // 3. 根据筹码情况决定 "加注" 按钮的状态

          // 场景 1: 跟注就是全押 (筹码 <= 跟注额)
          if (localPlayer.chips <= diff) {
            btnRaise.classList.add("hidden");
            document
              .getElementById("raise-slider-container")
              .classList.add("hidden");

            // 场景 2: 筹码不足以进行最小 *额外* 加注 (maxPossibleActionRaise < minPossibleActionRaise)
          } else if (maxPossibleActionRaise < minPossibleActionRaise) {
            // 玩家不能进行 "最小加注", 但 *可以* "全押"
            btnRaise.classList.remove("hidden");
            btnRaise.innerText = "全押"; // 强制文本为 "全押"

            document
              .getElementById("raise-slider-container")
              .classList.remove("hidden");
            // 滑块现在代表 *行动* 金额.
            // 最小值, 最大值, 和当前值都是 maxPossibleActionRaise (即玩家的全部筹码)
            slider.min = maxPossibleActionRaise;
            slider.max = maxPossibleActionRaise;
            slider.value = maxPossibleActionRaise;
            valDisplay.innerText = `$${maxPossibleActionRaise}`; // 显示行动的金额
            slider.disabled = true; // 禁用滑块

            // (onclick 已被 network.handleHumanAction('raise') 绑定, 无需重写)

            // 场景 3: 筹码充足, 可以正常加注
          } else {
            btnRaise.classList.remove("hidden");
            document
              .getElementById("raise-slider-container")
              .classList.remove("hidden");

            // 滑块范围现在是 *行动* 的加注额
            slider.min = minPossibleActionRaise;
            slider.max = maxPossibleActionRaise;

            // 步进必须为 1 (原版 读博.html 也是 1)
            slider.step = 1;

            // *** 修改: (请求 #2) 始终将滑块重置为最小值 ***
            slider.value = slider.min;
            // *** 结束修改 (请求 #2) ***

            slider.disabled = false; // 确保滑块启用

            // (onclick 已被 network.handleHumanAction('raise') 绑定, 无需重写)

            const updateBtnText = () => {
              const raiseVal = parseInt(slider.value); // 这是 *行动* 的金额

              // 显示 *行动* 的金额
              valDisplay.innerText = `$${raiseVal}`;

              if (raiseVal === maxPossibleActionRaise) {
                btnRaise.innerText = "全押";
              } else {
                // 按钮文本显示 "加注 X" (X=行动金额)
                btnRaise.innerText = `加注 $${raiseVal}`;
              }
            };

            // *** 修复: 移除 slider.oninput 的重复绑定 (已在构造函数中绑定) ***
            updateBtnText(); // 立即执行一次
          }
          // *** 修复结束 ***
        }

        // --- 调整加注滑块 ---
        adjustRaise(direction) {
          const slider = document.getElementById("raise-slider");
          if (!slider || slider.disabled) return;
          const currentVal = parseInt(slider.value);
          // *** 修复: 步进改为 1 (匹配原版 读博.html) ***
          const step = 1;
          // *** 结束修复 ***
          const min = parseInt(slider.min);
          const max = parseInt(slider.max);
          let newVal = currentVal + direction * step;
          if (newVal < min) newVal = min;
          if (newVal > max) newVal = max;
          slider.value = newVal;
          // 手动触发 input 事件来更新显示
          slider.dispatchEvent(new Event("input"));
        }

        // --- 显示消息 ---
        showMessage(msg) {
          const el = document.getElementById("game-message");
          el.innerText = msg;
          el.style.opacity = 1;
          clearTimeout(this.msgTimeout);
          this.msgTimeout = setTimeout(() => (el.style.opacity = 0), 3000);
        }

        // --- All-in 特效 ---
        showAllInEffect(playerName) {
          return new Promise((resolve) => {
            const overlay = document.createElement("div");
            overlay.className = "all-in-fullscreen-overlay";
            const bar = document.createElement("div");
            bar.className = "all-in-bar";
            const text = document.createElement("div");
            text.className = "all-in-text";
            
            text.innerText = `ALL-IN`;
            bar.appendChild(text);
            overlay.appendChild(bar);
            document.body.appendChild(overlay);
            
            this.sound.playAllIn();
            
            setTimeout(() => {
              overlay.style.transition = "opacity 0.3s";
              overlay.style.opacity = "0";
              setTimeout(() => {
                overlay.remove();
                resolve();
              }, 300);
            }, 1250);
          });
        }

        // --- 游戏结束 ---
        // *** 修复: (请求 #4) 修正函数位置，移到 GameUIManager 内部 ***
        showGameOver(isWin, isGameFinished, player) {
          const screen = document.getElementById("game-over-screen");
          const title = document.getElementById("game-over-title");
          const msg = document.getElementById("game-over-msg");
          const btnContainer = document.getElementById("game-over-buttons"); // *** 新增 ***

          screen.classList.remove("hidden");

          if (isWin) {
            // *** 冠军 (请求 #4) ***
            title.innerText = "冠军";
            title.className = "text-6xl font-black mb-4 text-yellow-500";
            msg.innerText = `你击败了所有对手！房间已重置。`; // *** 修改: (请求 #1) ***
            sound.playWin();

            // *** 修改: 游戏结束自动重置, 移除按钮 ***
            btnContainer.innerHTML = `<p class="text-gray-500 text-sm">将在4秒后自动返回等待室...</p>`;
          } else {
            // *** 破产 (请求 #4) ***
            title.innerText = "破产";
            title.className = "text-6xl font-black mb-4 text-red-600";
            msg.innerText = "你的筹码已耗尽。";
            sound.playLose();

            if (isGameFinished) {
              // 游戏结束了，我是输家
              msg.innerText = "你的筹码已耗尽。房间已重置。"; // *** 修改: (请求 #1) ***
              // *** 修改: 游戏结束自动重置, 移除按钮 ***
              btnContainer.innerHTML = `<p class="text-gray-500 text-sm">将在4秒后自动返回等待室...</p>`;
            } else {
              // 游戏还在继续，我可以观战 (保持按钮)
              btnContainer.innerHTML = `
                            <button onclick="network.leaveRoom()" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg">返回大厅</button>
                            <button onclick="gameUI.spectate(false)" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg">继续观战</button>
                        `;
            }
          }
        }

        // *** 修复: (请求 #4) 修正函数位置，移到 GameUIManager 内部 ***
        spectate(isGameFinished) {
          document.getElementById("game-over-screen").classList.add("hidden");
          if (isGameFinished) {
            this.showMessage("游戏已结束。等待房主重新开始...");
          } else {
            this.showMessage("观战中... (筹码已耗尽)");
          }
          // 玩家仍在房间内, 仍会接收 onSnapshot 更新
        }

        // --- 创建卡牌元素 ---
        createCardEl(c) {
          const d = document.createElement("div");
          d.className = `card ${c.color}`;
          if (this.highlightCards.has(c.id)) d.classList.add("winning-card");
          d.innerHTML = `<span class="absolute top-0 left-1 text-xs">${c.rank}</span><span class="text-2xl">${c.suit}</span>`;
          return d;
        }
        createBackEl() {
          const d = document.createElement("div");
          d.className = "card card-back";
          return d;
        }
      }

      // --- 网络和 Firebase 交互 ---
      class NetworkManager {
        constructor(gameUI) {
          this.gameUI = gameUI;
          this.db = null;
          this.auth = null;
          this.appId = appId;
          this.localUserId = null;
          this.currentRoomId = null;
          this.unsubscribeRoom = null;
          this.nextRoundTimeout = null;
          this.nextPhaseTimeout = null; // *** 新增: 自动推进计时器 ***
          // *** 移除: AI 思考锁 ***
        }

        async init() {
          try {
            setLogLevel("Debug"); // 开启 Firebase 调试日志
            this.app = initializeApp(firebaseConfig);
            this.db = getFirestore(this.app);
            this.auth = getAuth(this.app);

            console.log("Firebase 初始化... AppID:", this.appId);

            onAuthStateChanged(this.auth, async (user) => {
              if (user) {
                this.localUserId = user.uid;
                console.log("Firebase 已认证:", this.localUserId);
                document.getElementById("user-id-display").innerText =
                  this.localUserId;
                document
                  .getElementById("firebase-loader")
                  .classList.add("hidden");
                document
                  .getElementById("room-screen")
                  .classList.remove("hidden");
              } else {
                console.log("用户未登录，尝试登录...");
                await this.signIn();
              }
            });
          } catch (error) {
            console.error("Firebase 初始化失败:", error);
            document.getElementById("firebase-loader").innerText =
              "连接失败，请刷新。";
          }
        }

        // --- 修复: UI上移 + 输入框严格纯数字校验 ---
        updateWaitingRoomUI(state, localId) {
          const hostControls = document.getElementById("wait-host-controls");
          const btnContainer = document.getElementById("host-start-btn-container");

          if (state.hostId === localId) {
            // --- 我是房主 ---
            hostControls.classList.remove("hidden");

            const bbInput = document.getElementById("setting-big-blind");
            const chipsInput = document.getElementById("setting-initial-chips"); // 获取筹码输入框
            const sbDisplay = document.getElementById("setting-sb-display");

            // *** 修改 1: 绑定筹码输入框的净化逻辑 (防粘贴) ***
            if (chipsInput && !chipsInput.oninput) {
                chipsInput.oninput = () => {
                    // 强制替换非数字字符
                    chipsInput.value = chipsInput.value.replace(/[^\d]/g, '');
                };
            }

            // *** 修改 2: 绑定大盲注输入框的净化逻辑 + 联动 ***
            if (bbInput && !bbInput.oninput) {
                bbInput.oninput = () => {
                    // 强制替换非数字字符
                    bbInput.value = bbInput.value.replace(/[^\d]/g, '');
                    
                    const val = parseInt(bbInput.value) || 0;
                    if(sbDisplay) sbDisplay.innerText = Math.floor(val / 2);
                };
            }

            // 房主不需要文本提示，直接隐藏
            const waitMessage = document.getElementById("wait-message");
            if (waitMessage) waitMessage.classList.add("hidden"); 

            const playerCount = state.playerOrder.length;

            if (playerCount < 2) {
              // --- 人数不足 ---
              if (btnContainer) {
                btnContainer.innerHTML = `
                  <button disabled class="bg-gray-500 text-gray-300 font-black text-2xl py-4 px-12 rounded-full shadow-none border-b-4 border-gray-700 cursor-not-allowed opacity-50">
                    等待玩家 (${playerCount}/10)
                  </button>
                `;
              }
            } else {
              // --- 人数足够 ---
              if (btnContainer) {
                btnContainer.innerHTML = `
                  <button 
                    id="btn-start-game"
                    onclick="network.startGame()" 
                    class="bg-red-600 hover:bg-red-500 text-white font-black text-2xl py-4 px-12 rounded-full shadow-xl border-b-4 border-red-800 active:border-b-0 active:translate-y-1 transition-all">
                    开始游戏 (${playerCount}/10)
                  </button>
                `;
              }
            }
          } else {
            // --- 我是普通玩家 ---
            hostControls.classList.add("hidden");
            if (btnContainer) btnContainer.innerHTML = ""; 
            
            const hostPlayer = state.players[state.hostId];
            const hostName = hostPlayer ? hostPlayer.name : "房主";
            
            const waitMessage = document.getElementById("wait-message");
            if (waitMessage) {
                waitMessage.classList.remove("hidden");
                waitMessage.innerText = `等待 ${hostName} 开始游戏...`;
            }
          }
        }

        async signIn() {
          try {
            // 优先使用 Canvas 提供的令牌
            if (initialAuthToken) {
              console.log("使用 __initial_auth_token 登录...");
              await signInWithCustomToken(this.auth, initialAuthToken);
            } else {
              // 否则，匿名登录
              console.log("使用匿名登录...");
              await signInAnonymously(this.auth);
            }
          } catch (error) {
            console.error("Firebase 登录失败:", error);
          }
        }

        getRoomRef(roomId) {
          return doc(
            this.db,
            "artifacts",
            this.appId,
            "public/data/poker-rooms",
            roomId
          );
        }

        validateInputs() {
          const name = document
            .getElementById("player-name-input")
            .value.trim();
          const room = document.getElementById("room-id-input").value.trim();
          const errEl = document.getElementById("room-error");

          if (name.length < 2 || name.length > 10) {
            errEl.innerText = "昵称必须在 2-10 个字符之间";
            return null;
          }
          if (room.length < 1 || room.length > 20) {
            errEl.innerText = "房间 ID 不能为空";
            return null;
          }

          localPlayerName = name; // 存储昵称
          errEl.innerText = "";
          return room;
        }

        // --- 创建房间 ---
        async createRoom() {
          const roomId = this.validateInputs();
          if (!roomId) return;

          this.disableRoomButtons(true);
          const roomRef = this.getRoomRef(roomId);

          try {
            const docSnap = await getDoc(roomRef);
            if (docSnap.exists()) {
              document.getElementById("room-error").innerText =
                "房间已存在，请换个ID";
              this.disableRoomButtons(false);
              return;
            }

            // 创建新玩家
            const newPlayer = {
              uid: this.localUserId,
              id: 0, // 房主总是 0
              name: localPlayerName,
              chips: 2000,
              holeCards: [],
              folded: false,
              currentBet: 0,
              accumulatedBet: 0,
              status: "等待中",
            };

            // 创建新房间状态
            const initialState = {
              status: "waiting", // waiting, playing, finished
              hostId: this.localUserId,
              // *** 新增: 默认游戏配置 ***
              config: {
                initialChips: 2000,
                smallBlind: 10,
                bigBlind: 20
              },
            
              players: {
                [this.localUserId]: newPlayer,
              },
              playerOrder: [this.localUserId], // 玩家加入顺序
              communityCards: [],
              pot: 0,
              dealerIndex: 0,
              currentPlayerIndex: -1, // -1 表示游戏未开始
              currentMaxBet: 0,
              phase: "waiting",
              lastRaiseAmount: 20,
              deck: [], // 游戏开始时再洗牌
              logs: [`${localPlayerName} 创建了房间.`],
              highlightWinner: null,
              highlightCards: [],
              nextRoundTimer: 0,
              nextPhaseTimer: 0, // *** 新增: 计时器 ***
            };

            await setDoc(roomRef, initialState);
            console.log("房间创建成功:", roomId);
            this.subscribeToRoom(roomId);
          } catch (error) {
            console.error("创建房间失败:", error);
            document.getElementById("room-error").innerText = "创建房间失败";
            this.disableRoomButtons(false);
          }
        }

        // --- 加入房间 ---
        async joinRoom() {
          const roomId = this.validateInputs();
          if (!roomId) return;

          this.disableRoomButtons(true);
          const roomRef = this.getRoomRef(roomId);

          try {
            await runTransaction(this.db, async (transaction) => {
              const roomDoc = await transaction.get(roomRef);
              if (!roomDoc.exists()) {
                throw new Error("房间不存在");
              }

              let state = roomDoc.data();

              // 检查是否已在房间内
              if (state.players[this.localUserId]) {
                console.log("已在房间内，重新加入...");
                // *** 修改: (请求 #1) 如果玩家已存在, 确保他们重置 ***
                if (state.status === "waiting") {
                  state.players[this.localUserId].chips = 2000;
                  state.players[this.localUserId].status = "等待中";
                }
                // *** 结束修改 ***
                transaction.set(roomRef, state); // 确保更新状态
                return; // 直接加入
              }

              // 检查房间状态
              if (state.status !== "waiting") {
                throw new Error("游戏已开始，无法加入");
              }

              // 检查人数
              if (Object.keys(state.players).length >= 10) {
                throw new Error("房间已满");
              }

              // 加入新玩家
              const newPlayerId = Object.keys(state.players).length;
              const newPlayer = {
                uid: this.localUserId,
                id: newPlayerId,
                name: localPlayerName,
                chips: 2000,
                holeCards: [],
                folded: false,
                currentBet: 0,
                accumulatedBet: 0,
                status: "等待中",
              };

              state.players[this.localUserId] = newPlayer;
              state.playerOrder.push(this.localUserId);
              state.logs.push(`${localPlayerName} 加入了房间.`);

              transaction.set(roomRef, state);
            });

            console.log("加入房间成功:", roomId);
            this.subscribeToRoom(roomId);
          } catch (error) {
            console.error("加入房间失败:", error);
            document.getElementById("room-error").innerText =
              error.message || "加入房间失败";
            this.disableRoomButtons(false);
          }
        }

        // --- 退出房间 (已修改: 增加人数不足自动结束逻辑) ---
        async leaveRoom() {
          if (this.unsubscribeRoom) {
            this.unsubscribeRoom(); // 停止监听
            this.unsubscribeRoom = null;
          }

          const roomId = this.currentRoomId;
          const userId = this.localUserId;

          if (roomId && userId) {
            const roomRef = this.getRoomRef(roomId);
            try {
              // 尝试从房间中移除自己
              await runTransaction(this.db, async (transaction) => {
                const roomDoc = await transaction.get(roomRef);
                if (!roomDoc.exists()) return;

                let state = roomDoc.data();

                // 1. 从 players 和 playerOrder 移除
                if (state.players[userId]) {
                  const playerName = state.players[userId].name;
                  delete state.players[userId];
                  state.playerOrder = state.playerOrder.filter(
                    (uid) => uid !== userId
                  );
                  state.logs.push(`${playerName} 离开了房间.`); 
                }

                // 2. 检查是否需要删除房间
                if (state.playerOrder.length === 0) {
                  transaction.delete(roomRef);
                  console.log("房间空了，自动删除");
                  return; // 直接结束事务
                }

                // *** 新增: 如果游戏中人数不足2人，强制结束游戏并重置 ***
                if (state.status === 'playing' && state.playerOrder.length < 2) {
                    state.status = 'waiting'; // 回到等待状态
                    state.phase = 'waiting';
                    state.pot = 0;
                    state.communityCards = [];
                    state.currentMaxBet = 0;
                    state.currentPlayerIndex = -1;
                    state.dealerIndex = 0;
                    state.logs.push("--- 玩家人数不足，游戏强制结束，返回大厅 ---");
                    state.highlightWinner = null;
                    state.highlightCards = [];
                    state.nextRoundTimer = 0;
                    state.nextPhaseTimer = 0;

                    // 重置剩余玩家的状态 (恢复初始筹码)
                    state.playerOrder.forEach(uid => {
                        if(state.players[uid]) {
                            state.players[uid].chips = 2000; // 重置为初始筹码
                            state.players[uid].holeCards = [];
                            state.players[uid].folded = false;
                            state.players[uid].currentBet = 0;
                            state.players[uid].accumulatedBet = 0;
                            state.players[uid].status = "等待中";
                            state.players[uid].bestHand = null;
                        }
                    });
                }

                // 3. 检查房主是否离开
                if (state.hostId === userId) {
                  // 移交房主给下一个人
                  state.hostId = state.playerOrder[0];
                  state.logs.push(
                    `房主移交给 ${state.players[state.hostId].name}.`
                  );
                }
                
                // 4. 保存状态
                transaction.set(roomRef, state);
              });
            } catch (error) {
              console.error("离开房间时出错:", error);
            }
          }

          // 重置 UI
          this.currentRoomId = null;
          if (this.nextRoundTimeout) clearTimeout(this.nextRoundTimeout);
          if (this.nextPhaseTimeout) clearTimeout(this.nextPhaseTimeout);

          // 重置破产标志
          this.gameUI.bankruptcyScreenShown = false;

          document.getElementById("game-area").classList.add("hidden");
          document.getElementById("game-over-screen").classList.add("hidden");
          document.getElementById("room-screen").classList.remove("hidden");
          this.disableRoomButtons(false);
        }

        // --- 订阅房间更新 ---
        subscribeToRoom(roomId) {
          this.currentRoomId = roomId;
          document.getElementById("display-room-id").innerText = roomId;
          document.getElementById("room-screen").classList.add("hidden");
          document.getElementById("game-area").classList.remove("hidden");
          this.gameUI.initSound();
          this.gameUI.occlusionManager.start();

          const roomRef = this.getRoomRef(roomId);
          this.unsubscribeRoom = onSnapshot(
            roomRef,
            (doc) => {
              if (!doc.exists()) {
                // 房间被删除了
                console.log("房间不存在或已被删除。");
                this.gameUI.showMessage("房主已解散房间");
                setTimeout(() => this.leaveRoom(), 2000);
                return;
              }

              const state = doc.data();

              // --- 核心：渲染状态 ---
              this.gameUI.renderGameState(state, this.localUserId);

              // --- 修改: 运行房主控制逻辑 (仅限计时器) ---
              this.runHostTimerController(state);
            },
            (error) => {
              console.error("监听房间失败:", error);
              this.leaveRoom();
            }
          );
        }

        // --- 修改: 房主计时器控制逻辑 (移除了 AI) ---
        runHostTimerController(state) {
          // 1. 检查是否轮到房主自动推进 All-in 阶段
          if (state.nextPhaseTimer > 0 && state.hostId === this.localUserId) {
            if (!this.nextPhaseTimeout) {
              // 防止重复设置
              this.nextPhaseTimeout = setTimeout(async () => {
                console.log("房主：自动推进All-in阶段");
                this.nextPhaseTimeout = null;
                const roomRef = this.getRoomRef(this.currentRoomId);
                try {
                  let currentState = (await getDoc(roomRef)).data();
                  // 确保计时器仍然有效
                  if (currentState.nextPhaseTimer > 0) {
                    currentState.nextPhaseTimer = 0; // 清除计时器
                    // 再次调用 runAutoShowdown, 它会自动处理下一阶段 (turn -> river -> showdown)
                    const nextState = runAutoShowdown(currentState);
                    await setDoc(roomRef, nextState);
                  }
                } catch (error) {
                  console.error("推进All-in阶段失败:", error);
                }
              }, state.nextPhaseTimer);
            }
          } else if (state.nextPhaseTimer === 0 && this.nextPhaseTimeout) {
            // 状态已被其他人清除, 取消本地计时器
            clearTimeout(this.nextPhaseTimeout);
            this.nextPhaseTimeout = null;
          }

          // 2. 检查是否轮到房主自动开始新回合
          if (state.phase === "showdown" && state.hostId === this.localUserId) {
            if (state.nextRoundTimer > 0 && !this.nextRoundTimeout) {
              this.nextRoundTimeout = setTimeout(async () => {
                console.log("房主：自动开始新回合");
                this.nextRoundTimeout = null;
                const roomRef = this.getRoomRef(this.currentRoomId);
                try {
                  // 获取最新状态
                  const currentState = (await getDoc(roomRef)).data();
                  // 确保仍然是摊牌阶段
                  if (currentState.phase === "showdown") {
                    const nextState = startNewRound(currentState);
                    await setDoc(roomRef, nextState);
                  }
                } catch (error) {
                  console.error("开始新回合失败:", error);
                }
              }, state.nextRoundTimer);
            }
          }

          // 3. 移除了 AI 行动检查
        }

        // --- 房主开始游戏 (已修复: 错误提示在标题右侧) ---
        async startGame() {
          if (!this.currentRoomId || !this.gameUI.lastState) return;
          if (this.localUserId !== this.gameUI.lastState.hostId) return;

          // 1. 获取行内错误元素
          const errChipsEl = document.getElementById("error-chips-inline");
          const errBlindEl = document.getElementById("error-blind-inline");
          
          // 2. 清空旧错误
          if (errChipsEl) errChipsEl.innerText = "";
          if (errBlindEl) errBlindEl.innerText = "";

          const chipsInput = document.getElementById("setting-initial-chips");
          const blindInput = document.getElementById("setting-big-blind");
          
          let newInitChips = chipsInput ? parseInt(chipsInput.value) : 2000;
          let newBigBlind = blindInput ? parseInt(blindInput.value) : 20;

          newInitChips = Math.floor(newInitChips);
          newBigBlind = Math.floor(newBigBlind);

          // *** 修改: 验证逻辑，定向输出错误 ***
          let hasError = false;

          // 验证大盲注
          if (newBigBlind < 2 || newBigBlind % 2 !== 0) {
            if (errBlindEl) errBlindEl.innerText = "必须是大于1的偶数！";
            hasError = true;
          }
          
          // 验证初始筹码
          if (newInitChips <= newBigBlind) {
            if (errChipsEl) errChipsEl.innerText = "必须大于大盲注！";
            hasError = true;
          }

          if (hasError) {
              // 震动反馈
              if (navigator.vibrate) navigator.vibrate(200);
              return;
          }
          // *** 结束修改 ***

          const btn = document.getElementById("btn-start-game");
          if (!btn || this.gameUI.lastState.playerOrder.length < 2) {
              return;
          }

          btn.disabled = true;
          btn.innerText = "启动中...";

          const roomRef = this.getRoomRef(this.currentRoomId);
          try {
            const currentState = this.gameUI.lastState;
            if (currentState.status !== "waiting") return;

            // 写入配置
            currentState.config = {
                initialChips: newInitChips,
                bigBlind: newBigBlind,
                smallBlind: Math.floor(newBigBlind / 2)
            };

            // 覆盖所有人的筹码
            Object.keys(currentState.players).forEach(uid => {
                currentState.players[uid].chips = newInitChips;
                currentState.players[uid].currentBet = 0;
            });

            currentState.status = "playing";
            const nextState = startNewRound(currentState);

            await setDoc(roomRef, nextState);
            console.log("游戏启动指令已发送");
          } catch (error) {
            console.error("开始游戏失败:", error);
            btn.disabled = false;
            btn.innerText = "开始游戏";
            this.gameUI.showMessage("启动失败，请重试");
          }
        }

        // --- 玩家提交动作 (修复版) ---
        async handleHumanAction(action) {
          const state = this.gameUI.lastState;
          if (
            !state ||
            state.playerOrder[state.currentPlayerIndex] !== this.localUserId
          ) {
            return; // 不是你的回合
          }

          // 1. 立即锁定 UI，防止重复点击
          this.gameUI.updateControls({ ...state, currentPlayerIndex: -1 }); 

          let actionAmount = 0;
          if (action === "raise") {
            // 获取加注金额
            const slider = document.getElementById("raise-slider");
            if (slider) actionAmount = parseInt(slider.value);
          }

          const roomRef = this.getRoomRef(this.currentRoomId);

          try {
            // 使用事务来处理动作，防止冲突
            await runTransaction(this.db, async (transaction) => {
              const roomDoc = await transaction.get(roomRef);
              if (!roomDoc.exists()) throw new Error("房间不存在");

              const currentState = roomDoc.data();

              // 再次验证是否是该玩家的回合
              if (
                currentState.playerOrder[currentState.currentPlayerIndex] !==
                this.localUserId
              ) {
                console.warn("动作提交时已不是你的回合");
                return;
              }

              let totalAmount = 0;
              const player = currentState.players[this.localUserId];

              if (action === "raise") {
                // 这里的逻辑取决于你之前的 processAction 实现
                totalAmount = player.currentBet + actionAmount; 
                // 注意：请确保这里计算的 totalAmount 符合你 processAction 的要求
                // 如果 actionAmount 已经是总额（slider.value），则直接 totalAmount = actionAmount;
                // 根据之前的上下文，slider.value 似乎是“本次行动的金额”，所以 totalAmount = player.currentBet + actionAmount 是合理的
                // 但如果是 No-Limit 模式，slider 通常直接代表 Total Bet。请根据实际情况微调。
                // 建议保留你原本逻辑中的计算方式。
                totalAmount = player.currentBet + actionAmount; 
              }

              // 调用纯函数计算下一个状态
              const nextState = processAction(
                currentState,
                this.localUserId,
                action,
                totalAmount
              );

              // 写入新状态
              transaction.set(roomRef, nextState);
            });
          } catch (error) {
            console.error("处理动作失败:", error);
            
            // ============================================================
            // *** 核心修复：操作失败时，必须恢复按钮状态！ ***
            // ============================================================
            this.gameUI.showMessage("网络繁忙，请重试");
            
            // 强制使用“上一次的已知状态”重新渲染控制栏，从而重新激活按钮
            if (this.gameUI.lastState && this.localUserId) {
                // 恢复 currentPlayerIndex，让 updateControls 认为还是你的回合
                this.gameUI.updateControls(this.gameUI.lastState);
            }
          }
        }

        // --- 移除: submitBotAction 函数 ---

        // --- 移除: addAiPlayer 函数 ---

        // --- 移除: removePlayer 函数 ---

        // --- 移除: getAiAction 函数 ---

        disableRoomButtons(disabled) {
          document.getElementById("btn-join-room").disabled = disabled;
          document.getElementById("btn-create-room").disabled = disabled;
          if (disabled) {
            document
              .getElementById("btn-join-room")
              .classList.add("btn-disabled");
            document
              .getElementById("btn-create-room")
              .classList.add("btn-disabled");
          } else {
            document
              .getElementById("btn-join-room")
              .classList.remove("btn-disabled");
            document
              .getElementById("btn-create-room")
              .classList.remove("btn-disabled");
          }
        }
      }

      // --- (从单机版复制的辅助类) ---
      class SoundManager {
        constructor() {
          this.ctx = null;
          this.enabled = false;
        }
        init() {
          if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true;

            // *** 修复: 添加一个全局监听器 ***
            // 确保任何点击都可以唤醒被浏览器暂停的音频
            const resumeAudio = () => {
              if (this.ctx && this.ctx.state === "suspended") {
                this.ctx.resume();
              }
            };
            // 同时监听鼠标点击和触摸
            document.addEventListener("click", resumeAudio);
            document.addEventListener("touchstart", resumeAudio);
            // *** 修复结束 ***
          }

          // 保持原有的检查 (用于处理初始加载)
          if (this.ctx.state === "suspended") {
            this.ctx.resume();
          }
        }
        playTone(freq, type, duration, vol = 0.1, when = 0) {
          if (!this.enabled) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime + when);
          gain.gain.setValueAtTime(vol, this.ctx.currentTime + when);
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            this.ctx.currentTime + when + duration
          );
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start(this.ctx.currentTime + when);
          osc.stop(this.ctx.currentTime + when + duration);
        }
        playChip() {
          this.playTone(2000, "square", 0.05, 0.03);
        }
        playCard() {
          this.playTone(800, "sine", 0.1, 0.02);
        }
        playCheck() {
          this.playTone(300, "sine", 0.05, 0.1);
          this.playTone(300, "sine", 0.05, 0.1, 0.1);
        }
        playFold() {
          this.playTone(150, "triangle", 0.3, 0.1);
        }
        playAllIn() {
          if (!this.enabled) return;
          const t = this.ctx.currentTime;
          this.playTone(100, "sawtooth", 0.4, 0.4, 0);
          this.playTone(50, "square", 1.0, 0.5, 0.1);
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(800, t);
          osc.frequency.exponentialRampToValueAtTime(100, t + 0.3);
          gain.gain.setValueAtTime(0.1, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.3);
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start();
          osc.stop(t + 0.3);
        }
        playRaise() {
          this.playTone(1500, "square", 0.08, 0.04);
          this.playTone(1000, "square", 0.08, 0.04, 0.05);
        }

        // --- 恢复的逻辑: 局结束音效 (来自 读博.html) ---
        playHandEnd() {
          this.playTone(440, "sine", 0.2, 0.1);
        }
        // --- 结束 ---

        playWin() {
          [523, 659, 784, 1046].forEach((f, i) =>
            this.playTone(f, "triangle", 0.4, 0.15, i * 0.15)
          );
        }
        playLose() {
          this.playTone(100, "sawtooth", 1.0, 0.2);
          this.playTone(80, "sawtooth", 1.0, 0.2, 0.3);
        }
      }
      class OcclusionManager {
        constructor() {
          this.communityArea = document.getElementById("community-area");
          this.gameMessage = document.getElementById("game-message");
          this.isRunning = false;
          this.checkLoop = null;
        }
        start() {
          if (this.isRunning) return;
          this.isRunning = true;
          this.checkLoop = setInterval(() => this.check(), 100);
        }
        stop() {
          this.isRunning = false;
          clearInterval(this.checkLoop);
        }
        getOverlapRatio(r1, r2) {
          if (!r1 || !r2) return 0;
          const overlapLeft = Math.max(r1.left, r2.left);
          const overlapRight = Math.min(r1.right, r2.right);
          const overlapTop = Math.max(r1.top, r2.top);
          const overlapBottom = Math.min(r1.bottom, r2.bottom);
          if (overlapLeft >= overlapRight || overlapTop >= overlapBottom)
            return 0;
          const overlapArea =
            (overlapRight - overlapLeft) * (overlapBottom - overlapTop);
          const area1 = r1.width * r1.height;
          const area2 = r2.width * r2.height;
          return overlapArea / Math.min(area1, area2);
        }
        check() {
          const seats = document.querySelectorAll(".player-seat");
          if (seats.length === 0) return;
          const cardTargets = [];
          seats.forEach((seat) => {
            const cardsDiv = seat.querySelector('div[id^="cards-"]');
            if (cardsDiv && cardsDiv.children.length > 0)
              cardTargets.push(cardsDiv.getBoundingClientRect());
          });
          const commRect = this.communityArea.getBoundingClientRect();
          if (commRect.width > 10 && commRect.height > 10) {
            let commObstructed = false;
            for (const targetRect of cardTargets) {
              if (this.getOverlapRatio(targetRect, commRect) > 0.2) {
                commObstructed = true;
                break;
              }
            }
            if (!commObstructed) {
              seats.forEach((seat) => {
                const infoBox = seat.querySelector(".player-info-box");
                if (infoBox) {
                  if (
                    this.getOverlapRatio(
                      infoBox.getBoundingClientRect(),
                      commRect
                    ) > 0.2
                  )
                    commObstructed = true;
                }
              });
            }
            this.applyTransparency(this.communityArea, commObstructed);
          } else {
            this.applyTransparency(this.communityArea, false);
          }
          if (this.gameMessage && this.gameMessage.style.opacity !== "0") {
            let msgObstructed = false;
            const msgRect = this.gameMessage.getBoundingClientRect();
            if (commRect.width > 10 && commRect.height > 10) {
              if (this.getOverlapRatio(msgRect, commRect) > 0.2)
                msgObstructed = true;
            }
            if (!msgObstructed) {
              for (const targetRect of cardTargets) {
                if (this.getOverlapRatio(msgRect, targetRect) > 0.2) {
                  msgObstructed = true;
                  break;
                }
              }
            }
            this.applyTransparency(this.gameMessage, msgObstructed);
          }
        }
        applyTransparency(el, shouldBeTransparent) {
          if (shouldBeTransparent) {
            if (!el.classList.contains("smart-transparent"))
              el.classList.add("smart-transparent");
          } else {
            if (el.classList.contains("smart-transparent"))
              el.classList.remove("smart-transparent");
          }
        }
      }
      class TableDragSystem {
        constructor() {
          this.container = document.getElementById("table-area");
          this.table = document.getElementById("table");
          this.isDragging = false;
          this.startY = 0;
          this.currentY = 30;
          this.initialDragY = 0;
          this.init();
        }
        init() {
          this.container.addEventListener("mousedown", this.onStart.bind(this));
          window.addEventListener("mousemove", this.onMove.bind(this));
          window.addEventListener("mouseup", this.onEnd.bind(this));
          this.container.addEventListener(
            "touchstart",
            this.onStart.bind(this),
            { passive: false }
          );
          window.addEventListener("touchmove", this.onMove.bind(this), {
            passive: false,
          });
          window.addEventListener("touchend", this.onEnd.bind(this));
          this.updateTransform();
        }
        onStart(e) {
          if (e.target.closest("button") || e.target.closest("input")) return;
          this.isDragging = true;
          this.startY = this.getY(e);
          this.initialDragY = this.currentY;
          this.table.classList.remove("duration-500");
          this.table.classList.add("duration-0");
          this.container.classList.add("cursor-grabbing");
          this.container.classList.remove("cursor-grab");
        }
        onMove(e) {
          if (!this.isDragging) return;
          e.preventDefault();
          const y = this.getY(e);
          const diff = y - this.startY;
          this.currentY = this.initialDragY + diff;
          if (this.currentY > 180) this.currentY = 180;
          if (this.currentY < -120) this.currentY = -120;
          this.updateTransform();
          if (window.occlusionManager) window.occlusionManager.check();
        }
        onEnd() {
          if (!this.isDragging) return;
          this.isDragging = false;
          this.table.classList.remove("duration-0");
          this.table.classList.add("duration-500");
          this.container.classList.remove("cursor-grabbing");
          this.container.classList.add("cursor-grab");
        }
        getY(e) {
          return e.touches ? e.touches[0].clientY : e.clientY;
        }
        updateTransform() {
          this.table.style.transform = `translateY(${this.currentY}px)`;
        }
      }

      // *** 修复: 替换整个 HandEvaluator 类 ***
      class HandEvaluator {
        static evaluate(holeCards, communityCards) {
          if (!holeCards || holeCards.length === 0)
            return { score: 0, name: "无", bestCards: [] };

          // *** 修正: 标记手牌并优先排序 ***
          // 1. 合并所有牌，并标记来源 (isHole)
          const all = [
            ...holeCards.map((c) => ({ ...c, isHole: true })),
            ...communityCards.map((c) => ({ ...c, isHole: false })),
          ];

          // 2. 排序: 优先按点数，点数相同，手牌(true=1)优先于公共牌(false=0)
          all.sort((a, b) => {
            if (b.value !== a.value) return b.value - a.value;
            return b.isHole - a.isHole;
          });
          // *** 结束修正 ***

          // getKickers 会自动从排好序的 'all' 数组中取牌
          const getKickers = (excludeCards, count) => {
            const kickers = [];
            const excludeIds = new Set(excludeCards.map((c) => c.id));
            for (const c of all) {
              // 'all' 已经排好序
              if (!excludeIds.has(c.id)) {
                kickers.push(c);
                if (kickers.length === count) break;
              }
            }
            return kickers;
          };

          // calcScore 仅用于计算分数，不影响 'bestCards'
          const calcScore = (rankVal, mainCards, kickers) => {
            let s = rankVal * Math.pow(100, 5);
            mainCards.forEach((c, i) => {
              s += c.value * Math.pow(100, 4 - i);
            });
            kickers.forEach((c, i) => {
              s += c.value * Math.pow(100, 4 - mainCards.length - i);
            });
            return s;
          };

          // 寻找同花 (flushCards 也会保持 'all' 的排序)
          const suits = {};
          all.forEach((c) => {
            if (!suits[c.suit]) suits[c.suit] = [];
            suits[c.suit].push(c);
          });
          let flushCards = null;
          for (let s in suits) {
            if (suits[s].length >= 5) {
              flushCards = suits[s].slice(0, 5); // .slice(0,5) 保留了排序
              break;
            }
          }

          // 寻找顺子 (cardsToCheck 也会保持 'all' 的排序)
          const getStraightCards = (cardsToCheck) => {
            // .map 再 new Set 会丢失 isHole 排序, 但没关系
            const uniqueVals = [
              ...new Set(cardsToCheck.map((c) => c.value)),
            ].sort((a, b) => b - a);

            // A-5 顺子 (特殊处理)
            if (
              uniqueVals.includes(14) &&
              uniqueVals.includes(5) &&
              uniqueVals.includes(4) &&
              uniqueVals.includes(3) &&
              uniqueVals.includes(2)
            ) {
              const straightVals = [5, 4, 3, 2, 14];
              const best5 = [];
              const usedIds = new Set();
              straightVals.forEach((v) => {
                // .find() 会找到 'cardsToCheck' (已排序) 中的第一张
                const card = cardsToCheck.find(
                  (c) => c.value === v && !usedIds.has(c.id)
                );
                if (card) {
                  // 确保卡片被找到
                  best5.push(card);
                  
                  // *** 修复 1: 这里原来是 c.id，必须改为 card.id ***
                  usedIds.add(card.id); 
                  // *** 修复结束 ***
                }
              });
              // 必须确保找到了5张牌
              if (best5.length === 5) return { cards: best5, high: 5 };
            }

            // K-Q-J-10-9 普通顺子
            for (let i = 0; i <= uniqueVals.length - 5; i++) {
              if (uniqueVals[i] - uniqueVals[i + 4] === 4) {
                const straightVals = uniqueVals.slice(i, i + 5);
                const best5 = [];
                const usedIds = new Set();
                straightVals.forEach((v) => {
                  // .find() 会找到 'cardsToCheck' (已排序) 中的第一张
                  const card = cardsToCheck.find(
                    (c) => c.value === v && !usedIds.has(c.id)
                  );
                  if (card) {
                    // 确保卡片被找到
                    best5.push(card);
                    
                    // *** 修复 2: 这里原来是 c.id，必须改为 card.id ***
                    usedIds.add(card.id);
                    // *** 修复结束 ***
                  }
                });
                // 必须确保找到了5张牌
                if (best5.length === 5)
                  return { cards: best5, high: uniqueVals[i] };
              }
            }
            return null;
          };

          // 1. 同花顺
          if (flushCards) {
            const sf = getStraightCards(flushCards); // flushCards 保持了 'isHole' 排序
            if (sf)
              return {
                score: calcScore(9, [sf.cards[0]], []),
                name: "同花顺",
                bestCards: sf.cards,
              };
          }

          // 2. 四条
          const counts = {};
          all.forEach((c) => (counts[c.value] = (counts[c.value] || 0) + 1));
          const fours = Object.keys(counts)
            .filter((v) => counts[v] === 4)
            .map(Number)
            .sort((a, b) => b - a);
          const threes = Object.keys(counts)
            .filter((v) => counts[v] === 3)
            .map(Number)
            .sort((a, b) => b - a);
          const pairs = Object.keys(counts)
            .filter((v) => counts[v] === 2)
            .map(Number)
            .sort((a, b) => b - a);
          if (fours.length > 0) {
            const fourVal = fours[0];
            const quadCards = all.filter((c) => c.value === fourVal); // .filter() 保持了 'isHole' 排序
            const kicker = getKickers(quadCards, 1); // getKickers 保持了 'isHole' 排序
            return {
              score: calcScore(8, [quadCards[0]], kicker),
              name: "四条",
              bestCards: [...quadCards, ...kicker],
            };
          }

          // 3. 葫芦
          if (threes.length > 0 && (threes.length > 1 || pairs.length > 0)) {
            const threeVal = threes[0];
            const pairVal = threes.length > 1 ? threes[1] : pairs[0];
            const threeCards = all
              .filter((c) => c.value === threeVal)
              .slice(0, 3); // .filter().slice() 保持了 'isHole' 排序
            const pairCards = all
              .filter((c) => c.value === pairVal)
              .slice(0, 2); // .filter().slice() 保持了 'isHole' 排序
            return {
              score: calcScore(7, [threeCards[0], pairCards[0]], []),
              name: "葫芦",
              bestCards: [...threeCards, ...pairCards],
            };
          }

          // 4. 同花
          if (flushCards) {
            return {
              score: calcScore(6, flushCards, []),
              name: "同花",
              bestCards: flushCards,
            }; // flushCards 保持了 'isHole' 排序
          }

          // 5. 顺子
          const straight = getStraightCards(all); // 'all' 保持了 'isHole' 排序
          if (straight) {
            return {
              score: calcScore(5, [straight.cards[0]], []),
              name: "顺子",
              bestCards: straight.cards,
            };
          }

          // 6. 三条
          if (threes.length > 0) {
            const threeVal = threes[0];
            const threeCards = all
              .filter((c) => c.value === threeVal)
              .slice(0, 3); // .filter().slice() 保持了 'isHole' 排序
            const kickers = getKickers(threeCards, 2); // getKickers 保持了 'isHole' 排序
            return {
              score: calcScore(4, [threeCards[0]], kickers),
              name: "三条",
              bestCards: [...threeCards, ...kickers],
            };
          }

          // 7. 两对
          if (pairs.length >= 2) {
            const p1 = pairs[0];
            const p2 = pairs[1];
            const pair1Cards = all.filter((c) => c.value === p1).slice(0, 2); // .filter().slice() 保持了 'isHole' 排序
            const pair2Cards = all.filter((c) => c.value === p2).slice(0, 2); // .filter().slice() 保持了 'isHole' 排序
            const kicker = getKickers([...pair1Cards, ...pair2Cards], 1); // getKickers 保持了 'isHole' 排序
            return {
              score: calcScore(3, [pair1Cards[0], pair2Cards[0]], kicker),
              name: "两对",
              bestCards: [...pair1Cards, ...pair2Cards, ...kicker],
            };
          }

          // 8. 一对
          if (pairs.length === 1) {
            const p1 = pairs[0];
            const pairCards = all.filter((c) => c.value === p1).slice(0, 2); // .filter().slice() 保持了 'isHole' 排序
            const kickers = getKickers(pairCards, 3); // getKickers 保持了 'isHole' 排序
            return {
              score: calcScore(2, [pairCards[0]], kickers),
              name: "一对",
              bestCards: [...pairCards, ...kickers],
            };
          }

          // 9. 高牌
          const highCards = all.slice(0, 5); // .slice() 保持了 'isHole' 排序
          return {
            score: calcScore(1, highCards, []),
            name: "高牌",
            bestCards: highCards,
          };
        }
      }

      // --- 游戏启动 ---

      // 将关键实例暴露给 window，以便 HTML onclick 事件可以调用
      const gameUI = new GameUIManager();
      const network = new NetworkManager(gameUI);

      window.network = network; // 暴露 network.createRoom, .joinRoom 等
      window.gameUI = gameUI; // 暴露 gameUI.adjustRaise

      // 启动 Firebase
      network.init();

      // 移除旧的单机版逻辑
      // (旧的 game = new PokerGame() 和 restartGame() 已被 network.leaveRoom 替代)
    </script>

    <!-- 移除旧的 <script> ... </script> 块 -->
  </body>
</html>
