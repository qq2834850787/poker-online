<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Texas Hold'em</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♠️</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Supabase JS SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Black+Ops+One&family=Noto+Sans+JP:wght@500;700&family=Noto+Sans+SC:wght@500;700&display=swap");

        body {
            font-family: "Inter", "Noto Sans JP", "Noto Sans SC", "Microsoft YaHei", sans-serif;
            background-color: #111827;
            color: white;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            height: 100dvh;
            width: 100vw;
        }

        /* --- Card Styles --- */
        .card {
            width: 42px;
            height: 60px;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            position: relative;
            transition: transform 0.3s, box-shadow 0.3s;
            z-index: 10;
            border: 1px solid #e5e7eb;
        }

        @media (min-width: 768px) {
            .card {
                width: 56px;
                height: 78px;
                font-size: 20px;
                border-radius: 6px;
            }
        }

        .card.red {
            color: #dc2626;
        }

        .card.black {
            color: #1f2937;
        }

        .card-back {
            background: repeating-linear-gradient(45deg,
                    #1e3a8a,
                    #1e3a8a 10px,
                    #172554 10px,
                    #172554 20px);
            border: 2px solid #e2e8f0;
        }

        .card-back span {
            display: none;
        }

        .card-placeholder {
            width: 42px;
            height: 60px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border: none;
            background: transparent;
        }

        .card-placeholder:empty {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            background-color: rgba(0, 0, 0, 0.2);
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            .card-placeholder {
                width: 56px;
                height: 78px;
                border-radius: 6px;
            }
        }

        .card.winning-card {
            box-shadow: 0 0 15px 5px rgba(251, 191, 36, 0.9);
            border: 3px solid #fbbf24;
            z-index: 100;
        }

        /* --- Table --- */
        .poker-table {
            background: radial-gradient(circle, #15803d 0%, #064e3b 90%, #022c22 100%);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.9), 0 0 0 12px #374151, 0 0 0 16px #1f2937;
            position: relative;
            border-radius: 180px;
            transform: translateY(0px);
            will-change: transform;
        }

        @media (min-width: 768px) {
            .poker-table {
                transform: translateY(30px);
            }
        }

        .cursor-grab {
            cursor: grab;
        }

        .cursor-grabbing {
            cursor: grabbing;
        }

        .player-seat {
            position: absolute;
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.6s, top 0.6s;
            width: 120px;
            height: 110px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transform-origin: center center;
            pointer-events: none;
        }

        .player-seat>* {
            pointer-events: auto;
        }

        .player-info-box {
            background: linear-gradient(180deg, rgba(31, 41, 55, 0.95) 0%, rgba(17, 24, 39, 0.98) 100%);
            border: 1px solid #4b5563;
            border-radius: 6px;
            padding: 4px 2px;
            width: 100%;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            position: relative;
        }

        .dealer-btn {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, #fff, #cbd5e0);
            color: #1a202c;
            border-radius: 50%;
            font-size: 12px;
            font-weight: 900;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: -8px;
            right: -6px;
            border: 1px solid #9ca3af;
            z-index: 30;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
        }

        .active-player .player-info-box {
            box-shadow: 0 0 0 2px #fbbf24, 0 0 20px rgba(251, 191, 36, 0.4);
            border-color: #f59e0b;
            background: linear-gradient(180deg, #374151 0%, #1f2937 100%);
            transform: translateY(-2px);
            z-index: 40;
        }

        .winner-highlight .player-info-box {
            box-shadow: 0 0 0 3px #22c55e, 0 0 30px rgba(34, 197, 94, 0.6);
            border-color: #22c55e;
            background: linear-gradient(180deg, #064e3b 0%, #065f46 100%);
            z-index: 50;
        }

        /* --- All-in VFX --- */
        .all-in-fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.2s ease-out;
        }

        .all-in-bar {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 140px;
            background: rgba(0, 0, 0, 0.95);
            transform: translateY(-50%) translateX(-100%);
            animation: barSlideIn 0.4s cubic-bezier(0.05, 0.7, 0.1, 1) forwards;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border-top: 2px solid rgba(234, 179, 8, 0.6);
            border-bottom: 2px solid rgba(234, 179, 8, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        @keyframes barSlideIn {
            from {
                transform: translateY(-50%) translateX(-100%);
            }

            to {
                transform: translateY(-50%) translateX(0%);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .all-in-text {
            position: relative;
            font-family: "Black Ops One", system-ui, sans-serif;
            font-size: 90px;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 4px;
            background: linear-gradient(to bottom, #fef08a 0%, #eab308 45%, #a16207 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 5px 3px rgba(0, 0, 0, 0.5));
            text-shadow: 0 0 30px rgba(234, 179, 8, 0.6);
            opacity: 0;
            transform: scale(2);
            animation: textImpact 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards 0.2s;
        }

        @keyframes textImpact {
            0% {
                opacity: 0;
                transform: scale(2);
                filter: blur(10px);
            }

            100% {
                opacity: 1;
                transform: scale(1);
                filter: blur(0px);
            }
        }

        .all-in-bar::after {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 30%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.4), transparent);
            transform: skewX(-25deg);
            animation: shine 1s infinite 0.5s;
        }

        @keyframes shine {
            0% {
                left: -50%;
            }

            100% {
                left: 150%;
            }
        }

        input[type="range"]::-webkit-slider-thumb {
            background: #fbbf24;
        }

        .adjust-btn:active {
            transform: scale(0.95);
            background-color: #4b5563;
        }

        .smart-transparent {
            opacity: 0.15 !important;
            transition: opacity 0.2s ease-out;
            pointer-events: none;
        }

        /* --- Loader & Screens --- */
        .loader-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111827;
            z-index: 10000;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #4b5563;
            border-top-color: #f59e0b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #room-screen {
            z-index: 50;
            background: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(10px);
        }

        .btn-disabled {
            background-color: #4b5563 !important;
            border-color: #374151 !important;
            color: #9ca3af !important;
            cursor: not-allowed !important;
            transform: none !important;
        }

        #bottom-bar {
            padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
        }
    </style>
</head>

<body class="h-[100dvh] w-screen flex flex-col items-center justify-center bg-gray-950">
    <div id="loader-screen" class="loader-screen">
        <div class="spinner"></div>
        <p class="text-gray-400 mt-4 text-sm font-medium" data-i18n="connecting">Connecting to Supabase...</p>
    </div>

    <!-- Room Selection Screen -->
    <div id="room-screen"
        class="hidden absolute z-50 bg-gray-900 p-8 rounded-xl shadow-2xl border border-gray-700 w-11/12 max-w-md">
        <!-- Language Selector -->
        <div class="absolute top-2 right-2">
            <select id="language-selector" onchange="updateLanguage(this.value)"
                class="bg-gray-800 text-gray-300 text-xs rounded px-2 py-1 border border-gray-600 focus:outline-none focus:border-yellow-500">
                <option value="en" selected>English</option>
                <option value="ja">日本語</option>
                <option value="zh">中文</option>
            </select>
        </div>

        <h1 class="text-3xl font-bold text-yellow-500 mb-6 tracking-tight text-center" data-i18n="gameTitle">
            Texas Hold'em
        </h1>

        <div class="mb-4">
            <label class="block text-gray-400 mb-2 text-sm font-bold" for="player-name-input"
                data-i18n="nicknameLabel">Your
                Nickname</label>
            <input type="text" id="player-name-input"
                class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
                placeholder="" />
        </div>
        <div class="mb-6">
            <label class="block text-gray-400 mb-2 text-sm font-bold" for="room-id-input" data-i18n="roomIdLabel">Room
                ID</label>
            <input type="text" id="room-id-input"
                class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
                placeholder="" />
        </div>
        <div class="flex space-x-4 mb-4">
            <button onclick="network.joinRoom()" id="btn-join-room" data-i18n="joinRoomBtn"
                class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">
                Join Room
            </button>
            <button onclick="network.createRoom()" id="btn-create-room" data-i18n="createRoomBtn"
                class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1">
                Create Room
            </button>
        </div>
        <p id="room-error" class="text-red-400 text-sm h-5 text-center"></p>

        <div class="mt-6 border-t border-gray-700 pt-4 w-full">
            <div class="flex justify-between items-center mb-2">
                <h2 class="text-yellow-500 font-bold text-sm" data-i18n="roomListTitle">Open Rooms</h2>
                <button onclick="network.fetchRoomList()"
                    class="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded text-white flex items-center gap-1">
                    <span data-i18n="refreshBtn">Refresh</span> ↻
                </button>
            </div>
            <div id="room-list" class="h-40 overflow-y-auto bg-gray-800 rounded border border-gray-700 p-2 space-y-2">
                <p class="text-gray-500 text-xs text-center mt-4" data-i18n="clickToLoad">Click Refresh to load rooms...
                </p>
            </div>
        </div>

        <p class="text-gray-500 text-xs mt-4 text-center">
            User ID: <span id="user-id-display">...</span>
        </p>
    </div>

    <!-- Game Area -->
    <div id="game-area" class="hidden w-full h-full relative flex flex-col">
        <div id="top-bar"
            class="h-16 bg-gray-900 w-full flex items-center justify-between px-6 shadow-lg z-10 border-b border-gray-800 relative z-50">
            <div class="flex items-center space-x-2">
                <div class="text-yellow-500 font-black text-2xl tracking-tight">
                    <span data-i18n="pot">Pot</span>: $<span id="pot-display">0</span>
                </div>
            </div>

            <div class="flex items-center space-x-4">
                <div class="flex flex-col items-center mr-1 bg-gray-800 px-2 py-1 rounded border border-gray-700">
                    <span class="text-gray-500 text-[10px] font-bold leading-none mb-1" data-i18n="room">Room</span>
                    <span id="display-room-id"
                        class="text-yellow-500 font-mono font-bold text-sm leading-none">---</span>
                </div>
                <div class="text-right hidden sm:block">
                    <div id="blinds-display" class="text-gray-400 text-xs font-bold tracking-wider">
                        Blinds $10/$20
                    </div>
                    <div class="text-gray-600 text-[10px]">
                        <span data-i18n="online">Online</span>: <span id="active-players-count">0</span>
                    </div>
                </div>

                <button id="btn-leave-room" onclick="network.leaveRoom()" data-i18n="leaveRoomBtn"
                    class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-2 px-4 rounded-lg text-xs shadow-md">
                    Leave
                </button>
            </div>
        </div>

        <div id="table-area"
            class="flex-grow relative overflow-hidden flex items-center justify-center bg-gray-950 cursor-grab active:cursor-grabbing">
            <div id="table"
                class="poker-table w-[95vw] h-[55vh] md:w-[800px] md:h-[450px] max-w-full relative transition-all duration-500">
                <div id="community-area"
                    class="absolute top-[42%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 flex flex-col items-center z-20 transition-opacity duration-200">
                    <div id="community-cards"
                        class="flex flex-wrap justify-center items-center gap-1 sm:gap-2 max-w-[150px] md:max-w-none transition-all duration-300">
                        <div id="comm-slot-0" class="card-placeholder"></div>
                        <div id="comm-slot-1" class="card-placeholder"></div>
                        <div id="comm-slot-2" class="card-placeholder"></div>
                        <div id="comm-slot-3" class="card-placeholder"></div>
                        <div id="comm-slot-4" class="card-placeholder"></div>
                    </div>
                </div>
                <div id="game-message"
                    class="absolute top-[23%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-yellow-100 font-bold text-xl text-center z-30 pointer-events-none drop-shadow-lg px-4 py-2 rounded whitespace-nowrap transition-opacity duration-300 opacity-0">
                </div>
                <div id="seats-container" class="w-full h-full relative"></div>
            </div>
        </div>

        <div id="bottom-bar"
            class="bg-gray-900 p-4 shadow-[0_-5px_15px_rgba(0,0,0,0.5)] z-20 border-t border-gray-800 relative z-50">
            <div id="game-log"
                class="h-16 overflow-y-auto text-xs text-gray-500 mb-3 font-mono bg-gray-950 p-2 rounded border border-gray-800 scroll-smooth leading-5">
                <div data-i18n="log_welcome">System: Welcome to Texas Hold'em.</div>
            </div>
            <div id="player-controls"
                class="flex flex-col items-center opacity-50 pointer-events-none transition-all duration-300 transform translate-y-2">
                <div id="raise-slider-container" class="w-full max-w-md mb-4 flex items-center space-x-2 px-2">
                    <span class="text-xs text-gray-500 font-bold tracking-wider w-8 text-center"
                        data-i18n="raiseLabel">Bet</span>
                    <button onclick="gameUI.adjustRaise(-1)"
                        class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700">
                        -
                    </button>
                    <input type="range" id="raise-slider" step="1"
                        class="flex-grow h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mx-2" />
                    <button onclick="gameUI.adjustRaise(1)"
                        class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700">
                        +
                    </button>
                    <span id="raise-val-display"
                        class="text-sm text-yellow-400 w-14 text-right font-mono font-bold">$0</span>
                </div>
                <div class="flex justify-center space-x-3 w-full max-w-lg">
                    <button onclick="network.handleHumanAction('fold')" data-i18n="foldBtn"
                        class="flex-1 bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
                        Fold
                    </button>
                    <button onclick="network.handleHumanAction('check')" id="btn-check" data-i18n="checkBtn"
                        class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1">
                        Check
                    </button>
                    <button onclick="network.handleHumanAction('call')" id="btn-call" data-i18n="callBtn"
                        class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1 hidden">
                        Call
                    </button>
                    <button onclick="network.handleHumanAction('raise')" id="btn-raise" data-i18n="raiseBtn"
                        class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1">
                        Raise
                    </button>
                </div>
            </div>
            <div class="text-center mt-2 text-gray-700 text-[10px] font-mono tracking-wider">
                <span data-i18n="phaseLabel">Phase</span>: <span id="phase-display" class="text-gray-500"
                    data-i18n="waiting">Waiting</span>
            </div>
        </div>

        <div id="waiting-room-overlay"
            class="hidden absolute top-0 left-0 w-full h-full z-40 flex flex-col items-center justify-center pointer-events-none">
            <div id="wait-host-controls"
                class="hidden pointer-events-auto flex flex-col items-center gap-4 transition-transform duration-300 mb-28">

                <div id="host-settings-panel"
                    class="bg-gray-800/80 p-4 rounded-lg border border-gray-600 w-72 backdrop-blur-sm shadow-lg">

                    <div class="mb-3">
                        <div class="flex justify-between items-center mb-1">
                            <label class="block text-yellow-500 text-xs font-bold" data-i18n="initialChips">Initial
                                Chips</label>
                            <span id="error-chips-inline"
                                class="text-red-500 text-[10px] font-bold animate-pulse"></span>
                        </div>
                        <input type="number" id="setting-initial-chips" value="2000" step="100"
                            class="w-full bg-gray-900 text-white border border-gray-600 rounded px-2 py-1 text-sm focus:border-yellow-500 outline-none font-mono">
                    </div>

                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label class="block text-yellow-500 text-xs font-bold" data-i18n="bigBlind">Big
                                Blind</label>
                            <span id="error-blind-inline"
                                class="text-red-500 text-[10px] font-bold animate-pulse"></span>
                        </div>
                        <input type="number" id="setting-big-blind" value="20" step="2" min="2"
                            class="w-full bg-gray-900 text-white border border-gray-600 rounded px-2 py-1 text-sm focus:border-yellow-500 outline-none font-mono">
                        <p class="text-gray-400 text-[10px] mt-1 text-right"><span data-i18n="smallBlindAuto">SB
                                Auto</span>: <span id="setting-sb-display" class="text-white font-bold">10</span></p>
                    </div>
                </div>

                <div id="host-start-btn-container"></div>
            </div>

            <p id="wait-message"
                class="mt-8 text-yellow-400 font-bold text-xl drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)] pointer-events-auto bg-black/40 px-6 py-2 rounded-lg backdrop-blur-sm border border-white/10"
                data-i18n="waitForHost">
                Waiting for host to start...
            </p>
        </div>
    </div>

    <script>
        // --- I18N SYSTEM (ENHANCED) ---
        const TRANSLATIONS = {
            en: {
                connecting: "Connecting to server...",
                gameTitle: "Texas Hold'em",
                nicknameLabel: "Your Nickname",
                roomIdLabel: "Room ID",
                joinRoomBtn: "Join Room",
                createRoomBtn: "Create Room",
                pot: "Pot",
                room: "Room",
                online: "Players",
                leaveRoomBtn: "Leave",
                raiseLabel: "Bet",
                foldBtn: "Fold",
                checkBtn: "Check",
                callBtn: "Call",
                raiseBtn: "Raise",
                allInBtn: "All-in",
                phaseLabel: "Phase",
                waiting: "Waiting",
                initialChips: "Initial Chips",
                bigBlind: "Big Blind",
                smallBlindAuto: "SB Auto",
                waitForHost: "Waiting for host...",
                startGameBtn: "Start Game",
                waitPlayerBtn: "Waiting Players",
                error_blind_min: "Min 2",
                error_blind_even: "Even # only",
                error_chips_too_low: "Must be > BB",
                // Status & Phase
                status_fold: "Fold",
                status_check: "Check",
                status_call: "Call",
                status_raise: "Raise",
                status_all_in: "All-in",
                status_small_blind: "Small Blind",
                status_big_blind: "Big Blind",
                status_eliminated: "Eliminated",
                status_won: "Won",
                phase_preflop: "Preflop",
                phase_flop: "Flop",
                phase_turn: "Turn",
                phase_river: "River",
                phase_showdown: "Showdown",
                // Hands
                hand_high_card: "High Card",
                hand_pair: "Pair",
                hand_two_pairs: "Two Pairs",
                hand_three_of_a_kind: "Three of a Kind",
                hand_straight: "Straight",
                hand_flush: "Flush",
                hand_full_house: "Full House",
                hand_four_of_a_kind: "Four of a Kind",
                hand_straight_flush: "Straight Flush",
                // Messages
                msg_your_turn: "Your Turn",
                msg_thinking: " Thinking",
                msg_winner: "Winner!",
                msg_bankruptcy: "You are bankrupt. Spectating.",
                msg_game_reset: "Game resetting...",
                error_nickname: "Nickname 2-10 chars",
                error_room_id: "Room ID required",
                error_room_dead: "Room expired/dead",
                error_room_full: "Room full",
                error_game_started: "Game already started",
                error_join_fail: "Join Failed",
                bet_prefix: "Bet",
                call_prefix: "Call",
                // Dynamic Logs
                log_welcome: "System: Welcome to Texas Hold'em.",
                log_join: "{name} joined.",
                log_leave: "{name} left.",
                log_create: "{name} created room.",
                log_fold: "{name} Folded",
                log_check: "{name} Checked",
                log_call: "{name} Called ${amount}",
                log_raise: "{name} Raised to ${amount}",
                log_all_in: "{name} All-in ${amount}",
                log_phase_flop: "--- Flop ---",
                log_phase_turn: "--- Turn ---",
                log_phase_river: "--- River ---",
                log_refund: "Refunding ${amount} to {name}",
                log_win_sole: "--- {name} Wins ${amount} ---",
                log_round_end_no_winner: "--- Round End (No Winner?) ---",
                log_showdown_result: "{potName}(${amount}): {winners} Wins",
                log_game_over: "--- Game Over! {name} Wins! ---",
                log_auto_all_in: "--- Auto All-in (Blinds) ---",
                log_new_round: "--- New Round ---",
                log_host_change: "Host is now {name}.",
                main_pot: "Main Pot",
                side_pot: "Side Pot",
                roomListTitle: "Open Rooms",
                refreshBtn: "Refresh",
                clickToLoad: "Click Refresh to load rooms...",
                loadingList: "Loading...",
                noRooms: "No rooms found.",
                noActiveRooms: "No active rooms.",
                errorLoad: "Error loading list.",
                hostLabel: "Host",
                status_playing_list: "Playing",
                status_waiting_list: "Waiting",
                spectatorModeMsg: "Game in progress. Spectator Mode."
            },
            ja: {
                connecting: "サーバーに接続中...",
                gameTitle: "テキサスホールデム",
                nicknameLabel: "ニックネーム",
                roomIdLabel: "ルームID",
                joinRoomBtn: "参加する",
                createRoomBtn: "作成する",
                pot: "ポット",
                room: "部屋",
                online: "人数",
                leaveRoomBtn: "退出",
                raiseLabel: "額",
                foldBtn: "降りる",
                checkBtn: "チェック",
                callBtn: "コール",
                raiseBtn: "レイズ",
                allInBtn: "オールイン",
                phaseLabel: "フェーズ",
                waiting: "待機中",
                initialChips: "初期チップ",
                bigBlind: "ビッグブラインド",
                smallBlindAuto: "SB自動",
                waitForHost: "ホストの開始待ち...",
                startGameBtn: "ゲーム開始",
                waitPlayerBtn: "参加者待ち",
                status_fold: "フォールド",
                status_check: "チェック",
                status_call: "コール",
                status_raise: "レイズ",
                status_all_in: "オールイン",
                status_small_blind: "SB",
                status_big_blind: "BB",
                status_eliminated: "敗退",
                status_won: "勝利",
                phase_preflop: "プリフロップ",
                phase_flop: "フロップ",
                phase_turn: "ターン",
                phase_river: "リバー",
                phase_showdown: "ショーダウン",
                hand_high_card: "ハイカード",
                hand_pair: "ワンペア",
                hand_two_pairs: "ツーペア",
                hand_three_of_a_kind: "スリーカード",
                hand_straight: "ストレート",
                hand_flush: "フラッシュ",
                hand_full_house: "フルハウス",
                hand_four_of_a_kind: "フォーカード",
                hand_straight_flush: "ストレートフラッシュ",
                msg_your_turn: "あなたの番です",
                msg_thinking: " 思考中...",
                msg_winner: "優勝！",
                msg_bankruptcy: "破産しました。観戦モードへ。",
                msg_game_reset: "リセット中...",
                error_nickname: "名前は2〜10文字",
                error_room_id: "IDを入力してください",
                error_room_dead: "部屋が無効です",
                error_room_full: "満員です",
                error_game_started: "ゲーム進行中",
                error_join_fail: "参加失敗",
                bet_prefix: "ベット",
                call_prefix: "コール",
                error_blind_min: "最小2",
                error_blind_even: "偶数のみ",
                error_chips_too_low: "BBより大きく",
                // Dynamic Logs
                log_welcome: "システム: テキサスホールデムへようこそ。",
                log_join: "{name} が参加しました。",
                log_leave: "{name} が退出しました。",
                log_create: "{name} が部屋を作成しました。",
                log_fold: "{name} 降りる",
                log_check: "{name} チェック",
                log_call: "{name} コール ${amount}",
                log_raise: "{name} レイズ ${amount}",
                log_all_in: "{name} オールイン ${amount}",
                log_phase_flop: "--- フロップ ---",
                log_phase_turn: "--- ターン ---",
                log_phase_river: "--- リバー ---",
                log_refund: "{name}に ${amount} を返却",
                log_win_sole: "--- {name} が ${amount} を獲得 ---",
                log_round_end_no_winner: "--- 勝者なし？終了 ---",
                log_showdown_result: "{potName}(${amount}): {winners} 勝利",
                log_game_over: "--- ゲーム終了! 優勝は {name}! ---",
                log_auto_all_in: "--- 自動オールイン ---",
                log_new_round: "--- 新しいラウンド ---",
                log_host_change: "ホストが {name} になりました。",
                main_pot: "メインポット",
                side_pot: "サイドポット",
                roomListTitle: "公開ルーム列表",
                refreshBtn: "更新",
                clickToLoad: "更新ボタンを押して読み込み...",
                loadingList: "読み込み中...",
                noRooms: "ルームが見つかりません。",
                noActiveRooms: "有効なルームがありません。",
                errorLoad: "読み込みエラー。",
                hostLabel: "ホスト",
                status_playing_list: "進行中",
                status_waiting_list: "待機中",
                spectatorModeMsg: "ゲーム進行中。観戦モードです。"
            },
            zh: {
                connecting: "连接服务器中...",
                gameTitle: "德州扑克",
                nicknameLabel: "你的昵称",
                roomIdLabel: "房间 ID",
                joinRoomBtn: "加入房间",
                createRoomBtn: "创建房间",
                pot: "底池",
                room: "房间",
                online: "在线",
                leaveRoomBtn: "退出",
                raiseLabel: "加注",
                foldBtn: "弃牌",
                checkBtn: "过牌",
                callBtn: "跟注",
                raiseBtn: "加注",
                allInBtn: "全押",
                phaseLabel: "阶段",
                waiting: "等待中",
                initialChips: "初始筹码",
                bigBlind: "大盲注",
                smallBlindAuto: "小盲自动",
                waitForHost: "等待房主开始...",
                startGameBtn: "开始游戏",
                waitPlayerBtn: "等待玩家",
                status_fold: "弃牌",
                status_check: "过牌",
                status_call: "跟注",
                status_raise: "加注",
                status_all_in: "全押",
                status_small_blind: "小盲",
                status_big_blind: "大盲",
                status_eliminated: "淘汰",
                status_won: "获胜",
                phase_preflop: "翻牌前",
                phase_flop: "翻牌",
                phase_turn: "转牌",
                phase_river: "河牌",
                phase_showdown: "摊牌",
                hand_high_card: "高牌",
                hand_pair: "一对",
                hand_two_pairs: "两对",
                hand_three_of_a_kind: "三条",
                hand_straight: "顺子",
                hand_flush: "同花",
                hand_full_house: "葫芦",
                hand_four_of_a_kind: "四条",
                hand_straight_flush: "同花顺",
                msg_your_turn: "你的回合",
                msg_thinking: " 思考中",
                msg_winner: "你是冠军！",
                msg_bankruptcy: "你已破产，进入观战模式",
                msg_game_reset: "游戏即将重置...",
                error_nickname: "昵称必须2-10字符",
                error_room_id: "请输入房间ID",
                error_room_dead: "房间已失效",
                error_room_full: "房间已满",
                error_game_started: "游戏已开始",
                error_join_fail: "加入失败",
                bet_prefix: "下注",
                call_prefix: "跟注",
                error_blind_min: "最小为2",
                error_blind_even: "必须为偶数",
                error_chips_too_low: "须大于大盲",
                // Dynamic Logs
                log_welcome: "系统: 欢迎游玩德州扑克。",
                log_join: "{name} 加入了房间。",
                log_leave: "{name} 离开了房间。",
                log_create: "{name} 创建了房间。",
                log_fold: "{name} 弃牌",
                log_check: "{name} 过牌",
                log_call: "{name} 跟注 ${amount}",
                log_raise: "{name} 加注至 ${amount}",
                log_all_in: "{name} 全押 ${amount}",
                log_phase_flop: "--- 翻牌 ---",
                log_phase_turn: "--- 转牌 ---",
                log_phase_river: "--- 河牌 ---",
                log_refund: "退还 ${amount} 给 {name}",
                log_win_sole: "--- {name} 获胜, 赢得 ${amount} ---",
                log_round_end_no_winner: "--- 无人获胜？回合结束 ---",
                log_showdown_result: "{potName}(${amount}): {winners} 获胜",
                log_game_over: "--- 游戏结束! {name} 获胜! ---",
                log_auto_all_in: "--- 盲注导致全押 ---",
                log_new_round: "--- 新回合开始 ---",
                log_host_change: "房主移交给 {name}。",
                main_pot: "主池",
                side_pot: "边池",
                roomListTitle: "房间列表",
                refreshBtn: "刷新",
                clickToLoad: "点击刷新加载房间...",
                loadingList: "加载中...",
                noRooms: "未找到房间。",
                noActiveRooms: "当前无活跃房间。",
                errorLoad: "加载失败。",
                hostLabel: "房主",
                status_playing_list: "游戏中",
                status_waiting_list: "等待中",
                spectatorModeMsg: "游戏进行中，进入观战模式。"
            }
        };

        let currentLang = "en";

        // Enhanced t() to support argument replacement
        const t = (key, args = {}) => {
            let text = TRANSLATIONS[currentLang][key] || key;
            Object.keys(args).forEach(argKey => {
                text = text.replace(`{${argKey}}`, args[argKey]);
            });
            return text;
        };

        // Helper to create structured log objects (saved as JSON string)
        const createLog = (key, args = {}) => {
            return JSON.stringify({ key, args });
        };

        window.updateLanguage = (lang) => {
            currentLang = lang;
            document.documentElement.lang = lang;
            document.querySelectorAll("[data-i18n]").forEach(el => {
                const key = el.getAttribute("data-i18n");
                el.innerText = t(key);
            });
            if (gameUI && gameUI.lastState) {
                gameUI.renderGameState(gameUI.lastState, network.localUserId);
            }
            if (network) {
                network.renderRoomList();
            }
        };

        // --- CONSTANTS & UTILS ---
        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
        const SUITS = ["♠", "♥", "♣", "♦"];
        const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
        const RANK_VALUES = { 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, J: 11, Q: 12, K: 13, A: 14 };

        const PHASE_KEY_MAP = {
            waiting: "waiting",
            preflop: "phase_preflop",
            flop: "phase_flop",
            turn: "phase_turn",
            river: "phase_river",
            showdown: "phase_showdown",
        };

        // --- SUPABASE GLOBALS ---
        let supabase;
        let localUserId = null;
        let localPlayerName = "Guest";
        let sound;

        // --- GAME LOGIC (PURE FUNCTIONS) ---
        // (逻辑保持不变，确保与 UI 和数据结构兼容)

        function processAction(currentState, actingUserId, action, amount = 0) {
            let newState = JSON.parse(JSON.stringify(currentState));
            const config = newState.config || { bigBlind: 20 };
            let player = newState.players[actingUserId];

            const currentPlayerId = newState.playerOrder[newState.currentPlayerIndex];
            if (currentPlayerId !== actingUserId) return currentState;

            if (player.folded || (player.chips === 0 && newState.phase !== "waiting")) {
                newState.currentPlayerIndex = (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
                return newState;
            }

            const diff = newState.currentMaxBet - player.currentBet;
            let triggerAllInEffect = false;
            let logJson = "";

            if (action === "fold") {
                player.folded = true;
                player.status = "status_fold";
                logJson = createLog("log_fold", { name: player.name });
            } else if (action === "check") {
                if (diff > 0) return currentState;
                player.status = "status_check";
                logJson = createLog("log_check", { name: player.name });
            } else if (action === "call") {
                let callAmount = Math.min(diff, player.chips);
                let isAllIn = callAmount === player.chips && diff > 0;
                player.chips -= callAmount;
                player.currentBet += callAmount;
                newState.pot += callAmount;
                player.status = isAllIn ? "status_all_in" : "status_call";
                const logKey = isAllIn ? "log_all_in" : "log_call";
                logJson = createLog(logKey, { name: player.name, amount: callAmount });
                if (isAllIn) triggerAllInEffect = true;
            } else if (action === "raise") {
                let raiseAmount = amount - player.currentBet;
                let actualAmount = amount;

                if (actualAmount <= newState.currentMaxBet && actualAmount < player.chips) return currentState;
                const extraRaise = actualAmount - newState.currentMaxBet;

                if (extraRaise < newState.lastRaiseAmount && actualAmount < player.chips) return currentState;

                let isAllIn = raiseAmount >= player.chips;
                if (isAllIn) {
                    actualAmount = player.chips + player.currentBet;
                    raiseAmount = player.chips;
                    triggerAllInEffect = true;
                }

                player.chips -= raiseAmount;
                player.currentBet = actualAmount;
                newState.pot += raiseAmount;

                const newRaiseAmount = actualAmount - newState.currentMaxBet;
                if (!isAllIn || newRaiseAmount >= newState.lastRaiseAmount) {
                    newState.lastRaiseAmount = newRaiseAmount;
                }
                newState.currentMaxBet = actualAmount;
                newState.playersActed.length = 0;

                player.status = isAllIn ? "status_all_in" : "status_raise";
                const logKey = isAllIn ? "log_all_in" : "log_raise";
                logJson = createLog(logKey, { name: player.name, amount: actualAmount });
            }

            if (logJson) {
                newState.logs.push(logJson);
                if (newState.logs.length > 20) newState.logs.shift();
            }

            if (!newState.playersActed.includes(actingUserId)) {
                newState.playersActed.push(actingUserId);
            }

            const activePlayers = newState.playerOrder.map(uid => newState.players[uid]).filter(p => !p.folded);
            const playersWithChips = activePlayers.filter(p => p.chips > 0);

            const isRoundComplete = activePlayers.every(p => {
                const isAllIn = p.chips === 0 && !p.folded;
                const matchBet = p.currentBet === newState.currentMaxBet;
                const hasActed = newState.playersActed.includes(p.uid);
                if (isAllIn) return true;

                if (newState.phase === 'preflop' && newState.currentMaxBet === config.bigBlind) {
                    let bbIndex;
                    if (newState.playerOrder.length === 2) {
                        bbIndex = (newState.dealerIndex + 1) % 2;
                    } else {
                        bbIndex = (newState.dealerIndex + 2) % newState.playerOrder.length;
                    }
                    if (p.uid === newState.playerOrder[bbIndex] && !hasActed) return false;
                }

                return hasActed && matchBet;
            });

            if (activePlayers.length === 1) {
                newState = advanceToShowdown(newState, activePlayers[0]);
            }
            else if (isRoundComplete && playersWithChips.length <= 1 && newState.phase !== "showdown") {
                newState = runAutoShowdown(newState);
            }
            else if (isRoundComplete) {
                newState = advanceToNextPhase(newState);
            }
            else {
                let loops = 0;
                do {
                    newState.currentPlayerIndex = (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
                    const nextPlayer = newState.players[newState.playerOrder[newState.currentPlayerIndex]];
                    if (nextPlayer.folded || nextPlayer.chips === 0) {
                        loops++;
                        continue;
                    }
                    break;
                } while (loops <= newState.playerOrder.length * 2);
            }

            if (triggerAllInEffect) {
                newState.lastAllInPlayer = player.uid + "_" + Date.now();
            }
            return newState;
        }

        function advanceToNextPhase(currentState) {
            let newState = JSON.parse(JSON.stringify(currentState));
            const config = newState.config || { bigBlind: 20 };
            newState = returnExcessBets(newState);

            newState.playerOrder.forEach(uid => {
                const p = newState.players[uid];
                p.accumulatedBet += p.currentBet;
                p.currentBet = 0;
                p.status = "";
            });

            newState.currentMaxBet = 0;
            newState.lastRaiseAmount = config.bigBlind;
            newState.playersActed = [];

            if (newState.phase === "preflop") {
                newState.phase = "flop";
                newState.communityCards.push(newState.deck.pop(), newState.deck.pop(), newState.deck.pop());
                newState.logs.push(createLog("log_phase_flop"));
            } else if (newState.phase === "flop") {
                newState.phase = "turn";
                newState.communityCards.push(newState.deck.pop());
                newState.logs.push(createLog("log_phase_turn"));
            } else if (newState.phase === "turn") {
                newState.phase = "river";
                newState.communityCards.push(newState.deck.pop());
                newState.logs.push(createLog("log_phase_river"));
            } else if (newState.phase === "river") {
                newState = advanceToShowdown(newState);
                return newState;
            }

            let nextIdx = (newState.dealerIndex + 1) % newState.playerOrder.length;
            let loops = 0;
            while (loops <= newState.playerOrder.length) {
                const p = newState.players[newState.playerOrder[nextIdx]];
                if (!p.folded && p.chips > 0) break;
                nextIdx = (nextIdx + 1) % newState.playerOrder.length;
                loops++;
            }
            newState.currentPlayerIndex = nextIdx;
            return newState;
        }

        function runAutoShowdown(currentState) {
            let newState = JSON.parse(JSON.stringify(currentState));
            newState = returnExcessBets(newState);

            newState.playerOrder.forEach(uid => {
                const p = newState.players[uid];
                p.accumulatedBet += p.currentBet;
                p.currentBet = 0;
                p.status = p.chips === 0 && !p.folded ? "status_all_in" : p.status;
            });

            newState.currentPlayerIndex = -1;

            if (newState.phase === "preflop") {
                newState.phase = "flop";
                newState.communityCards.push(newState.deck.pop(), newState.deck.pop(), newState.deck.pop());
                newState.logs.push(createLog("log_phase_flop"));
                newState.nextPhaseTimer = 1500;
            } else if (newState.phase === "flop") {
                newState.phase = "turn";
                newState.communityCards.push(newState.deck.pop());
                newState.logs.push(createLog("log_phase_turn"));
                newState.nextPhaseTimer = 1500;
            } else if (newState.phase === "turn") {
                newState.phase = "river";
                newState.communityCards.push(newState.deck.pop());
                newState.logs.push(createLog("log_phase_river"));
                newState.nextPhaseTimer = 1500;
            } else if (newState.phase === "river") {
                newState.nextPhaseTimer = 0;
                newState = advanceToShowdown(newState);
            }
            return newState;
        }

        function returnExcessBets(currentState) {
            let newState = JSON.parse(JSON.stringify(currentState));
            const activePlayers = newState.playerOrder.map(uid => newState.players[uid]).filter(p => !p.folded);
            if (activePlayers.length < 2) return newState;

            const sortedPlayers = [...activePlayers].sort((a, b) => b.currentBet - a.currentBet);
            const highest = sortedPlayers[0];
            const secondHighest = sortedPlayers[1];

            if (highest.currentBet > secondHighest.currentBet) {
                const refund = highest.currentBet - secondHighest.currentBet;
                const playerToRefund = newState.players[highest.uid];
                playerToRefund.chips += refund;
                playerToRefund.currentBet -= refund;
                newState.pot -= refund;
                newState.logs.push(createLog("log_refund", { amount: refund, name: playerToRefund.name }));
            }
            return newState;
        }

        function advanceToShowdown(currentState, soleWinner = null) {
            let newState = JSON.parse(JSON.stringify(currentState));
            newState.phase = "showdown";
            newState.currentPlayerIndex = -1;

            if (soleWinner) {
                const winnerPlayer = newState.players[soleWinner.uid];
                newState.playerOrder.forEach(uid => newState.players[uid].currentBet = 0);
                winnerPlayer.chips += newState.pot;
                newState.logs.push(createLog("log_win_sole", { name: winnerPlayer.name, amount: newState.pot }));
                newState.highlightWinner = winnerPlayer.uid;
            }
            else {
                let finalPot = 0;
                newState.playerOrder.forEach(uid => {
                    const p = newState.players[uid];
                    p.accumulatedBet += p.currentBet;
                    finalPot += p.accumulatedBet;
                    p.currentBet = 0;
                });
                newState.pot = finalPot;
                const allPlayers = newState.playerOrder.map(uid => newState.players[uid]);
                const activePlayers = allPlayers.filter(p => !p.folded);

                if (activePlayers.length === 0) {
                    newState.logs.push(createLog("log_round_end_no_winner"));
                } else {
                    activePlayers.forEach(p => {
                        p.bestHand = HandEvaluator.evaluate(p.holeCards, newState.communityCards);
                    });

                    let distinctBets = [...new Set(activePlayers.map(p => p.accumulatedBet))].filter(bet => bet > 0).sort((a, b) => a - b);
                    let winnerLogs = [];
                    newState.highlightCards = new Set();

                    let prevBet = 0;
                    distinctBets.forEach((betLevel, index) => {
                        let potAmount = 0;
                        allPlayers.forEach(p => {
                            if (p.accumulatedBet >= betLevel) potAmount += betLevel - prevBet;
                            else if (p.accumulatedBet > prevBet) potAmount += p.accumulatedBet - prevBet;
                        });

                        let contributors = activePlayers.filter(p => p.accumulatedBet >= betLevel);
                        if (potAmount > 0 && contributors.length > 0) {
                            let bestScore = -1;
                            let winners = [];

                            contributors.forEach(p => {
                                if (p.bestHand.score > bestScore) {
                                    bestScore = p.bestHand.score;
                                    winners = [p];
                                } else if (Math.abs(p.bestHand.score - bestScore) < 0.1) {
                                    winners.push(p);
                                }
                            });

                            const winPer = Math.floor(potAmount / winners.length);
                            let remainder = potAmount % winners.length;

                            const potNameKey = index === 0 ? "main_pot" : "side_pot";
                            let winnerNames = winners.map(w => w.name).join(", ");

                            winnerLogs.push(createLog("log_showdown_result", {
                                potName: index === 0 ? "Main" : `Side ${index}`,
                                amount: potAmount,
                                winners: winnerNames
                            }));

                            winners.forEach(w => {
                                let winnings = winPer;
                                if (remainder > 0) { winnings++; remainder--; }
                                newState.players[w.uid].chips += winnings;
                                newState.highlightWinner = w.uid;
                                if (w.bestHand.bestCards) w.bestHand.bestCards.forEach(c => newState.highlightCards.add(c.id));
                            });
                        }
                        prevBet = betLevel;
                    });

                    newState.highlightCards = Array.from(newState.highlightCards);
                    newState.logs.push(...winnerLogs);
                }
            }
            newState.nextRoundTimer = 6000;
            sound.playHandEnd();
            return newState;
        }

        function startNewRound(currentState) {
            let newState = JSON.parse(JSON.stringify(currentState));
            const config = newState.config || { initialChips: 2000, smallBlind: 10, bigBlind: 20 };
            const bigBlindVal = parseInt(config.bigBlind) || 20;
            const smallBlindVal = parseInt(config.smallBlind) || 10;

            let activePlayerIds = [];
            const allPlayerIds = currentState.playerOrder;

            allPlayerIds.forEach(uid => {
                if (newState.players[uid].chips > 0) activePlayerIds.push(uid);
                else {
                    newState.players[uid].folded = true;
                    newState.players[uid].status = "status_eliminated";
                }
            });

            if (activePlayerIds.length < 2) {
                const winnerId = activePlayerIds.length > 0 ? activePlayerIds[0] : null;
                const winnerName = winnerId ? newState.players[winnerId].name : "No one";
                let newLogs = [...newState.logs];
                newLogs.push(createLog("log_game_over", { name: winnerName }));

                // 1. 先重置现有的玩家
                const resetPlayers = {};
                // 注意：这里使用 newState.playerOrder 来保证顺序，但也要注意如果有玩家中途离开的情况
                let currentOrder = [...newState.playerOrder];

                currentOrder.forEach(uid => {
                    const p = newState.players[uid];
                    if (p) {
                        resetPlayers[uid] = {
                            ...p,
                            chips: config.initialChips, // 重置筹码
                            holeCards: [],
                            folded: false,
                            currentBet: 0,
                            accumulatedBet: 0,
                            status: "waiting",
                            bestHand: null
                        };
                    }
                });

                // 2. 处理旁观者 (Spectator Promotion Logic)
                let nextSpectators = [];
                let currentSpectators = currentState.spectators || [];

                // 遍历所有旁观者
                currentSpectators.forEach(spec => {
                    // 兼容旧数据：如果是纯字符串ID，转为对象结构 (防止报错)
                    const specObj = typeof spec === 'object' ? spec : { uid: spec, name: "Spectator" };

                    // 检查当前玩家总数是否已满 10 人
                    if (currentOrder.length < 10) {
                        // --- 晋升为玩家 ---
                        const newUid = specObj.uid;

                        // 创建新玩家对象
                        resetPlayers[newUid] = {
                            uid: newUid,
                            id: currentOrder.length, // 分配新 ID
                            name: specObj.name,
                            chips: config.initialChips,
                            holeCards: [],
                            folded: false,
                            currentBet: 0,
                            accumulatedBet: 0,
                            status: "waiting",
                            bestHand: null
                        };

                        // 加入顺序列表
                        currentOrder.push(newUid);
                        newLogs.push(createLog("log_join", { name: specObj.name + " (Promoted)" }));
                    } else {
                        // --- 仍然是旁观者 ---
                        // 房间满了，只能继续旁观
                        nextSpectators.push(specObj);
                    }
                });

                return {
                    status: "waiting",
                    hostId: newState.hostId,
                    config: config,
                    players: resetPlayers,
                    playerOrder: currentOrder, // 包含旧玩家 + 新晋升的玩家
                    spectators: nextSpectators, // 剩下挤不进去的旁观者

                    communityCards: [],
                    pot: 0,
                    dealerIndex: 0,
                    currentPlayerIndex: -1,
                    currentMaxBet: 0,
                    phase: "waiting",
                    lastRaiseAmount: bigBlindVal,
                    deck: [],
                    logs: newLogs,
                    highlightWinner: winnerId,
                    highlightCards: [],
                    nextRoundTimer: 0,
                    nextPhaseTimer: 0,
                    lastAllInPlayer: null
                };
            }

            newState.playerOrder = activePlayerIds;
            newState.communityCards = [];
            newState.pot = 0;
            newState.currentMaxBet = 0;
            newState.lastRaiseAmount = bigBlindVal;
            newState.phase = "preflop";
            newState.playersActed = [];
            newState.highlightWinner = null;
            newState.highlightCards = [];
            newState.nextRoundTimer = 0;
            newState.nextPhaseTimer = 0;
            newState.lastAllInPlayer = null;

            newState.playerOrder.forEach(uid => {
                const p = newState.players[uid];
                p.holeCards = [];
                p.folded = false;
                p.currentBet = 0;
                p.accumulatedBet = 0;
                p.status = "";
                p.bestHand = null;
            });

            let deck = [];
            for (let suit of SUITS) {
                for (let rank of RANKS) {
                    deck.push({ suit, rank, value: RANK_VALUES[rank], color: suit === "♥" || suit === "♦" ? "red" : "black", id: Math.random().toString(36).substr(2, 9) });
                }
            }
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            newState.deck = deck;

            const oldOrder = currentState.playerOrder;
            const oldDealerIndex = currentState.dealerIndex;
            let nextDealerId = null;
            let checkIndex = oldDealerIndex;
            for (let i = 0; i < oldOrder.length; i++) {
                checkIndex = (checkIndex + 1) % oldOrder.length;
                const candidateId = oldOrder[checkIndex];
                if (activePlayerIds.includes(candidateId)) {
                    nextDealerId = candidateId;
                    break;
                }
            }
            const newDealerIndex = newState.playerOrder.indexOf(nextDealerId);
            newState.dealerIndex = newDealerIndex !== -1 ? newDealerIndex : 0;
            const numPlayers = newState.playerOrder.length;

            let sbIndex, bbIndex;
            if (numPlayers === 2) {
                sbIndex = newState.dealerIndex;
                bbIndex = (newState.dealerIndex + 1) % numPlayers;
            } else {
                sbIndex = (newState.dealerIndex + 1) % numPlayers;
                bbIndex = (newState.dealerIndex + 2) % numPlayers;
            }

            const sbPlayer = newState.players[newState.playerOrder[sbIndex]];
            const bbPlayer = newState.players[newState.playerOrder[bbIndex]];

            const sbAmount = Math.min(smallBlindVal, sbPlayer.chips);
            sbPlayer.chips -= sbAmount;
            sbPlayer.currentBet = sbAmount;

            if (sbPlayer.chips === 0) {
                sbPlayer.status = "status_all_in";
                newState.lastAllInPlayer = sbPlayer.uid + "_" + Date.now();
            } else {
                sbPlayer.status = "status_small_blind";
            }

            const bbAmount = Math.min(bigBlindVal, bbPlayer.chips);
            bbPlayer.chips -= bbAmount;
            bbPlayer.currentBet = bbAmount;

            if (bbPlayer.chips === 0) {
                bbPlayer.status = "status_all_in";
                newState.lastAllInPlayer = bbPlayer.uid + "_" + Date.now();
            } else {
                bbPlayer.status = "status_big_blind";
            }

            newState.pot = sbAmount + bbAmount;
            newState.currentMaxBet = bigBlindVal;

            for (let i = 0; i < 2; i++) {
                for (let uid of newState.playerOrder) newState.players[uid].holeCards.push(newState.deck.pop());
            }

            let nextIdx = (bbIndex + 1) % numPlayers;
            let loopCount = 0;
            while (loopCount < numPlayers) {
                const p = newState.players[newState.playerOrder[nextIdx]];
                if (p.chips > 0) break;
                nextIdx = (nextIdx + 1) % numPlayers;
                loopCount++;
            }
            newState.currentPlayerIndex = nextIdx;

            const activePlayersInGame = newState.playerOrder.map(uid => newState.players[uid]).filter(p => !p.folded);
            const playersWithChips = activePlayersInGame.filter(p => p.chips > 0);

            newState.logs.push(createLog("log_new_round"));
            return newState;
        }

        // --- UI MANAGER ---
        class GameUIManager {
            constructor() {
                this.sound = new SoundManager();
                this.dragSystem = new TableDragSystem();
                this.occlusionManager = new OcclusionManager();
                this.lastState = null;
                this.localPlayerId = null;
                this.lastActivePlayerId = null;
                this.highlightCards = new Set();
                this.bankruptcyScreenShown = false;
                this.lastAllInPlayerTriggered = null;
                this.isSliderReset = false;

                document.getElementById("raise-slider").oninput = () => {
                    const slider = document.getElementById("raise-slider");
                    const btnRaise = document.getElementById("btn-raise");
                    const valDisplay = document.getElementById("raise-val-display");
                    if (slider && btnRaise && valDisplay && !slider.disabled) {
                        const raiseVal = parseInt(slider.value);
                        const maxVal = parseInt(slider.max);
                        valDisplay.innerText = `$${raiseVal}`;
                        btnRaise.innerText = raiseVal === maxVal ? t("allInBtn") : `${t("raiseBtn")} $${raiseVal}`;
                    }
                };
            }

            initSound() {
                this.sound.init();
                sound = this.sound;
            }

            renderGameState(state, localId) {
                if (!state) return;
                this.initSound();

                const lastLogStr = state.logs.length > 0 ? state.logs[state.logs.length - 1] : "";
                const prevLogStr = (this.lastState && this.lastState.logs.length > 0) ? this.lastState.logs[this.lastState.logs.length - 1] : "";

                const hasNewLog = this.lastState && (state.logs.length > this.lastState.logs.length || (state.logs.length > 0 && lastLogStr !== prevLogStr));

                if (hasNewLog) {
                    let logKey = "";
                    try {
                        const logObj = JSON.parse(lastLogStr);
                        logKey = logObj.key;
                    } catch (e) {
                        logKey = lastLogStr;
                    }

                    if (logKey === "log_fold") this.sound.playFold();
                    else if (logKey === "log_check") this.sound.playCheck();
                    else if (logKey === "log_call") this.sound.playChip();
                    else if (logKey === "log_raise") this.sound.playRaise();
                    if (["log_phase_flop", "log_phase_turn", "log_phase_river"].includes(logKey)) this.sound.playCard();
                }

                this.highlightCards = new Set(state.highlightCards || []);
                const playerCount = state.playerOrder ? state.playerOrder.length : 0;
                const countEl = document.getElementById("active-players-count");
                if (countEl) countEl.innerText = playerCount;

                if (state.lastAllInPlayer && (!this.lastState || state.lastAllInPlayer !== this.lastState.lastAllInPlayer)) {
                    if (state.lastAllInPlayer !== this.lastAllInPlayerTriggered) {
                        this.showAllInEffect(state.lastAllInPlayer);
                        this.lastAllInPlayerTriggered = state.lastAllInPlayer;
                    }
                }
                if (state.phase === "showdown") this.lastAllInPlayerTriggered = null;

                this.lastState = state;
                this.localPlayerId = localId;
                const localPlayer = state.players[localId];

                document.getElementById("pot-display").innerText = state.pot;

                const phaseKey = PHASE_KEY_MAP[state.phase] || state.phase;
                document.getElementById("phase-display").innerText = t(phaseKey);

                if (state.config) {
                    const blindsEl = document.getElementById("blinds-display");
                    if (blindsEl) blindsEl.innerText = `${t("bigBlind")} $${state.config.bigBlind}`;
                }

                this.renderTableLayout(state, localId);

                for (let i = 0; i < 5; i++) {
                    const slot = document.getElementById(`comm-slot-${i}`);
                    if (!slot) continue;
                    const cardData = state.communityCards[i];
                    if (cardData) {
                        let cardEl = slot.firstElementChild;
                        if (!cardEl) {
                            cardEl = this.createCardEl(cardData);
                            slot.appendChild(cardEl);
                        }
                        if (this.highlightCards.has(cardData.id)) {
                            if (!cardEl.classList.contains("winning-card")) cardEl.classList.add("winning-card");
                        } else {
                            if (cardEl.classList.contains("winning-card")) cardEl.classList.remove("winning-card");
                        }
                    } else {
                        slot.innerHTML = "";
                    }
                }

                const logDiv = document.getElementById("game-log");
                logDiv.innerHTML = state.logs.map((logStr) => {
                    let displayMsg = logStr;
                    try {
                        const logObj = JSON.parse(logStr);
                        if (logObj.key) {
                            displayMsg = t(logObj.key, logObj.args);
                            if (logObj.key === "log_showdown_result") {
                                const potNameRaw = logObj.args.potName;
                                let translatedPot = potNameRaw;
                                if (potNameRaw === "Main") translatedPot = t("main_pot");
                                else if (potNameRaw && potNameRaw.startsWith("Side")) translatedPot = t("side_pot") + " " + potNameRaw.split(" ")[1];
                                displayMsg = displayMsg.replace(potNameRaw, translatedPot);
                            }
                        }
                    } catch (e) { }
                    return `<div>> ${displayMsg}</div>`;
                }).join("");
                logDiv.scrollTop = logDiv.scrollHeight;

                this.updateControls(state);

                if (localPlayer) {
                    const lastLog = state.logs.length > 0 ? state.logs[state.logs.length - 1] : "";
                    const isChampion = state.status === "waiting" && state.highlightWinner === localId && lastLog.includes("log_game_over");

                    const isEliminated = localPlayer.status === "status_eliminated" && localPlayer.chips === 0;

                    if (isChampion) {
                        if (!this.bankruptcyScreenShown) {
                            this.sound.playWin();
                            this.showMessage(t("msg_winner"));
                            this.bankruptcyScreenShown = true;
                        }
                    }
                    else if (isEliminated && state.status === "playing") {
                        if (!this.bankruptcyScreenShown) {
                            this.sound.playLose();
                            this.showMessage(t("msg_bankruptcy"));
                            this.bankruptcyScreenShown = true;
                        }
                    }
                    else if (state.status === "waiting" && !isChampion) {
                        this.bankruptcyScreenShown = false;
                    }
                }

                const waitOverlay = document.getElementById("waiting-room-overlay");
                if (state.status === "waiting") {
                    waitOverlay.classList.remove("hidden");
                    network.updateWaitingRoomUI(state, localId);
                } else {
                    waitOverlay.classList.add("hidden");
                }
            }

            renderTableLayout(state, localId) {
                const container = document.getElementById("seats-container");
                const playerIdsToRender = state.phase === "waiting" || state.status === "waiting" ? state.playerOrder : state.playerOrder;
                const num = playerIdsToRender.length;
                if (num === 0) {
                    container.innerHTML = "";
                    return;
                }
                const w = container.offsetWidth;
                const h = container.offsetHeight;
                const cx = w / 2;
                const cy = h / 2;
                const localIndex = playerIdsToRender.indexOf(localId);
                const renderIndex = localIndex === -1 ? 0 : localIndex;

                let scale = 1, radiusX = 0.38, radiusY = 0.38;
                if (num > 6) { scale = 0.85; radiusX = 0.42; radiusY = 0.42; }
                if (num >= 9) { scale = 0.75; radiusX = 0.44; radiusY = 0.44; }
                if (w < 768) {
                    if (num > 5) scale = 0.75;
                    if (num > 8) scale = 0.65;
                    radiusX = 0.4;
                }
                const rx = w * radiusX;
                const ry = h * radiusY;
                const activeSeatIds = new Set();

                playerIdsToRender.forEach((uid, i) => {
                    const p = state.players[uid];
                    if (!p) return;

                    const seatId = `seat-${p.uid}`;
                    activeSeatIds.add(seatId);

                    let seatDiv = document.getElementById(seatId);
                    if (!seatDiv) {
                        seatDiv = document.createElement("div");
                        seatDiv.id = seatId;
                        seatDiv.className = "player-seat";
                        seatDiv.innerHTML = `
              <div id="cards-${p.uid}" class="absolute flex space-x-1 z-10 transition-all" style="top:-50px;"></div>
              <div class="player-info-box relative z-20">
                  <div id="dealer-${p.uid}" class="dealer-btn hidden">D</div>
                  <div id="name-${p.uid}" class="font-bold text-yellow-400 truncate text-sm tracking-wide"></div>
                  <div class="text-white text-xs font-mono">$<span id="chips-${p.uid}"></span></div>
                  <div id="status-${p.uid}" class="text-gray-400 text-[10px] h-4 truncate font-bold uppercase mt-1"></div>
              </div>`;
                        container.appendChild(seatDiv);
                    }

                    const offsetIndex = (i - renderIndex + num) % num;
                    const angle = Math.PI / 2 + (offsetIndex * (2 * Math.PI)) / num;
                    const x = cx + rx * Math.cos(angle);
                    const y = cy + ry * Math.sin(angle);

                    seatDiv.style.left = `${x - 60}px`;
                    seatDiv.style.top = `${y - 55}px`;
                    seatDiv.style.transform = `scale(${scale})`;

                    seatDiv.querySelector(`#name-${p.uid}`).innerText = p.name;
                    seatDiv.querySelector(`#chips-${p.uid}`).innerText = p.chips;

                    const dealerBtn = seatDiv.querySelector(`#dealer-${p.uid}`);
                    if (i === state.dealerIndex) dealerBtn.classList.remove("hidden");
                    else dealerBtn.classList.add("hidden");

                    let statusText = "";
                    if (p.currentBet > 0) statusText = `${t("bet_prefix")} $${p.currentBet}`;
                    else if (p.status) {
                        statusText = t(p.status);
                        if (p.status.startsWith("hand_")) statusText = t(p.status);
                    }
                    seatDiv.querySelector(`#status-${p.uid}`).innerText = statusText;

                    if (state.playerOrder[state.currentPlayerIndex] === p.uid && state.phase !== "showdown") {
                        seatDiv.classList.add("active-player");
                    } else {
                        seatDiv.classList.remove("active-player");
                    }
                    if (state.highlightWinner === p.uid) seatDiv.classList.add("winner-highlight");
                    else seatDiv.classList.remove("winner-highlight");
                    seatDiv.style.opacity = p.folded ? 0.4 : 1;

                    const cardsContainer = document.getElementById(`cards-${p.uid}`);
                    const activePlayersCount = Object.values(state.players).filter(player => !player.folded).length;
                    const shouldShowFace = !p.folded && p.holeCards && p.holeCards.length > 0 &&
                        (p.uid === localId || (state.phase === "showdown" && activePlayersCount > 1));

                    if (shouldShowFace) {
                        if (cardsContainer.querySelector('.card-back')) cardsContainer.innerHTML = "";

                        p.holeCards.forEach((c, cardIdx) => {
                            let cardEl = cardsContainer.children[cardIdx];

                            if (!cardEl || cardEl.dataset.cid !== c.id) {
                                const newCard = this.createCardEl(c);
                                newCard.dataset.cid = c.id;
                                if (cardEl) cardsContainer.replaceChild(newCard, cardEl);
                                else cardsContainer.appendChild(newCard);
                                cardEl = newCard;
                            }

                            if (this.highlightCards.has(c.id)) {
                                if (!cardEl.classList.contains("winning-card")) cardEl.classList.add("winning-card");
                            } else {
                                cardEl.classList.remove("winning-card");
                            }
                        });

                        while (cardsContainer.children.length > p.holeCards.length) {
                            cardsContainer.removeChild(cardsContainer.lastChild);
                        }
                    } else if (!p.folded && p.holeCards && p.holeCards.length > 0) {
                        if (cardsContainer.children.length !== 2 || !cardsContainer.children[0].classList.contains('card-back')) {
                            cardsContainer.innerHTML = "";
                            cardsContainer.appendChild(this.createBackEl());
                            cardsContainer.appendChild(this.createBackEl());
                        }
                    } else {
                        cardsContainer.innerHTML = "";
                    }
                });

                Array.from(container.children).forEach(child => {
                    if (!activeSeatIds.has(child.id)) {
                        container.removeChild(child);
                    }
                });
            }

            updateControls(state) {
                if (!state || !state.players || !this.localPlayerId) return;
                const localPlayer = state.players[this.localPlayerId];
                const controls = document.getElementById("player-controls");

                // 如果本地用户不在 players 列表中（即旁观者），隐藏所有操作按钮
                if (!localPlayer) {
                    controls.classList.add("opacity-50", "pointer-events-none", "translate-y-2");
                    // 可以额外显示一个状态，例如将 check 按钮文本改为 "SPECTATING"
                    const btnCheck = document.getElementById("btn-check");
                    if (btnCheck) btnCheck.innerText = "SPECTATING";
                    btnCheck.classList.remove("hidden");
                    document.getElementById("btn-call").classList.add("hidden");
                    document.getElementById("btn-raise").classList.add("hidden");
                    document.getElementById("raise-slider-container").classList.add("hidden");
                    return;
                }
                const currentTurnPlayerId = state.playerOrder[state.currentPlayerIndex];
                const currentTurnPlayer = state.players[currentTurnPlayerId];

                if (state.status === "playing" && state.phase !== "showdown" && state.phase !== "waiting") {
                    if (this.lastActivePlayerId !== currentTurnPlayerId) {
                        this.lastActivePlayerId = currentTurnPlayerId;
                        if (currentTurnPlayerId === this.localPlayerId) {
                            this.showMessage(t("msg_your_turn"));
                        } else {
                            const name = currentTurnPlayer ? currentTurnPlayer.name : "Player";
                            this.showMessage(`${name} ${t("msg_thinking")}`);
                        }
                    }
                } else {
                    this.lastActivePlayerId = null;
                }

                const isMyTurn = currentTurnPlayerId === this.localPlayerId;
                const canAct = isMyTurn && !localPlayer.folded && localPlayer.chips > 0 && state.phase !== "showdown";

                if (!canAct) {
                    controls.classList.add("opacity-50", "pointer-events-none", "translate-y-2");
                    this.isSliderReset = false;
                    return;
                }
                controls.classList.remove("opacity-50", "pointer-events-none", "translate-y-2");

                const diff = state.currentMaxBet - localPlayer.currentBet;
                const btnCheck = document.getElementById("btn-check");
                const btnCall = document.getElementById("btn-call");
                const btnRaise = document.getElementById("btn-raise");
                const slider = document.getElementById("raise-slider");
                const valDisplay = document.getElementById("raise-val-display");

                btnCheck.innerText = t("checkBtn");
                btnCall.innerText = t("callBtn");
                btnRaise.innerText = t("raiseBtn");
                document.querySelector('[data-i18n="foldBtn"]').innerText = t("foldBtn");

                if (diff === 0) {
                    btnCheck.classList.remove("hidden");
                    btnCall.classList.add("hidden");
                } else {
                    btnCheck.classList.add("hidden");
                    btnCall.classList.remove("hidden");
                    if (localPlayer.chips <= diff) btnCall.innerText = t("allInBtn");
                    else btnCall.innerText = `${t("callBtn")} $${diff}`;
                }

                const minRaiseAmount = state.lastRaiseAmount;
                const minPossibleActionRaise = diff + minRaiseAmount;
                const maxPossibleActionRaise = localPlayer.chips;

                if (localPlayer.chips <= diff) {
                    btnRaise.classList.add("hidden");
                    document.getElementById("raise-slider-container").classList.add("hidden");
                } else if (maxPossibleActionRaise < minPossibleActionRaise) {
                    btnRaise.classList.remove("hidden");
                    btnRaise.innerText = t("allInBtn");
                    document.getElementById("raise-slider-container").classList.remove("hidden");
                    slider.min = maxPossibleActionRaise;
                    slider.max = maxPossibleActionRaise;
                    slider.value = maxPossibleActionRaise;
                    valDisplay.innerText = `$${maxPossibleActionRaise}`;
                    slider.disabled = true;
                } else {
                    btnRaise.classList.remove("hidden");
                    document.getElementById("raise-slider-container").classList.remove("hidden");
                    slider.min = minPossibleActionRaise;
                    slider.max = maxPossibleActionRaise;
                    slider.step = 1;
                    if (!this.isSliderReset) {
                        slider.value = slider.min;
                        this.isSliderReset = true;
                    }
                    slider.disabled = false;
                    const updateBtnText = () => {
                        const raiseVal = parseInt(slider.value);
                        valDisplay.innerText = `$${raiseVal}`;
                        if (raiseVal === maxPossibleActionRaise) btnRaise.innerText = t("allInBtn");
                        else btnRaise.innerText = `${t("raiseBtn")} $${raiseVal}`;
                    };
                    updateBtnText();
                }
            }

            adjustRaise(direction) {
                const slider = document.getElementById("raise-slider");
                if (!slider || slider.disabled) return;
                const currentVal = parseInt(slider.value);
                const step = 1;
                const min = parseInt(slider.min);
                const max = parseInt(slider.max);
                let newVal = currentVal + direction * step;
                if (newVal < min) newVal = min;
                if (newVal > max) newVal = max;
                slider.value = newVal;
                slider.dispatchEvent(new Event("input"));
            }

            showMessage(msg) {
                const el = document.getElementById("game-message");
                if (!el) return;
                el.innerText = msg;
                el.style.opacity = 1;
                if (this.msgTimeout) {
                    clearTimeout(this.msgTimeout);
                    this.msgTimeout = null;
                }
                this.msgTimeout = setTimeout(() => {
                    el.style.opacity = 0;
                }, 3000);
            }

            showAllInEffect(playerName) {
                return new Promise((resolve) => {
                    const overlay = document.createElement("div");
                    overlay.className = "all-in-fullscreen-overlay";
                    const bar = document.createElement("div");
                    bar.className = "all-in-bar";
                    const text = document.createElement("div");
                    text.className = "all-in-text";
                    text.innerText = `ALL-IN`;
                    bar.appendChild(text);
                    overlay.appendChild(bar);
                    document.body.appendChild(overlay);
                    this.sound.playAllIn();
                    setTimeout(() => {
                        overlay.style.transition = "opacity 0.3s";
                        overlay.style.opacity = "0";
                        setTimeout(() => {
                            overlay.remove();
                            resolve();
                        }, 300);
                    }, 1250);
                });
            }

            createCardEl(c) {
                const d = document.createElement("div");
                d.className = `card ${c.color}`;
                if (this.highlightCards.has(c.id)) d.classList.add("winning-card");
                d.innerHTML = `<span class="absolute top-0 left-1 text-xs">${c.rank}</span><span class="text-2xl">${c.suit}</span>`;
                return d;
            }
            createBackEl() {
                const d = document.createElement("div");
                d.className = "card card-back";
                return d;
            }
        }

        class NetworkManager {
            constructor(gameUI) {
                this.gameUI = gameUI;
                this.appId = "texas-holdem-supabase";
                this.localUserId = null;
                this.currentRoomId = null;
                this.realtimeChannel = null;
                this.nextRoundTimeout = null;
                this.nextPhaseTimeout = null;
                this.heartbeatInterval = null;
                this.cachedRooms = null;
                this.roomListInterval = null;
            }

            init() {
                const SUPABASE_URL = 'https://ptpvoqcksuwkdlxnekad.supabase.co';
                const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB0cHZvcWNrc3V3a2RseG5la2FkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3NTU0MjAsImV4cCI6MjA4MDMzMTQyMH0.ArID4owrMjOjDMc4b1ePDPZJ7Pajy8i9z7CA9hZZGHg';

                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

                let storedId = localStorage.getItem("poker_user_id");
                if (!storedId) {
                    storedId = "user_" + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem("poker_user_id", storedId);
                }
                this.localUserId = storedId;
                localUserId = storedId;

                document.getElementById("user-id-display").innerText = this.localUserId;
                document.getElementById("loader-screen").classList.add("hidden");
                document.getElementById("room-screen").classList.remove("hidden");

                // 初始化时自动加载一次列表
                this.startRoomAutoRefresh();
            }

            // --- 修改：获取房间列表 ---
            async fetchRoomList() {
                const listEl = document.getElementById("room-list");

                // 【优化】只有在没有缓存数据时（首次加载），才显示 Loading 提示
                // 这样自动刷新时，用户界面不会闪烁
                if (!this.cachedRooms && listEl) {
                    listEl.innerHTML = `<p class="text-gray-500 text-xs text-center mt-4">${t('loadingList')}</p>`;
                }

                try {
                    const { data: rooms, error } = await supabase
                        .from('rooms')
                        .select('*')
                        .order('last_active', { ascending: false })
                        .limit(20);

                    if (error) throw error;

                    // 如果没有房间
                    if (!rooms || rooms.length === 0) {
                        this.cachedRooms = [];
                        this.renderRoomList();
                        return;
                    }

                    const now = Date.now();
                    const validRooms = [];

                    // 预处理：清理僵尸房间
                    rooms.forEach(room => {
                        const lastActiveTime = new Date(room.last_active).getTime();
                        const isDead = (now - lastActiveTime) > 60000;

                        if (isDead) {
                            // 后台静默清理，不阻塞
                            supabase.from('rooms').delete().eq('id', room.id).then(() => { });
                        } else {
                            validRooms.push(room);
                        }
                    });

                    // 保存缓存并渲染
                    this.cachedRooms = validRooms;
                    this.renderRoomList();

                } catch (e) {
                    console.error(e);
                    // 只有在列表为空时才显示错误，防止刷新时把现有列表刷成错误提示
                    if (!this.cachedRooms || this.cachedRooms.length === 0) {
                        if (listEl) listEl.innerHTML = `<p class="text-red-500 text-xs text-center mt-4">${t('errorLoad')}</p>`;
                    }
                    this.cachedRooms = null;
                }
            }

            renderRoomList() {
                const listEl = document.getElementById("room-list");
                if (!listEl) return;

                // 如果还没获取过数据，或者获取失败，不执行渲染
                if (this.cachedRooms === null) return;

                listEl.innerHTML = "";

                // 如果缓存是空的（或者全是僵尸房间被过滤了）
                if (this.cachedRooms.length === 0) {
                    listEl.innerHTML = `<p class="text-gray-500 text-xs text-center mt-4">${t('noActiveRooms')}</p>`;
                    return;
                }

                // 遍历缓存数据生成 HTML
                this.cachedRooms.forEach(room => {
                    const state = room.game_state;
                    const playerCount = state.playerOrder ? state.playerOrder.length : 0;
                    const isPlaying = state.status === "playing";
                    const statusColor = isPlaying ? "text-red-400" : "text-green-400";

                    // 这里现在会根据当前的 t() 实时获取语言
                    const statusText = isPlaying ? t('status_playing_list') : t('status_waiting_list');

                    let hostName = 'Unknown';
                    if (state.players && state.players[state.hostId]) {
                        hostName = state.players[state.hostId].name;
                    }

                    const item = document.createElement("div");
                    item.className = "bg-gray-700 hover:bg-gray-600 p-2 rounded cursor-pointer flex justify-between items-center transition-colors mb-2";
                    item.onclick = () => {
                        document.getElementById("room-id-input").value = room.id;
                        this.joinRoom();
                    };

                    item.innerHTML = `
                        <div class="flex flex-col">
                            <span class="font-bold text-white text-xs">${room.id}</span>
                            <span class="text-[10px] text-gray-400">${t('hostLabel')}: ${hostName}</span>
                        </div>
                        <div class="text-right">
                            <div class="text-xs font-mono text-yellow-500">${playerCount}/10</div>
                            <div class="text-[10px] ${statusColor}">${statusText}</div>
                        </div>
                    `;
                    listEl.appendChild(item);
                });
            }

            // --- 新增：启动自动刷新 ---
            startRoomAutoRefresh() {
                // 先清除旧的，防止重复
                this.stopRoomAutoRefresh();

                // 立即执行一次
                this.fetchRoomList();

                // 每5秒执行一次
                this.roomListInterval = setInterval(() => {
                    this.fetchRoomList();
                }, 5000);
            }

            // --- 新增：停止自动刷新 ---
            stopRoomAutoRefresh() {
                if (this.roomListInterval) {
                    clearInterval(this.roomListInterval);
                    this.roomListInterval = null;
                }
            }

            updateWaitingRoomUI(state, localId) {
                const hostControls = document.getElementById("wait-host-controls");
                const btnContainer = document.getElementById("host-start-btn-container");

                if (state.hostId === localId) {
                    hostControls.classList.remove("hidden");
                    const playerCount = state.playerOrder.length;
                    if (playerCount < 2) {
                        if (btnContainer) {
                            btnContainer.innerHTML = `
                  <button disabled class="bg-gray-500 text-gray-300 font-black text-2xl py-4 px-12 rounded-full shadow-none border-b-4 border-gray-700 cursor-not-allowed opacity-50">
                    ${t("waitPlayerBtn")} (${playerCount}/10)
                  </button>`;
                        }
                    } else {
                        if (btnContainer) {
                            btnContainer.innerHTML = ` 
                              <button id="btn-start-game" onclick="network.startGame()" 
                                class="bg-red-600 hover:bg-red-500 text-white font-black text-2xl py-4 px-12 rounded-full shadow-xl border-b-4 border-red-800 active:border-b-0 active:translate-y-1 transition-all">
                                ${t("startGameBtn")} (${playerCount}/10)
                              </button>`;
                        }
                    }
                    const bbInput = document.getElementById("setting-big-blind");
                    const chipsInput = document.getElementById("setting-initial-chips");
                    const sbDisplay = document.getElementById("setting-sb-display");
                    const errChips = document.getElementById("error-chips-inline");
                    const errBlind = document.getElementById("error-blind-inline");
                    const startBtn = document.getElementById("btn-start-game");
                    const validateInputs = () => {
                        let isValid = true;

                        const chipsVal = parseInt(chipsInput.value) || 0;
                        const bbVal = parseInt(bbInput.value) || 0;
                        if (bbVal < 2) {
                            errBlind.innerText = t("error_blind_min");
                            isValid = false;
                        } else if (bbVal % 2 !== 0) {
                            errBlind.innerText = t("error_blind_even");
                            isValid = false;
                        } else {
                            errBlind.innerText = "";
                        }
                        if (sbDisplay) sbDisplay.innerText = Math.floor(bbVal / 2);
                        if (chipsVal <= bbVal) {
                            errChips.innerText = t("error_chips_too_low");
                            isValid = false;
                        } else {
                            errChips.innerText = "";
                        }
                        if (startBtn) {
                            if (!isValid) {
                                startBtn.disabled = true;
                                startBtn.classList.add("opacity-50", "cursor-not-allowed", "grayscale");
                            } else {
                                startBtn.disabled = false;
                                startBtn.classList.remove("opacity-50", "cursor-not-allowed", "grayscale");
                            }
                        }
                    };
                    if (chipsInput) {
                        chipsInput.oninput = () => {
                            chipsInput.value = chipsInput.value.replace(/[^\d]/g, '');
                            validateInputs();
                        };
                    }

                    if (bbInput) {
                        bbInput.oninput = () => {
                            bbInput.value = bbInput.value.replace(/[^\d]/g, '');
                            validateInputs();
                        };
                    }
                    validateInputs();
                } else {
                    hostControls.classList.add("hidden");
                    if (btnContainer) btnContainer.innerHTML = "";
                    const hostPlayer = state.players[state.hostId];
                    const hostName = hostPlayer ? hostPlayer.name : "Host";
                    const waitMessage = document.getElementById("wait-message");
                    if (waitMessage) {
                        waitMessage.classList.remove("hidden");
                        waitMessage.innerText = `${t("waitForHost")} (${hostName})`;
                    }
                }
            }

            validateInputs() {
                const name = document.getElementById("player-name-input").value.trim();
                const room = document.getElementById("room-id-input").value.trim();
                const errEl = document.getElementById("room-error");
                if (name.length < 2 || name.length > 10) {
                    errEl.innerText = t("error_nickname");
                    return null;
                }
                if (room.length < 1 || room.length > 20) {
                    errEl.innerText = t("error_room_id");
                    return null;
                }
                localPlayerName = name;
                errEl.innerText = "";
                return room;
            }

            async createRoom() {
                const roomId = this.validateInputs();
                if (!roomId) return;
                this.disableRoomButtons(true);

                try {
                    // Check existence and liveness via Supabase
                    const { data: existing, error } = await supabase
                        .from('rooms')
                        .select('*')
                        .eq('id', roomId)
                        .maybeSingle();

                    if (existing) {
                        const lastActiveTime = new Date(existing.last_active).getTime();
                        if (Date.now() - lastActiveTime > 30000) {
                            // Dead room, cleanup
                            await supabase.from('rooms').delete().eq('id', roomId);
                        } else {
                            document.getElementById("room-error").innerText = t("error_game_started");
                            this.disableRoomButtons(false);
                            return;
                        }
                    }

                    const newPlayer = {
                        uid: this.localUserId,
                        id: 0,
                        name: localPlayerName,
                        chips: 2000,
                        holeCards: [],
                        folded: false,
                        currentBet: 0,
                        accumulatedBet: 0,
                        status: "waiting"
                    };
                    const initialState = {
                        status: "waiting",
                        hostId: this.localUserId,
                        // lastActive is now handled by SQL column mostly, but we keep it for logic consistency
                        lastActive: Date.now(),
                        config: { initialChips: 2000, smallBlind: 10, bigBlind: 20 },
                        players: { [this.localUserId]: newPlayer },
                        playerOrder: [this.localUserId],
                        spectators: [],
                        communityCards: [],
                        pot: 0,
                        dealerIndex: 0,
                        currentPlayerIndex: -1,
                        currentMaxBet: 0,
                        phase: "waiting",
                        lastRaiseAmount: 20,
                        deck: [],
                        spectators: [],
                        logs: [createLog("log_create", { name: localPlayerName })],
                        highlightWinner: null,
                        highlightCards: [],
                        nextRoundTimer: 0,
                        nextPhaseTimer: 0,
                    };

                    const { error: insertError } = await supabase
                        .from('rooms')
                        .insert({ id: roomId, game_state: initialState }); // last_active defaults to now()

                    if (insertError) throw insertError;

                    this.stopRoomAutoRefresh();
                    this.subscribeToRoom(roomId);
                } catch (error) {
                    console.error(error);
                    document.getElementById("room-error").innerText = "Create failed";
                    this.disableRoomButtons(false);
                }
            }

            async joinRoom() {
                const roomId = this.validateInputs();
                if (!roomId) return;
                this.disableRoomButtons(true);

                try {
                    const { data: roomRow, error } = await supabase
                        .from('rooms')
                        .select('*')
                        .eq('id', roomId)
                        .maybeSingle();

                    if (!roomRow) throw new Error("Room not found");

                    // 检查死房间
                    const lastActiveTime = new Date(roomRow.last_active).getTime();
                    if (Date.now() - lastActiveTime > 60000) { // 60秒无心跳视为死房间
                        await supabase.from('rooms').delete().eq('id', roomId);
                        throw new Error("ROOM_IS_DEAD");
                    }

                    let state = roomRow.game_state;
                    let isSpectator = false;

                    // 已经在玩家列表中
                    if (state.players[this.localUserId]) {
                        if (state.status === "waiting") {
                            state.players[this.localUserId].chips = 2000;
                            state.players[this.localUserId].status = "waiting";
                        }
                    } else {
                        // 新加入逻辑
                        if (state.status !== "waiting") {
                            // --- 关键修改：游戏进行中，加入旁观者列表 ---
                            isSpectator = true;
                            if (!state.spectators) state.spectators = [];

                            // 检查是否已经在旁观列表中 (使用 some 检查对象)
                            const alreadySpec = state.spectators.some(s => s.uid === this.localUserId);

                            if (!alreadySpec) {
                                // 【改动点】存入对象，包含 name
                                state.spectators.push({
                                    uid: this.localUserId,
                                    name: localPlayerName
                                });
                                state.logs.push(createLog("log_join", { name: localPlayerName + " (Spec)" }));
                            }
                        } else {
                            // 正常加入游戏
                            if (Object.keys(state.players).length >= 10) throw new Error(t("error_room_full"));

                            const newPlayer = {
                                uid: this.localUserId,
                                id: Object.keys(state.players).length,
                                name: localPlayerName,
                                chips: 2000,
                                holeCards: [],
                                folded: false,
                                currentBet: 0,
                                accumulatedBet: 0,
                                status: "waiting"
                            };
                            state.players[this.localUserId] = newPlayer;
                            state.playerOrder.push(this.localUserId);
                            state.logs.push(createLog("log_join", { name: localPlayerName }));
                        }
                    }

                    const { error: updateError } = await supabase
                        .from('rooms')
                        .update({ game_state: state })
                        .eq('id', roomId);

                    if (updateError) throw updateError;

                    this.stopRoomAutoRefresh();
                    this.subscribeToRoom(roomId);

                    // 如果是旁观者，提示用户
                    if (isSpectator) {
                        setTimeout(() => gameUI.showMessage(t('spectatorModeMsg')), 1000);
                    }

                } catch (error) {
                    if (error.message.includes("ROOM_IS_DEAD")) {
                        document.getElementById("room-error").innerText = t("error_room_dead");
                    } else {
                        document.getElementById("room-error").innerText = error.message || t("error_join_fail");
                    }
                    this.disableRoomButtons(false);
                }
            }

            async leaveRoom() {
                this.stopHeartbeat();
                if (this.realtimeChannel) {
                    supabase.removeChannel(this.realtimeChannel);
                    this.realtimeChannel = null;
                }

                const roomId = this.currentRoomId;
                const userId = this.localUserId;

                if (roomId && userId) {
                    try {
                        const { data: roomRow } = await supabase.from('rooms').select('*').eq('id', roomId).maybeSingle();
                        if (roomRow) {
                            let state = roomRow.game_state;

                            // 检查是否是玩家
                            if (state.players[userId]) {
                                const playerName = state.players[userId].name;
                                delete state.players[userId];
                                state.playerOrder = state.playerOrder.filter((uid) => uid !== userId);
                                state.logs.push(createLog("log_leave", { name: playerName }));

                                // 主机转移等原逻辑...
                                if (state.playerOrder.length === 0) {
                                    await supabase.from('rooms').delete().eq('id', roomId);
                                } else {
                                    if (state.status === 'playing' && state.playerOrder.length < 2) {
                                        // 重置游戏逻辑 (保持原样)
                                        state.status = 'waiting';
                                        state.phase = 'waiting';
                                        state.pot = 0;
                                        state.communityCards = [];
                                        state.currentMaxBet = 0;
                                        state.currentPlayerIndex = -1;
                                        state.dealerIndex = 0;
                                        state.logs.push(createLog("log_round_end_no_winner"));

                                        // 恢复所有玩家状态
                                        state.playerOrder.forEach(uid => {
                                            if (state.players[uid]) {
                                                state.players[uid].chips = 2000;
                                                state.players[uid].holeCards = [];
                                                state.players[uid].folded = false;
                                                state.players[uid].currentBet = 0;
                                                state.players[uid].accumulatedBet = 0;
                                                state.players[uid].status = "waiting";
                                            }
                                        });
                                    }
                                    if (state.hostId === userId) {
                                        state.hostId = state.playerOrder[0];
                                        state.logs.push(createLog("log_host_change", { name: state.players[state.hostId].name }));
                                    }
                                    await supabase.from('rooms').update({ game_state: state }).eq('id', roomId);
                                }
                            }
                            // 检查是否是旁观者
                            else if (state.spectators && state.spectators.some(s => s.uid === userId)) {
                                // 【改动点】使用 filter 过滤对象
                                state.spectators = state.spectators.filter(s => s.uid !== userId);
                                await supabase.from('rooms').update({ game_state: state }).eq('id', roomId);
                            }
                        }
                    } catch (e) { console.error(e); }
                }

                this.currentRoomId = null;
                // ...清理定时器等逻辑 (保持原样)
                this.gameUI.bankruptcyScreenShown = false;
                document.getElementById("game-area").classList.add("hidden");
                document.getElementById("room-screen").classList.remove("hidden");
                this.disableRoomButtons(false);

                // 离开房间回到大厅时刷新列表
                this.startRoomAutoRefresh();
            }

            startHeartbeat(roomId) {
                this.stopHeartbeat();
                this.heartbeatInterval = setInterval(async () => {
                    if (!this.currentRoomId || !this.localUserId) return;
                    const state = this.gameUI.lastState;
                    if (state && state.hostId === this.localUserId) {
                        // Heartbeat: Only update the timestamp column to avoid heavy JSON write conflicts
                        try {
                            await supabase
                                .from('rooms')
                                .update({ last_active: new Date().toISOString() })
                                .eq('id', roomId);
                        } catch (e) { }
                    }
                }, 5000);
            }

            stopHeartbeat() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
            }

            subscribeToRoom(roomId) {
                this.currentRoomId = roomId;
                document.getElementById("display-room-id").innerText = roomId;
                document.getElementById("room-screen").classList.add("hidden");
                document.getElementById("game-area").classList.remove("hidden");
                this.gameUI.initSound();
                this.gameUI.occlusionManager.start();
                this.startHeartbeat(roomId);

                // Initial Fetch
                supabase.from('rooms').select('*').eq('id', roomId).maybeSingle()
                    .then(({ data }) => {
                        if (data) {
                            this.gameUI.renderGameState(data.game_state, this.localUserId);
                            this.runHostTimerController(data.game_state);
                        }
                    });

                // Supabase Realtime Subscription
                this.realtimeChannel = supabase
                    .channel(`room_${roomId}`)
                    .on('postgres_changes', { event: '*', schema: 'public', table: 'rooms', filter: `id=eq.${roomId}` }, (payload) => {
                        if (payload.eventType === 'DELETE') {
                            this.gameUI.showMessage("Room closed");
                            setTimeout(() => this.leaveRoom(), 2000);
                        } else {
                            // ✅ 新增：如果没有 new 对象，或者 new 对象里没有 game_state，直接忽略
                            if (!payload.new || !payload.new.game_state) {
                                return;
                            }

                            const newState = payload.new.game_state;

                            // (建议) 这里也可以加上之前说的防抖逻辑，防止重复刷新
                            // if (this.gameUI.lastState && JSON.stringify(this.gameUI.lastState) === JSON.stringify(newState)) return;

                            this.gameUI.renderGameState(newState, this.localUserId);
                            this.runHostTimerController(newState);
                        }
                    })
                    .subscribe();
            }

            runHostTimerController(state) {
                if (state.nextPhaseTimer > 0 && state.hostId === this.localUserId) {
                    if (!this.nextPhaseTimeout) {
                        this.nextPhaseTimeout = setTimeout(async () => {
                            this.nextPhaseTimeout = null;
                            // Re-fetch to get latest before update
                            const { data } = await supabase.from('rooms').select('game_state').eq('id', this.currentRoomId).maybeSingle();
                            if (data) {
                                let cur = data.game_state;
                                if (cur.nextPhaseTimer > 0) {
                                    cur.nextPhaseTimer = 0;
                                    const next = runAutoShowdown(cur);
                                    await supabase.from('rooms').update({ game_state: next }).eq('id', this.currentRoomId);
                                }
                            }
                        }, state.nextPhaseTimer);
                    }
                } else if (state.nextPhaseTimer === 0 && this.nextPhaseTimeout) {
                    clearTimeout(this.nextPhaseTimeout);
                    this.nextPhaseTimeout = null;
                }

                if (state.phase === "showdown" && state.hostId === this.localUserId) {
                    if (state.nextRoundTimer > 0 && !this.nextRoundTimeout) {
                        this.nextRoundTimeout = setTimeout(async () => {
                            this.nextRoundTimeout = null;
                            const { data } = await supabase.from('rooms').select('game_state').eq('id', this.currentRoomId).maybeSingle();
                            if (data) {
                                const cur = data.game_state;
                                if (cur.phase === "showdown") {
                                    const next = startNewRound(cur);
                                    await supabase.from('rooms').update({ game_state: next }).eq('id', this.currentRoomId);
                                }
                            }
                        }, state.nextRoundTimer);
                    }
                }
            }

            async startGame() {
                if (!this.currentRoomId || !this.gameUI.lastState) return;
                if (this.localUserId !== this.gameUI.lastState.hostId) return;

                const chipsInput = document.getElementById("setting-initial-chips");
                const blindInput = document.getElementById("setting-big-blind");
                let newInitChips = chipsInput ? parseInt(chipsInput.value) : 2000;
                let newBigBlind = blindInput ? parseInt(blindInput.value) : 20;

                newInitChips = Math.floor(newInitChips);
                newBigBlind = Math.floor(newBigBlind);

                if (newBigBlind < 2 || newBigBlind % 2 !== 0) return;
                if (newInitChips <= newBigBlind) return;

                const btn = document.getElementById("btn-start-game");
                if (!btn || this.gameUI.lastState.playerOrder.length < 2) return;

                btn.disabled = true;

                try {
                    const currentState = this.gameUI.lastState;
                    if (currentState.status !== "waiting") return;

                    currentState.config = {
                        initialChips: newInitChips,
                        bigBlind: newBigBlind,
                        smallBlind: Math.floor(newBigBlind / 2)
                    };

                    Object.keys(currentState.players).forEach(uid => {
                        currentState.players[uid].chips = newInitChips;
                        currentState.players[uid].currentBet = 0;
                    });

                    // Shuffle seating
                    for (let i = currentState.playerOrder.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [currentState.playerOrder[i], currentState.playerOrder[j]] = [currentState.playerOrder[j], currentState.playerOrder[i]];
                    }

                    currentState.status = "playing";
                    const nextState = startNewRound(currentState);
                    await supabase.from('rooms').update({ game_state: nextState }).eq('id', this.currentRoomId);

                } catch (error) {
                    btn.disabled = false;
                    this.gameUI.showMessage("Start failed");
                }
            }

            async handleHumanAction(action) {
                const state = this.gameUI.lastState;
                if (!state || state.playerOrder[state.currentPlayerIndex] !== this.localUserId) return;

                this.gameUI.updateControls({ ...state, currentPlayerIndex: -1 });
                let actionAmount = 0;
                if (action === "raise") {
                    const slider = document.getElementById("raise-slider");
                    if (slider) actionAmount = parseInt(slider.value);
                }

                try {
                    // Read latest state to ensure valid move
                    const { data } = await supabase.from('rooms').select('game_state').eq('id', this.currentRoomId).maybeSingle();
                    if (!data) throw new Error("Room missing");

                    const currentState = data.game_state;
                    if (currentState.playerOrder[currentState.currentPlayerIndex] !== this.localUserId) return;

                    let totalAmount = 0;
                    const player = currentState.players[this.localUserId];
                    if (action === "raise") totalAmount = player.currentBet + actionAmount;

                    const nextState = processAction(currentState, this.localUserId, action, totalAmount);
                    await supabase.from('rooms').update({ game_state: nextState }).eq('id', this.currentRoomId);

                } catch (error) {
                    console.error(error);
                    this.gameUI.showMessage("Action failed");
                    if (this.gameUI.lastState && this.localUserId) {
                        this.gameUI.updateControls(this.gameUI.lastState);
                    }
                }
            }

            disableRoomButtons(disabled) {
                document.getElementById("btn-join-room").disabled = disabled;
                document.getElementById("btn-create-room").disabled = disabled;
                const method = disabled ? "add" : "remove";
                document.getElementById("btn-join-room").classList[method]("btn-disabled");
                document.getElementById("btn-create-room").classList[method]("btn-disabled");
            }
        }

        class SoundManager {
            constructor() {
                this.ctx = null;
                this.enabled = false;
            }

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.enabled = true;
                    const resumeAudio = () => {
                        if (this.ctx && this.ctx.state === "suspended") {
                            this.ctx.resume();
                        }
                    };
                    document.addEventListener("click", resumeAudio);
                    document.addEventListener("touchstart", resumeAudio);
                }
                if (this.ctx.state === "suspended") {
                    this.ctx.resume();
                }
            }

            playTone(freq, type, duration, vol = 0.1, when = 0) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + when);

                gain.gain.setValueAtTime(vol, this.ctx.currentTime + when);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + when + duration);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start(this.ctx.currentTime + when);
                osc.stop(this.ctx.currentTime + when + duration);
            }

            playChip() {
                this.playTone(2000, "square", 0.05, 0.03);
            }

            playCard() {
                this.playTone(800, "sine", 0.1, 0.02);
            }

            playCheck() {
                this.playTone(300, "sine", 0.05, 0.1);
                this.playTone(300, "sine", 0.05, 0.1, 0.1);
            }

            playFold() {
                this.playTone(150, "triangle", 0.3, 0.1);
            }

            playAllIn() {
                if (!this.enabled) return;
                const t = this.ctx.currentTime;
                this.playTone(100, "sawtooth", 0.4, 0.4, 0);
                this.playTone(50, "square", 1.0, 0.5, 0.1);

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = "triangle";
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.3);

                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.3);
            }

            playRaise() {
                this.playTone(1500, "square", 0.08, 0.04);
                this.playTone(1000, "square", 0.08, 0.04, 0.05);
            }

            playHandEnd() {
                this.playTone(440, "sine", 0.2, 0.1);
            }

            playWin() {
                [523, 659, 784, 1046].forEach((f, i) => this.playTone(f, "triangle", 0.4, 0.15, i * 0.15));
            }

            playLose() {
                this.playTone(100, "sawtooth", 1.0, 0.2);
                this.playTone(80, "sawtooth", 1.0, 0.2, 0.3);
            }
        }

        class OcclusionManager {
            constructor() {
                this.communityArea = document.getElementById("community-area");
                this.gameMessage = document.getElementById("game-message");
                this.isRunning = false;
                this.checkLoop = null;
            }

            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.checkLoop = setInterval(() => this.check(), 100);
            }

            stop() {
                this.isRunning = false;
                clearInterval(this.checkLoop);
            }

            getOverlapRatio(r1, r2) {
                if (!r1 || !r2) return 0;
                const overlapLeft = Math.max(r1.left, r2.left);
                const overlapRight = Math.min(r1.right, r2.right);
                const overlapTop = Math.max(r1.top, r2.top);
                const overlapBottom = Math.min(r1.bottom, r2.bottom);

                if (overlapLeft >= overlapRight || overlapTop >= overlapBottom) return 0;

                const overlapArea = (overlapRight - overlapLeft) * (overlapBottom - overlapTop);
                const area1 = r1.width * r1.height;
                const area2 = r2.width * r2.height;
                return overlapArea / Math.min(area1, area2);
            }

            check() {
                const seats = document.querySelectorAll(".player-seat");
                if (seats.length === 0) return;

                const cardTargets = [];
                seats.forEach((seat) => {
                    const cardsDiv = seat.querySelector('div[id^="cards-"]');
                    if (cardsDiv && cardsDiv.children.length > 0) {
                        cardTargets.push(cardsDiv.getBoundingClientRect());
                    }
                });

                const commRect = this.communityArea.getBoundingClientRect();
                if (commRect.width > 10 && commRect.height > 10) {
                    let commObstructed = false;
                    for (const targetRect of cardTargets) {
                        if (this.getOverlapRatio(targetRect, commRect) > 0.2) {
                            commObstructed = true;
                            break;
                        }
                    }
                    if (!commObstructed) {
                        seats.forEach((seat) => {
                            const infoBox = seat.querySelector(".player-info-box");
                            if (infoBox) {
                                if (this.getOverlapRatio(infoBox.getBoundingClientRect(), commRect) > 0.2) {
                                    commObstructed = true;
                                }
                            }
                        });
                    }
                    this.applyTransparency(this.communityArea, commObstructed);
                } else {
                    this.applyTransparency(this.communityArea, false);
                }

                if (this.gameMessage && this.gameMessage.style.opacity !== "0") {
                    let msgObstructed = false;
                    const msgRect = this.gameMessage.getBoundingClientRect();
                    if (commRect.width > 10 && commRect.height > 10) {
                        if (this.getOverlapRatio(msgRect, commRect) > 0.2) msgObstructed = true;
                    }
                    if (!msgObstructed) {
                        for (const targetRect of cardTargets) {
                            if (this.getOverlapRatio(msgRect, targetRect) > 0.2) {
                                msgObstructed = true;
                                break;
                            }
                        }
                    }
                    this.applyTransparency(this.gameMessage, msgObstructed);
                }
            }

            applyTransparency(el, shouldBeTransparent) {
                if (shouldBeTransparent) {
                    if (!el.classList.contains("smart-transparent")) el.classList.add("smart-transparent");
                } else {
                    if (el.classList.contains("smart-transparent")) el.classList.remove("smart-transparent");
                }
            }
        }

        class TableDragSystem {
            constructor() {
                this.container = document.getElementById("table-area");
                this.table = document.getElementById("table");
                this.isDragging = false;
                this.startY = 0;
                this.currentY = 30;
                this.initialDragY = 0;
                this.init();
            }

            init() {
                this.container.addEventListener("mousedown", this.onStart.bind(this));
                window.addEventListener("mousemove", this.onMove.bind(this));
                window.addEventListener("mouseup", this.onEnd.bind(this));

                this.container.addEventListener("touchstart", this.onStart.bind(this), { passive: false });
                window.addEventListener("touchmove", this.onMove.bind(this), { passive: false });
                window.addEventListener("touchend", this.onEnd.bind(this));

                this.updateTransform();
            }

            onStart(e) {
                if (e.target.closest("button") || e.target.closest("input")) return;
                this.isDragging = true;
                this.startY = this.getY(e);
                this.initialDragY = this.currentY;

                this.table.classList.remove("duration-500");
                this.table.classList.add("duration-0");
                this.container.classList.add("cursor-grabbing");
                this.container.classList.remove("cursor-grab");
            }

            onMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                const y = this.getY(e);
                const diff = y - this.startY;
                this.currentY = this.initialDragY + diff;

                if (this.currentY > 180) this.currentY = 180;
                if (this.currentY < -120) this.currentY = -120;

                this.updateTransform();
                if (window.occlusionManager) window.occlusionManager.check();
            }

            onEnd() {
                if (!this.isDragging) return;
                this.isDragging = false;
                this.table.classList.remove("duration-0");
                this.table.classList.add("duration-500");
                this.container.classList.remove("cursor-grabbing");
                this.container.classList.add("cursor-grab");
            }

            getY(e) {
                return e.touches ? e.touches[0].clientY : e.clientY;
            }

            updateTransform() {
                this.table.style.transform = `translateY(${this.currentY}px)`;
            }
        }

        class HandEvaluator {
            static evaluate(holeCards, communityCards) {
                if (!holeCards || holeCards.length === 0) {
                    return { score: 0, name: "hand_high_card", bestCards: [] };
                }

                const all = [
                    ...holeCards.map((c) => ({ ...c, isHole: true })),
                    ...communityCards.map((c) => ({ ...c, isHole: false }))
                ];

                all.sort((a, b) => {
                    if (b.value !== a.value) return b.value - a.value;
                    return b.isHole - a.isHole;
                });

                const getKickers = (excludeCards, count) => {
                    const kickers = [];
                    const excludeIds = new Set(excludeCards.map((c) => c.id));
                    for (const c of all) {
                        if (!excludeIds.has(c.id)) {
                            kickers.push(c);
                            if (kickers.length === count) break;
                        }
                    }
                    return kickers;
                };

                const calcScore = (rankVal, mainCards, kickers) => {
                    let s = rankVal * Math.pow(100, 5);
                    mainCards.forEach((c, i) => { s += c.value * Math.pow(100, 4 - i); });
                    kickers.forEach((c, i) => { s += c.value * Math.pow(100, 4 - mainCards.length - i); });
                    return s;
                };

                const suits = {};
                all.forEach((c) => {
                    if (!suits[c.suit]) suits[c.suit] = [];
                    suits[c.suit].push(c);
                });

                let flushCards = null;
                for (let s in suits) {
                    if (suits[s].length >= 5) {
                        flushCards = suits[s].slice(0, 5);
                        break;
                    }
                }

                const getStraightCards = (cardsToCheck) => {
                    const uniqueVals = [...new Set(cardsToCheck.map((c) => c.value))].sort((a, b) => b - a);

                    if (uniqueVals.includes(14) && uniqueVals.includes(5) && uniqueVals.includes(4) && uniqueVals.includes(3) && uniqueVals.includes(2)) {
                        const straightVals = [5, 4, 3, 2, 14];
                        const best5 = [];
                        const usedIds = new Set();

                        straightVals.forEach((v) => {
                            const card = cardsToCheck.find((c) => c.value === v && !usedIds.has(c.id));
                            if (card) {
                                best5.push(card);
                                usedIds.add(card.id);
                            }
                        });
                        if (best5.length === 5) return { cards: best5, high: 5 };
                    }

                    for (let i = 0; i <= uniqueVals.length - 5; i++) {
                        if (uniqueVals[i] - uniqueVals[i + 4] === 4) {
                            const straightVals = uniqueVals.slice(i, i + 5);
                            const best5 = [];
                            const usedIds = new Set();

                            straightVals.forEach((v) => {
                                const card = cardsToCheck.find((c) => c.value === v && !usedIds.has(c.id));
                                if (card) {
                                    best5.push(card);
                                    usedIds.add(card.id);
                                }
                            });
                            if (best5.length === 5) return { cards: best5, high: uniqueVals[i] };
                        }
                    }
                    return null;
                };

                if (flushCards) {
                    const sf = getStraightCards(flushCards);
                    if (sf) {
                        return {
                            score: calcScore(9, [sf.cards[0]], []),
                            name: "hand_straight_flush",
                            bestCards: sf.cards
                        };
                    }
                }

                const counts = {};
                all.forEach((c) => (counts[c.value] = (counts[c.value] || 0) + 1));

                const fours = Object.keys(counts).filter((v) => counts[v] === 4).map(Number).sort((a, b) => b - a);
                const threes = Object.keys(counts).filter((v) => counts[v] === 3).map(Number).sort((a, b) => b - a);
                const pairs = Object.keys(counts).filter((v) => counts[v] === 2).map(Number).sort((a, b) => b - a);

                if (fours.length > 0) {
                    const fourVal = fours[0];
                    const quadCards = all.filter((c) => c.value === fourVal);
                    const kicker = getKickers(quadCards, 1);
                    return {
                        score: calcScore(8, [quadCards[0]], kicker),
                        name: "hand_four_of_a_kind",
                        bestCards: [...quadCards, ...kicker]
                    };
                }

                if (threes.length > 0 && (threes.length > 1 || pairs.length > 0)) {
                    const threeVal = threes[0];
                    const pairVal = threes.length > 1 ? threes[1] : pairs[0];
                    const threeCards = all.filter((c) => c.value === threeVal).slice(0, 3);
                    const pairCards = all.filter((c) => c.value === pairVal).slice(0, 2);
                    return {
                        score: calcScore(7, [threeCards[0], pairCards[0]], []),
                        name: "hand_full_house",
                        bestCards: [...threeCards, ...pairCards]
                    };
                }

                if (flushCards) {
                    return {
                        score: calcScore(6, flushCards, []),
                        name: "hand_flush",
                        bestCards: flushCards
                    };
                }

                const straight = getStraightCards(all);
                if (straight) {
                    return {
                        score: calcScore(5, [straight.cards[0]], []),
                        name: "hand_straight",
                        bestCards: straight.cards
                    };
                }

                if (threes.length > 0) {
                    const threeVal = threes[0];
                    const threeCards = all.filter((c) => c.value === threeVal).slice(0, 3);
                    const kickers = getKickers(threeCards, 2);
                    return {
                        score: calcScore(4, [threeCards[0]], kickers),
                        name: "hand_three_of_a_kind",
                        bestCards: [...threeCards, ...kickers]
                    };
                }

                if (pairs.length >= 2) {
                    const p1 = pairs[0];
                    const p2 = pairs[1];
                    const pair1Cards = all.filter((c) => c.value === p1).slice(0, 2);
                    const pair2Cards = all.filter((c) => c.value === p2).slice(0, 2);
                    const kicker = getKickers([...pair1Cards, ...pair2Cards], 1);
                    return {
                        score: calcScore(3, [pair1Cards[0], pair2Cards[0]], kicker),
                        name: "hand_two_pairs",
                        bestCards: [...pair1Cards, ...pair2Cards, ...kicker]
                    };
                }

                if (pairs.length === 1) {
                    const p1 = pairs[0];
                    const pairCards = all.filter((c) => c.value === p1).slice(0, 2);
                    const kickers = getKickers(pairCards, 3);
                    return {
                        score: calcScore(2, [pairCards[0]], kickers),
                        name: "hand_pair",
                        bestCards: [...pairCards, ...kickers]
                    };
                }

                const highCards = all.slice(0, 5);
                return {
                    score: calcScore(1, highCards, []),
                    name: "hand_high_card",
                    bestCards: highCards
                };
            }
        }

        const gameUI = new GameUIManager();
        const network = new NetworkManager(gameUI);
        window.network = network;
        window.gameUI = gameUI;
        network.init();
    </script>
</body>

</html>

