<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <!-- *** 修正: 改为 UTF-8 *** -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>德州扑克 (联机版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* ... existing styles ... */
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Black+Ops+One&family=Noto+Sans+JP:wght@500;700&display=swap");

      body {
        font-family: "Inter", "Noto Sans JP", "Microsoft YaHei", sans-serif;
        background-color: #111827;
        color: white;
        overflow: hidden;
        touch-action: none;
        user-select: none;
      }

      /* --- 卡牌样式 --- */
      .card {
        width: 42px;
        height: 60px;
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        position: relative;
        transition: transform 0.3s, box-shadow 0.3s;
        z-index: 10;
        border: 1px solid #e5e7eb;
      }
      @media (min-width: 768px) {
        .card {
          width: 56px;
          height: 78px;
          font-size: 20px;
          border-radius: 6px;
        }
      }
      .card.red {
        color: #dc2626;
      }
      .card.black {
        color: #1f2937;
      }
      .card-back {
        background: repeating-linear-gradient(
          45deg,
          #1e3a8a,
          #1e3a8a 10px,
          #172554 10px,
          #172554 20px
        );
        border: 2px solid #e2e8f0;
      }
      .card-back span {
        display: none;
      }

      /* --- 获胜牌高亮特效 --- */
      .card.winning-card {
        box-shadow: 0 0 15px 5px rgba(251, 191, 36, 0.9);
        border: 3px solid #fbbf24;
        z-index: 100;
      }

      /* --- 牌桌 --- */
      .poker-table {
        background: radial-gradient(
          circle,
          #15803d 0%,
          #064e3b 90%,
          #022c22 100%
        );
        box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.9), 0 0 0 12px #374151,
          0 0 0 16px #1f2937;
        position: relative;
        border-radius: 180px;
        transform: translateY(30px);
        will-change: transform;
      }

      .cursor-grab {
        cursor: grab;
      }
      .cursor-grabbing {
        cursor: grabbing;
      }

      .player-seat {
        position: absolute;
        transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.6s,
          top 0.6s;
        width: 120px;
        height: 110px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transform-origin: center center;
        pointer-events: none;
      }
      .player-seat > * {
        pointer-events: auto;
      }

      .player-info-box {
        background: linear-gradient(
          180deg,
          rgba(31, 41, 55, 0.95) 0%,
          rgba(17, 24, 39, 0.98) 100%
        );
        border: 1px solid #4b5563;
        border-radius: 6px;
        padding: 4px 2px;
        width: 100%;
        text-align: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
        position: relative;
      }

      .dealer-btn {
        width: 20px;
        height: 20px;
        background: radial-gradient(circle at 30% 30%, #fff, #cbd5e0);
        color: #1a202c;
        border-radius: 50%;
        font-size: 12px;
        font-weight: 900;
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: -8px;
        right: -6px;
        border: 1px solid #9ca3af;
        z-index: 30;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
      }

      .active-player .player-info-box {
        box-shadow: 0 0 0 2px #fbbf24, 0 0 20px rgba(251, 191, 36, 0.4);
        border-color: #f59e0b;
        background: linear-gradient(180deg, #374151 0%, #1f2937 100%);
        transform: translateY(-2px);
        z-index: 40;
      }

      .winner-highlight .player-info-box {
        box-shadow: 0 0 0 3px #22c55e, 0 0 30px rgba(34, 197, 94, 0.6);
        border-color: #22c55e;
        background: linear-gradient(180deg, #064e3b 0%, #065f46 100%);
        z-index: 50;
      }

      /* --- 聊天气泡样式 (移除) --- */

      /* --- All-in 特效 --- */
      .all-in-fullscreen-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.3);
        animation: fadeIn 0.2s ease-out;
      }
      .all-in-bar {
        position: absolute;
        top: 50%;
        left: 0;
        width: 100%;
        height: 140px;
        background: rgba(0, 0, 0, 0.95);
        transform: translateY(-50%) translateX(-100%);
        animation: barSlideIn 0.4s cubic-bezier(0.05, 0.7, 0.1, 1) forwards;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        border-top: 2px solid rgba(234, 179, 8, 0.6);
        border-bottom: 2px solid rgba(234, 179, 8, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      @keyframes barSlideIn {
        from {
          transform: translateY(-50%) translateX(-100%);
        }
        to {
          transform: translateY(-50%) translateX(0%);
        }
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .all-in-text {
        position: relative;
        font-family: "Black Ops One", system-ui, sans-serif;
        font-size: 90px;
        white-space: nowrap;
        text-transform: uppercase;
        letter-spacing: 4px;
        background: linear-gradient(
          to bottom,
          #fef08a 0%,
          #eab308 45%,
          #a16207 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        filter: drop-shadow(0 5px 3px rgba(0, 0, 0, 0.5));
        text-shadow: 0 0 30px rgba(234, 179, 8, 0.6);
        opacity: 0;
        transform: scale(2);
        animation: textImpact 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
          forwards 0.2s;
      }
      @keyframes textImpact {
        0% {
          opacity: 0;
          transform: scale(2);
          filter: blur(10px);
        }
        100% {
          opacity: 1;
          transform: scale(1);
          filter: blur(0px);
        }
      }
      .all-in-bar::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 30%;
        height: 100%;
        background: linear-gradient(
          to right,
          transparent,
          rgba(255, 255, 255, 0.4),
          transparent
        );
        transform: skewX(-25deg);
        animation: shine 1s infinite 0.5s;
      }
      @keyframes shine {
        0% {
          left: -50%;
        }
        100% {
          left: 150%;
        }
      }

      input[type="range"]::-webkit-slider-thumb {
        background: #fbbf24;
      }
      .adjust-btn:active {
        transform: scale(0.95);
        background-color: #4b5563;
      }

      /* 智能透明类 */
      .smart-transparent {
        opacity: 0.15 !important;
        transition: opacity 0.2s ease-out;
        pointer-events: none;
      }

      /* --- 新增: Firebase 加载和房间选择界面 --- */
      .firebase-loader {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #111827;
        z-index: 10000;
      }
      .spinner {
        width: 48px;
        height: 48px;
        border: 4px solid #4b5563;
        border-top-color: #f59e0b;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #room-screen {
        z-index: 50;
        background: rgba(17, 24, 39, 0.95);
        backdrop-filter: blur(10px);
      }

      /* 按钮禁用样式 */
      .btn-disabled {
        background-color: #4b5563 !important;
        border-color: #374151 !important;
        color: #9ca3af !important;
        cursor: not-allowed !important;
        transform: none !important;
      }
    </style>
  </head>
  <body
    class="h-screen w-screen flex flex-col items-center justify-center bg-gray-950"
  >
    <!-- *** 新增: Firebase 加载动画 *** -->
    <div id="firebase-loader" class="firebase-loader">
      <div class="spinner"></div>
      <p class="text-gray-400 mt-4 text-sm font-medium">连接到游戏服务器...</p>
    </div>

    <!-- *** 修改: 启动页改为房间选择页 *** -->
    <div
      id="room-screen"
      class="hidden absolute z-50 bg-gray-900 p-8 rounded-xl shadow-2xl border border-gray-700 w-11/12 max-w-md"
    >
      <h1 class="text-3xl font-bold text-yellow-500 mb-6 tracking-tight">
        联机对战
      </h1>

      <!-- *** 修复: 移除了 AI 玩家列表 (它们现在在等待室) *** -->

      <div class="mb-4">
        <label
          class="block text-gray-400 mb-2 text-sm font-bold"
          for="player-name-input"
          >你的昵称</label
        >
        <input
          type="text"
          id="player-name-input"
          class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
          placeholder="例如: 赌神"
        />
      </div>
      <div class="mb-6">
        <label
          class="block text-gray-400 mb-2 text-sm font-bold"
          for="room-id-input"
          >房间 ID</label
        >
        <input
          type="text"
          id="room-id-input"
          class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
          placeholder="输入房间ID (例如: 888)"
        />
      </div>
      <div class="flex space-x-4 mb-4">
        <button
          onclick="network.joinRoom()"
          id="btn-join-room"
          class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1"
        >
          加入房间
        </button>
        <button
          onclick="network.createRoom()"
          id="btn-create-room"
          class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1"
        >
          创建房间
        </button>
      </div>
      <p id="room-error" class="text-red-400 text-sm h-5"></p>
      <p class="text-gray-500 text-xs mt-4">
        你的 User ID: <span id="user-id-display">...</span>
      </p>
    </div>

    <!-- 结束页 -->
    <div
      id="game-over-screen"
      class="hidden absolute z-[60] bg-black bg-opacity-95 w-full h-full flex flex-col items-center justify-center text-center"
    >
      <h2 id="game-over-title" class="text-6xl font-black mb-4 text-white">
        游戏结束
      </h2>
      <p id="game-over-msg" class="text-xl text-gray-400 mb-8">...</p>
      <!-- *** 修改: 按钮改为 "返回大厅" *** -->
      <!-- *** 再次修改: 变为按钮容器 (请求 #3) *** -->
      <div id="game-over-buttons" class="flex space-x-4">
        <button
          onclick="network.leaveRoom()"
          class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg"
        >
          返回大厅
        </button>
        <!-- 观战按钮将由JS动态添加 -->
      </div>
    </div>

    <!-- 游戏主界面 -->
    <div id="game-area" class="hidden w-full h-full relative flex flex-col">
      <!-- *** 修改: 恢复了盲注和玩家计数UI *** -->
      <div
        id="top-bar"
        class="h-16 bg-gray-900 w-full flex items-center justify-between px-6 shadow-lg z-10 border-b border-gray-800 relative z-50"
      >
        <!-- Left Side: Pot -->
        <div class="flex items-center space-x-2">
          <div class="text-yellow-500 font-black text-2xl tracking-tight">
            底池: $<span id="pot-display">0</span>
          </div>
        </div>

        <!-- *** 修复: 移除了 host-controls, 它现在在等待室遮罩中 *** -->

        <!-- Right Side: Info & Leave Button -->
        <div class="flex items-center space-x-4">
          <!-- *** 恢复的逻辑: 盲注和玩家计数 *** -->
          <div class="text-right hidden sm:block">
            <!-- 在小屏幕上隐藏以避免混乱 -->
            <div class="text-gray-400 text-xs font-bold tracking-wider">
              盲注 $10/$20
            </div>
            <div class="text-gray-600 text-[10px]">
              在线玩家: <span id="active-players-count">0</span>
            </div>
          </div>
          <!-- *** 结束 *** -->
          <button
            id="btn-leave-room"
            onclick="network.leaveRoom()"
            class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-2 px-4 rounded-lg text-xs shadow-md"
          >
            退出房间
          </button>
        </div>
      </div>
      <!-- *** 结束修改 *** -->

      <div
        id="table-area"
        class="flex-grow relative overflow-hidden flex items-center justify-center bg-gray-950 cursor-grab active:cursor-grabbing"
      >
        <div
          id="table"
          class="poker-table w-[95vw] h-[55vh] md:w-[800px] md:h-[450px] max-w-full relative transition-all duration-500"
        >
          <div
            id="community-area"
            class="absolute top-[42%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 flex flex-col items-center space-y-2 z-20 transition-opacity duration-200"
          >
            <div
              id="community-cards"
              class="flex flex-col items-center space-y-2"
            ></div>
          </div>
          <div
            id="game-message"
            class="absolute top-[23%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-yellow-100 font-bold text-xl text-center z-30 pointer-events-none drop-shadow-lg px-4 py-2 rounded whitespace-nowrap transition-opacity duration-300 opacity-0"
          ></div>
          <div id="seats-container" class="w-full h-full relative"></div>
        </div>
      </div>

      <div
        id="bottom-bar"
        class="bg-gray-900 p-4 shadow-[0_-5px_15px_rgba(0,0,0,0.5)] z-20 border-t border-gray-800 relative z-50"
      >
        <div
          id="game-log"
          class="h-16 overflow-y-auto text-xs text-gray-500 mb-3 font-mono bg-gray-950 p-2 rounded border border-gray-800 scroll-smooth leading-5"
        >
          <div class="text-green-600">系统: 欢迎游玩德州扑克。</div>
        </div>
        <div
          id="player-controls"
          class="flex flex-col items-center opacity-50 pointer-events-none transition-all duration-300 transform translate-y-2"
        >
          <div
            id="raise-slider-container"
            class="w-full max-w-md mb-4 flex items-center space-x-2 px-2"
          >
            <span
              class="text-xs text-gray-500 font-bold tracking-wider w-8 text-center"
              >加注</span
            >
            <button
              onclick="gameUI.adjustRaise(-1)"
              class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700"
            >
              -
            </button>
            <input
              type="range"
              id="raise-slider"
              step="1"
              class="flex-grow h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mx-2"
            />
            <button
              onclick="gameUI.adjustRaise(1)"
              class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700"
            >
              +
            </button>
            <span
              id="raise-val-display"
              class="text-sm text-yellow-400 w-14 text-right font-mono font-bold"
              >$0</span
            >
          </div>
          <div class="flex justify-center space-x-3 w-full max-w-lg">
            <!-- *** 修改: onclick 事件 *** -->
            <button
              onclick="network.handleHumanAction('fold')"
              class="flex-1 bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-gray-900 active:border-b-0 active:translate-y-1"
            >
              弃牌
            </button>
            <button
              onclick="network.handleHumanAction('check')"
              id="btn-check"
              class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1"
            >
              过牌
            </button>
            <button
              onclick="network.handleHumanAction('call')"
              id="btn-call"
              class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1 hidden"
            >
              跟注
            </button>
            <button
              onclick="network.handleHumanAction('raise')"
              id="btn-raise"
              class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1"
            >
              加注
            </button>
          </div>
        </div>
        <div
          class="text-center mt-2 text-gray-700 text-[10px] font-mono tracking-wider"
        >
          阶段: <span id="phase-display" class="text-gray-500">等待中</span>
        </div>
      </div>

      <!-- *** 新增: 等待室遮罩 (用于显示玩家列表和 AI 控制) *** -->
      <div
        id="waiting-room-overlay"
        class="hidden absolute top-0 left-0 w-full h-full bg-gray-900 bg-opacity-90 z-40 flex flex-col items-center justify-center p-8"
      >
        <div
          class="bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-700 w-full max-w-md"
        >
          <h2 class="text-2xl font-bold text-yellow-500 mb-4 text-center">
            等待中...
          </h2>
          <p id="wait-message" class="text-gray-400 text-sm text-center mb-4">
            等待房主开始游戏
          </p>

          <div class="mb-4">
            <label class="block text-gray-400 mb-2 text-sm font-bold"
              >房间内玩家 (<span id="wait-player-count">0</span>/10)</label
            >
            <div
              id="wait-player-list"
              class="max-h-48 overflow-y-auto bg-gray-900 p-3 rounded-md border border-gray-700 space-y-2"
            >
              <!-- 玩家列表将在这里动态生成 -->
            </div>
          </div>

          <!-- 仅房主可见 -->
          <div id="wait-host-controls" class="hidden flex flex-col space-y-3">
            <!-- *** 移除: AI 按钮 *** -->
            <button
              id="btn-start-game"
              onclick="network.startGame()"
              class="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-5 rounded-lg shadow-lg border-b-4 border-green-800 active:border-b-0 active:translate-y-1"
            >
              开始游戏
            </button>
          </div>
        </div>
      </div>
      <!-- *** 结束新增 *** -->
    </div>

    <!-- *** Firebase 模块导入
        *** -->
    <script type="module">
      // --- 导入 Firebase SDK ---
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
        onAuthStateChanged,
        signInWithCustomToken, // 确保导入
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        onSnapshot,
        runTransaction,
        deleteDoc,
        setLogLevel, // 导入 setLogLevel
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      // --- 游戏常量和工具函数 ---
      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
      const getRandomInt = (min, max) =>
        Math.floor(Math.random() * (max - min + 1)) + min;
      const SUITS = ["♠", "♥", "♣", "♦"];
      const RANKS = [
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "J",
        "Q",
        "K",
        "A",
      ];
      const RANK_VALUES = {
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        10: 10,
        J: 11,
        Q: 12,
        K: 13,
        A: 14,
      };
      const PHASE_NAME_MAP = {
        waiting: "等待中",
        preflop: "翻牌前",
        flop: "翻牌",
        turn: "转牌",
        river: "河牌",
        showdown: "摊牌",
      };
      const SMALL_BLIND = 10;
      const BIG_BLIND = 20;

      // --- 移除: AI 姓名库 ---

      // --- 移除: AI 台词库 ---

      // --- Firebase 全局变量 ---
      let db, auth, app;
      let localUserId = null;
      let localPlayerName = "玩家";
      let currentRoomId = null;
      let unsubscribeRoom = null; // 用于取消 Firestore 监听
      let sound; // 音效管理器

      // --- 你的 Firebase 配置 (已修改为使用环境变量) ---
      const firebaseConfig =
        typeof __firebase_config !== "undefined"
          ? JSON.parse(__firebase_config)
          : {
              // 本地测试的回退 (使用你之前提供的配置)
              apiKey: "AIzaSyBX_mHFj3VHsx6U38Ib9pDJWCrnlSlR_g4",
              authDomain: "texas-hold-em-poker-1.firebaseapp.com",
              projectId: "texas-hold-em-poker-1",
              storageBucket: "texas-hold-em-poker-1.firebasestorage.app",
              messagingSenderId: "401916350194",
              appId: "1:401916350194:web:2b38d3da714968c8cd0a6b",
              measurementId: "G-HRQ5N6G7KD",
            };

      // --- Canvas 运行环境特定的全局变量 (用于本地测试的回退) ---
      const appId =
        typeof __app_id !== "undefined" ? __app_id : "poker-game-test";
      const initialAuthToken =
        typeof __initial_auth_token !== "undefined"
          ? __initial_auth_token
          : null;

      // --- 核心：游戏逻辑处理器 (纯函数) ---
      // 这是一个纯函数，接收当前状态和动作，返回新状态
      // 这是联机版的核心，所有客户端都依赖这个函数来同步游戏状态
      function processAction(currentState, actingUserId, action, amount = 0) {
        // 复制一份新状态，避免修改原状态
        let newState = JSON.parse(JSON.stringify(currentState));
        let player = newState.players[actingUserId];

        // 1. 检查是否轮到该玩家
        const currentPlayerId =
          newState.playerOrder[newState.currentPlayerIndex];
        if (currentPlayerId !== actingUserId) {
          console.warn(
            `非法操作: ${actingUserId} 试图在 ${currentPlayerId} 的回合行动`
          );
          return currentState; // 返回原状态
        }

        // 2. 玩家已弃牌或All-in，不能行动
        if (
          player.folded ||
          (player.chips === 0 && newState.phase !== "waiting")
        ) {
          console.warn(`非法操作: ${actingUserId} 已经弃牌或All-in`);
          // 自动跳到下一位
          newState.currentPlayerIndex =
            (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
          return newState; // 返回跳过后的状态
        }

        const diff = newState.currentMaxBet - player.currentBet;
        let triggerAllInEffect = false;
        let logMsg = "";
        let actionContext = action; // 用于AI语音

        // 3. 处理玩家动作
        if (action === "fold") {
          player.folded = true;
          player.status = "弃牌";
          logMsg = `${player.name} 弃牌`;
          // *** 移除: sound.playFold() (请求 #1) ***
        } else if (action === "check") {
          // 只有在 diff 为 0 时才能 check
          if (diff > 0) {
            console.warn(`非法操作: ${player.name} 试图在需要跟注时过牌`);
            return currentState; // 非法操作，返回原状态
          }
          player.status = "过牌";
          logMsg = `${player.name} 过牌`;
          // *** 移除: sound.playCheck() (请求 #1) ***
        } else if (action === "call") {
          let callAmount = Math.min(diff, player.chips);
          let isAllIn = callAmount === player.chips && diff > 0;

          player.chips -= callAmount;
          player.currentBet += callAmount;
          newState.pot += callAmount;

          player.status = isAllIn ? "全押" : "跟注";
          logMsg = `${player.name} ${isAllIn ? "全押" : "跟注"} $${callAmount}`;
          if (isAllIn) {
            triggerAllInEffect = true;
            actionContext = "all_in";
          } else {
            // *** 移除: sound.playChip() (请求 #1) ***
          }
        } else if (action === "raise") {
          // amount 是玩家 *总共* 投入的金额
          let raiseAmount = amount - player.currentBet; // 本次额外投入的
          let actualAmount = amount; // 本次动作的总支付额

          // 验证加注
          // 1. 支付额必须 > 当前最大下注
          if (
            actualAmount <= newState.currentMaxBet &&
            actualAmount < player.chips
          ) {
            console.warn(
              `非法加注: $${actualAmount} 小于等于 $${newState.currentMaxBet}`
            );
            return currentState;
          }
          // 2. 加注额必须 >= 上次加注额 (除非是All-in)
          const extraRaise = actualAmount - newState.currentMaxBet;
          if (
            extraRaise < newState.lastRaiseAmount &&
            actualAmount < player.chips
          ) {
            console.warn(
              `非法加注: 额外加注 $${extraRaise} 小于最小加注 $${newState.lastRaiseAmount}`
            );
            return currentState;
          }

          // *** 错误修复:
          // *** 原始错误逻辑: let isAllIn = (actualAmount >= player.chips);
          // *** (actualAmount 是总下注额, player.chips 是剩余筹码, 导致在筹码和总下注额相等时错误触发All-in)
          // *** 正确逻辑: 检查 "本次支付的金额" 是否大于或等于 "剩余筹码"
          let isAllIn = raiseAmount >= player.chips;
          // *** 错误修复结束 ***

          if (isAllIn) {
            actualAmount = player.chips + player.currentBet; // 总投入等于所有筹码
            raiseAmount = player.chips; // 额外投入等于剩余筹码
            triggerAllInEffect = true;
            actionContext = "all_in";
          }

          // 更新玩家状态
          player.chips -= raiseAmount;
          player.currentBet = actualAmount; // 总投入
          newState.pot += raiseAmount;

          // 更新公共状态
          const newRaiseAmount = actualAmount - newState.currentMaxBet; // 新的 *额外* 加注额
          // 只有当不是 "小于最小加注的all-in" 时，才更新 lastRaiseAmount
          if (!isAllIn || newRaiseAmount >= newState.lastRaiseAmount) {
            newState.lastRaiseAmount = newRaiseAmount;
          }
          newState.currentMaxBet = actualAmount;
          newState.playersActed.length = 0; // 重置已行动玩家

          player.status = isAllIn ? "全押" : "加注";
          logMsg = `${player.name} ${
            isAllIn ? "全押" : "加注到"
          } $${actualAmount}`;

          if (!isAllIn) {
            // *** 移除: sound.playRaise() (请求 #1) ***
            actionContext = `${newState.phase}_raise`;
          }
        }

        // 4. 记录日志和AI语音
        if (logMsg) {
          newState.logs.push(logMsg);
          if (newState.logs.length > 20) newState.logs.shift(); // 保持日志简洁

          // *** 移除: AI 语音触发 ***
        }

        // 5. 标记玩家已行动
        if (!newState.playersActed.includes(actingUserId)) {
          newState.playersActed.push(actingUserId);
        }

        // 6. 检查回合是否结束，或进入下一阶段

        const activePlayers = newState.playerOrder
          .map((uid) => newState.players[uid])
          .filter((p) => !p.folded);

        const playersWithChips = activePlayers.filter((p) => p.chips > 0);

        // 检查是否所有人都跟注了
        const isBetsMatched = activePlayers.every(
          (p) =>
            p.chips === 0 || // All-in 玩家
            p.currentBet === newState.currentMaxBet || // 已跟注
            p.folded // 已弃牌
        );

        // 检查是否所有人都行动了
        const allActed = activePlayers.every(
          (p) =>
            p.chips === 0 || // All-in
            p.folded || // 弃牌
            newState.playersActed.includes(p.uid) // 已行动
        );

        // 特殊情况：大盲注 "Option"
        // (在 preflop 且无人加注时, 大盲注是最后行动)
        let bigBlindHadOption = true;
        if (
          newState.phase === "preflop" &&
          newState.currentMaxBet === BIG_BLIND
        ) {
          const bbIndex =
            (newState.dealerIndex + 2) % newState.playerOrder.length;
          const bbPlayerId = newState.playerOrder[bbIndex];
          if (!newState.playersActed.includes(bbPlayerId)) {
            bigBlindHadOption = false; // 大盲注还未行动
          }
        }

        // --- 检查1: 是否只剩一个赢家 (其他人全弃牌) ---
        if (activePlayers.length === 1) {
          newState = advanceToShowdown(newState, activePlayers[0]); // 传入唯一赢家
        }
        // --- 检查3: 是否自动摊牌 (多人All-in) ---
        // *** 修正: 必须在 "检查2" 之前检查 ***
        else if (
          isBetsMatched &&
          playersWithChips.length <= 1 &&
          newState.phase !== "showdown"
        ) {
          // 所有人都跟了, 且只有0或1个玩家还有筹码
          newState.logs.push("--- 多人All-in, 自动发牌 ---");
          newState = runAutoShowdown(newState);
        }
        // --- 检查2: 是否进入下一阶段 ---
        else if (isBetsMatched && allActed && bigBlindHadOption) {
          // 回合结束，进入下一阶段 (flop, turn, river, showdown)
          newState = advanceToNextPhase(newState);
        }
        // --- 检查4: 轮到下一个人 ---
        else {
          // 循环找到下一个未弃牌、未All-in的玩家
          let loops = 0;
          do {
            newState.currentPlayerIndex =
              (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
            const nextPlayerId =
              newState.playerOrder[newState.currentPlayerIndex];
            const nextPlayer = newState.players[nextPlayerId];
            if (!nextPlayer.folded && nextPlayer.chips > 0) {
              break; // 找到了
            }
            loops++;
          } while (loops <= newState.playerOrder.length);
        }

        // 7. 处理 All-in 特效 (注意：这是客户端逻辑，但我们需要一个标记)
        if (triggerAllInEffect) {
          newState.lastAllInPlayer = player.name; // 标记谁触发了All-in
        }

        return newState;
      }

      // --- 游戏逻辑：进入下一阶段 ---
      function advanceToNextPhase(currentState) {
        let newState = JSON.parse(JSON.stringify(currentState));

        // 1. 结算本轮下注 (移入 accumulatedBet)
        let totalPotForThisRound = 0;
        newState.playerOrder.forEach((uid) => {
          const p = newState.players[uid];
          p.accumulatedBet += p.currentBet;
          totalPotForThisRound += p.currentBet;
          p.currentBet = 0; // 清空当前轮下注
          p.status = ""; // 清空状态
        });

        // 2. 重置下注状态
        newState.currentMaxBet = 0;
        newState.lastRaiseAmount = BIG_BLIND; // 重置最小加注额
        newState.playersActed = [];

        // 3. 推进阶段
        if (newState.phase === "preflop") {
          newState.phase = "flop";
          newState.communityCards.push(
            newState.deck.pop(),
            newState.deck.pop(),
            newState.deck.pop()
          );
          newState.logs.push("--- 翻牌圈 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
        } else if (newState.phase === "flop") {
          newState.phase = "turn";
          newState.communityCards.push(newState.deck.pop());
          newState.logs.push("--- 转牌圈 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
        } else if (newState.phase === "turn") {
          newState.phase = "river";
          newState.communityCards.push(newState.deck.pop());
          newState.logs.push("--- 河牌圈 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
        } else if (newState.phase === "river") {
          // 进入摊牌
          newState = advanceToShowdown(newState);
          return newState; // 摊牌逻辑会处理后续
        }

        // 4. 找到下一个行动的玩家 (从庄家左侧开始)
        let nextIdx = (newState.dealerIndex + 1) % newState.playerOrder.length;
        let loops = 0;
        while (loops <= newState.playerOrder.length) {
          const pId = newState.playerOrder[nextIdx];
          const p = newState.players[pId];
          if (!p.folded && p.chips > 0) {
            break; // 找到了
          }
          nextIdx = (nextIdx + 1) % newState.playerOrder.length;
          loops++;
        }
        newState.currentPlayerIndex = nextIdx;

        return newState;
      }

      // --- 游戏逻辑：自动发完所有牌 (多人All-in) ---
      function runAutoShowdown(currentState) {
        let newState = JSON.parse(JSON.stringify(currentState));

        // 1. 结算当前轮
        newState.playerOrder.forEach((uid) => {
          const p = newState.players[uid];
          p.accumulatedBet += p.currentBet;
          p.currentBet = 0;
          p.status = p.chips === 0 && !p.folded ? "All-in" : p.status;
        });

        newState.currentPlayerIndex = -1; // 停止所有玩家行动
        newState.logs.push("--- 全员梭哈 自动亮牌 ---");

        // 2. 推进到下一个发牌阶段
        if (newState.phase === "preflop") {
          newState.phase = "flop";
          newState.communityCards.push(
            newState.deck.pop(),
            newState.deck.pop(),
            newState.deck.pop()
          );
          newState.logs.push("--- 翻牌 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
          newState.nextPhaseTimer = 1500; // 设置1.5秒计时器
        } else if (newState.phase === "flop") {
          newState.phase = "turn";
          newState.communityCards.push(newState.deck.pop());
          newState.logs.push("--- 转牌 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
          newState.nextPhaseTimer = 1500; // 设置1.5秒计时器
        } else if (newState.phase === "turn") {
          newState.phase = "river";
          newState.communityCards.push(newState.deck.pop());
          newState.logs.push("--- 河牌 ---");
          // *** 移除: sound.playCard() (请求 #1) ***
          newState.nextPhaseTimer = 1500; // 设置1.5秒计时器
        } else if (newState.phase === "river") {
          // 牌已发完, 立即进入摊牌
          newState.nextPhaseTimer = 0; // 确保清除计时器
          newState = advanceToShowdown(newState);
        }

        return newState;
      }

      // --- 游戏逻辑：摊牌或结算 ---
      function advanceToShowdown(currentState, soleWinner = null) {
        let newState = JSON.parse(JSON.stringify(currentState));
        newState.phase = "showdown";
        newState.currentPlayerIndex = -1; // 停止行动

        // 1. 结算最后一轮下注
        let finalPot = 0;
        newState.playerOrder.forEach((uid) => {
          const p = newState.players[uid];
          if (!soleWinner) {
            // 只有在多人摊牌时才结算
            p.accumulatedBet += p.currentBet;
          }
          finalPot += p.accumulatedBet; // 累加总底池
          p.currentBet = 0;
        });
        newState.pot = finalPot; // 确保底池金额正确

        // 2. 退还多余的下注 (如果需要)
        // (此逻辑已在下面的 4c. 边池计算中自动处理)

        // 3. 情况A: 只有一个赢家 (其他人都弃牌了)
        if (soleWinner) {
          const winnerPlayer = newState.players[soleWinner.uid];
          winnerPlayer.chips += newState.pot;
          newState.logs.push(
            `--- ${winnerPlayer.name} 获胜, 赢得 $${newState.pot} ---`
          );
          newState.highlightWinner = winnerPlayer.uid; // 标记赢家高亮
        }
        // 4. 情况B: 多人摊牌 (*** 升级: 完整的边池计算逻辑 ***)
        else {
          // *** 修复: 必须先获取所有玩家, 再筛选 activePlayers ***
          const allPlayers = newState.playerOrder.map(
            (uid) => newState.players[uid]
          );
          const activePlayers = allPlayers.filter((p) => !p.folded);

          if (activePlayers.length === 0) {
            newState.logs.push("--- 无人获胜？回合结束 ---");
          } else {
            // 4a. 计算每个人的最佳手牌
            activePlayers.forEach((p) => {
              p.bestHand = HandEvaluator.evaluate(
                p.holeCards,
                newState.communityCards
              );
              p.status = p.bestHand.name; // 显示牌型
            });

            // 4b. 找出所有不同的下注额 (边池级别)
            // *** 修复: 必须从 allPlayers (包括已弃牌) 中获取 betLevels ***
            let betLevels = [
              ...new Set(allPlayers.map((p) => p.accumulatedBet)),
            ];
            // 必须确保 0 级别也包含在内，作为计算的起点
            if (!betLevels.includes(0)) {
              betLevels.push(0);
            }
            betLevels.sort((a, b) => a - b); // [0, 200, 500, 1000]

            let winnerLogs = [];
            newState.highlightCards = new Set(); // 用于高亮获胜卡牌

            // 4c. 逐级计算边池
            // --- 全新边池/退款逻辑 (修复Bug) ---
            // 我们需要一个循环来不断创建彩池, 直到所有的赌注都分配完毕
            while (true) {
              // 1. 找出所有 *仍有* 赌注 (accumulatedBet > 0) 的玩家 (包括已弃牌)
              let contributingPlayers = allPlayers.filter(
                (p) => p.accumulatedBet > 0
              );

              // 2. 找出所有 *未弃牌* 且 *仍有* 赌注的玩家 (他们是这个彩池的潜在赢家)
              let eligiblePlayers = activePlayers.filter(
                (p) => p.accumulatedBet > 0
              );

              // --- 检查循环结束条件 ---

              // 2a. 如果没有任何玩家有赌注了, 结束
              if (contributingPlayers.length === 0) {
                break;
              }

              // 2b. 如果 *有* 赌注, 但 *没有* 未弃牌的玩家 (例如, 所有人all-in, 一个人弃牌, 钱算错了)
              // 这种情况理论上不该发生, 但作为保险, 退还所有剩余赌注
              if (eligiblePlayers.length === 0) {
                winnerLogs.push("--- 错误: 发现无人有资格的赌注, 正在退款 ---");
                contributingPlayers.forEach((p) => {
                  newState.players[p.uid].chips += p.accumulatedBet;
                  winnerLogs.push(`${p.name} 获得退款 $${p.accumulatedBet}`);
                  p.accumulatedBet = 0;
                });
                break;
              }

              // 2c. (Bug 2 修复: 退款)
              // 如果 *有* 赌注的玩家中, 只有一个人是 *未弃牌* 的 (eligiblePlayers.length === 1),
              // 那么这个彩池就是他自己的钱 (和可能来自已弃牌玩家的钱)
              // 或者是, *总共* 只有一个人还有赌注 (contributingPlayers.length === 1)
              // 这两种情况都意味着这是最后一笔钱, 应该退款或判赢
              if (eligiblePlayers.length === 1) {
                let soleEligiblePlayer = eligiblePlayers[0];
                let potAmount = 0;

                contributingPlayers.forEach((p) => {
                  potAmount += p.accumulatedBet;
                  p.accumulatedBet = 0;
                });

                if (potAmount > 0) {
                  // 如果唯一的玩家是 Player B (bet 500), 且 Player A (bet 100) 已经处理完
                  // 此时 contributingPlayers 只有 [B (bet 400)], eligiblePlayers 只有 [B (bet 400)]
                  // 这 400 应该退还
                  // (Bug 1 修复: 只有两个玩家时, 这就是退款, 不叫 "边池")
                  if (
                    contributingPlayers.length === 1 &&
                    eligiblePlayers.length === 1
                  ) {
                    winnerLogs.push(
                      `${soleEligiblePlayer.name} 获得退款 $${potAmount}`
                    );
                  } else {
                    // 如果 Player C (弃牌) 也有 100, B 拿走 C 的 100
                    winnerLogs.push(
                      `${soleEligiblePlayer.name} 赢得 $${potAmount} (无人跟注)`
                    );
                  }
                  newState.players[soleEligiblePlayer.uid].chips += potAmount;
                }
                break; // 结束
              }

              // --- 正常彩池计算 (有 >= 2 个未弃牌玩家) ---

              // 3. 找到 *未弃牌* 玩家中的最小赌注, 这定义了当前彩池的级别
              let potLevel = Math.min(
                ...eligiblePlayers.map((p) => p.accumulatedBet)
              ); // e.g., 100

              if (potLevel === 0) break; // 不应该发生, 但作为保险

              let potAmount = 0;

              // 4. 从 *所有* 有赌注的玩家那里收取
              contributingPlayers.forEach((p) => {
                let contribution = Math.min(p.accumulatedBet, potLevel);
                potAmount += contribution;
                p.accumulatedBet -= contribution; // 减去已贡献的
              });

              if (potAmount === 0) continue; // 没钱, 跳过

              // 5. 从 eligiblePlayers (有资格的) 中找出赢家
              let bestScore = -1;
              let winners = [];
              let winHandName = "";

              eligiblePlayers.forEach((p) => {
                if (p.bestHand.score > bestScore) {
                  bestScore = p.bestHand.score;
                  winners = [p];
                  winHandName = p.bestHand.name;
                } else if (Math.abs(p.bestHand.score - bestScore) < 0.1) {
                  winners.push(p);
                }
              });

              // 6. 分钱
              const winPer = Math.floor(potAmount / winners.length);
              let remainder = potAmount % winners.length;

              // (Bug 1 修复: 只有两个玩家时, 不应该叫 "边池")
              const potName = "彩池";
              let winnerNames = winners.map((w) => w.name).join(", ");
              winnerLogs.push(
                `${potName}($${potAmount}): ${winnerNames} 获胜 (${winHandName})`
              );

              winners.forEach((w, index) => {
                let winnings = winPer;
                if (remainder > 0) {
                  winnings++;
                  remainder--;
                }
                newState.players[w.uid].chips += winnings;
                newState.highlightWinner = w.uid; // 高亮
                if (w.bestHand.bestCards) {
                  w.bestHand.bestCards.forEach((c) =>
                    newState.highlightCards.add(c.id)
                  );
                }
              });

              // 循环继续, 处理下一轮 (e.g., Player B 剩下的 400)
            }
            // --- 边池逻辑结束 ---

            // 将 Set 转换为数组以便
            newState.highlightCards = Array.from(newState.highlightCards);
            newState.logs.push("--- 摊牌结果 ---", ...winnerLogs);
          }
        }
        // (*** 结束修改 ***)

        // 5. 标记回合结束，准备下一轮
        newState.nextRoundTimer = 6000; // 6秒后开始新回合

        // --- 恢复的逻辑: 播放局结束音效 ---
        sound.playHandEnd();
        // --- 结束 ---

        return newState;
      }

      // --- 游戏逻辑：房主开始新回合 ---
      function startNewRound(currentState) {
        let newState = JSON.parse(JSON.stringify(currentState));

        // 1. 淘汰筹码为 0 的玩家
        let activePlayerIds = [];
        // *** 修改: 需要一个所有玩家的列表 ***
        const allPlayerIds = Object.keys(newState.players); // 获取所有玩家ID

        allPlayerIds.forEach((uid) => {
          if (newState.players[uid].chips > 0) {
            activePlayerIds.push(uid);
          } else {
            newState.players[uid].folded = true; // 标记为旁观
            newState.players[uid].status = "淘汰";
          }
        });
        // *** 临时更新 playerOrder 用于检查 ***
        const activePlayerOrder = activePlayerIds;

        // 2. 检查游戏是否结束
        // *** 修改: (请求 #1) 游戏结束后重置房间 ***
        if (activePlayerOrder.length < 2) {
          const winnerId =
            activePlayerOrder.length > 0 ? activePlayerOrder[0] : null;
          const winnerName = winnerId
            ? newState.players[winnerId].name
            : "无人";

          let newLogs = [...newState.logs]; // 复制日志
          newLogs.push(`--- 游戏结束! ${winnerName} 获胜! ---`);
          newLogs.push("--- 房间已重置, 等待房主重新开始 ---");
          if (newLogs.length > 20) newLogs = newLogs.slice(newLogs.length - 20);

          // *** 新增: 游戏结束后重置为等待室状态 ***
          const resetPlayers = {};
          // *** 使用 allPlayerIds 遍历 ***
          allPlayerIds.forEach((uid) => {
            const p = newState.players[uid];
            if (p) {
              // 确保玩家存在
              resetPlayers[uid] = {
                ...p, // 保留 uid, name, id
                chips: 1000, // 重置筹码
                holeCards: [],
                folded: false,
                currentBet: 0,
                accumulatedBet: 0,
                status: "等待中",
                bestHand: null,
              };
            }
          });

          // 2. 返回一个全新的 "waiting" 状态
          return {
            status: "waiting", // 关键: 回到等待状态
            hostId: newState.hostId,
            players: resetPlayers, // 使用重置后的玩家列表
            playerOrder: allPlayerIds, // 恢复所有玩家
            communityCards: [],
            pot: 0,
            dealerIndex: 0, // 重置庄家
            currentPlayerIndex: -1,
            currentMaxBet: 0,
            phase: "waiting",
            lastRaiseAmount: BIG_BLIND,
            deck: [],
            logs: newLogs, // 使用新日志
            highlightWinner: winnerId, // 短暂高亮赢家
            highlightCards: [],
            nextRoundTimer: 0,
            nextPhaseTimer: 0,
          };
        }

        // *** 如果游戏未结束, 必须使用 activePlayerIds ***
        newState.playerOrder = activePlayerIds; // 更新玩家顺序为活跃玩家
        // *** 结束修改 (请求 #1) ***

        // 3. 重置状态
        newState.communityCards = [];
        newState.pot = 0;
        newState.currentMaxBet = 0;
        newState.lastRaiseAmount = BIG_BLIND;
        newState.phase = "preflop";
        newState.playersActed = [];
        newState.highlightWinner = null;
        newState.highlightCards = [];
        newState.nextRoundTimer = 0;
        newState.nextPhaseTimer = 0; // *** 新增: 清除计时器 ***

        // 4. 重置玩家
        newState.playerOrder.forEach((uid) => {
          const p = newState.players[uid];
          p.holeCards = [];
          p.folded = false;
          p.currentBet = 0;
          p.accumulatedBet = 0;
          p.status = "";
          p.bestHand = null;
        });

        // 5. 洗牌
        let deck = [];
        for (let suit of SUITS) {
          for (let rank of RANKS) {
            deck.push({
              suit,
              rank,
              value: RANK_VALUES[rank],
              color: suit === "♥" || suit === "♦" ? "red" : "black",
              id: Math.random().toString(36).substr(2, 9), // 每张牌的唯一ID
            });
          }
        }
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        newState.deck = deck; // 牌库存储在 state 中

        // 6. 移动庄家
        newState.dealerIndex =
          (newState.dealerIndex + 1) % newState.playerOrder.length;
        const numPlayers = newState.playerOrder.length;

        // 7. 放置盲注
        const sbIndex = (newState.dealerIndex + 1) % numPlayers;
        const bbIndex = (newState.dealerIndex + 2) % numPlayers;

        const sbPlayerId = newState.playerOrder[sbIndex];
        const bbPlayerId = newState.playerOrder[bbIndex];

        const sbPlayer = newState.players[sbPlayerId];
        const sbAmount = Math.min(SMALL_BLIND, sbPlayer.chips);
        sbPlayer.chips -= sbAmount;
        sbPlayer.currentBet = sbAmount;
        sbPlayer.status = "小盲";

        const bbPlayer = newState.players[bbPlayerId];
        const bbAmount = Math.min(BIG_BLIND, bbPlayer.chips);
        bbPlayer.chips -= bbAmount;
        bbPlayer.currentBet = bbAmount;
        bbPlayer.status = "大盲";

        newState.pot = sbAmount + bbAmount;
        newState.currentMaxBet = BIG_BLIND;

        // 8. 发手牌
        for (let i = 0; i < 2; i++) {
          for (let uid of newState.playerOrder) {
            newState.players[uid].holeCards.push(newState.deck.pop());
          }
        }

        // 9. 设置第一个行动者 (大盲注左侧)
        newState.currentPlayerIndex = (bbIndex + 1) % numPlayers;

        newState.logs.push("--- 新回合开始 ---");
        return newState;
      }

      // --- UI 渲染和音效 (客户端) ---
      class GameUIManager {
        constructor() {
          this.sound = new SoundManager();
          this.dragSystem = new TableDragSystem();
          this.occlusionManager = new OcclusionManager();
          this.lastState = null; // 用于比较状态
          this.localPlayerId = null;
          this.highlightCards = new Set();

          // 绑定加注滑块
          document.getElementById("raise-slider").oninput = () => {
            const slider = document.getElementById("raise-slider");
            const btnRaise = document.getElementById("btn-raise");
            const valDisplay = document.getElementById("raise-val-display");

            if (slider && btnRaise && valDisplay && !slider.disabled) {
              const raiseVal = parseInt(slider.value);
              const maxVal = parseInt(slider.max);

              valDisplay.innerText = `$${raiseVal}`;
              btnRaise.innerText =
                raiseVal === maxVal ? "全押" : `加注 $${raiseVal}`;
            }
          };
        }

        initSound() {
          this.sound.init();
          sound = this.sound; // 赋值给全局音效
        }

        // --- 移除: showDialogue 函数 ---

        // --- 移除: speak 函数 ---

        // --- 核心渲染函数 ---
        renderGameState(state, localId) {
          if (!state) {
            console.log("Render: state 为空");
            return;
          }

          // *** 新增: 确保音效被激活 (请求 #1) ***
          this.initSound();

          // *** 新增: 客户端音效 (基于日志) (请求 #1) ***
          if (
            this.lastState &&
            state.logs.length > this.lastState.logs.length
          ) {
            const newLog = state.logs[state.logs.length - 1];

            if (newLog.includes("弃牌")) {
              this.sound.playFold();
            } else if (newLog.includes("过牌")) {
              this.sound.playCheck();
            } else if (newLog.includes("跟注")) {
              this.sound.playChip();
            } else if (newLog.includes("加注到")) {
              this.sound.playRaise();
            }
            // All-in sound is handled by showAllInEffect

            // 牌局音效
            if (
              newLog.includes("--- 翻牌圈 ---") ||
              newLog.includes("--- 转牌圈 ---") ||
              newLog.includes("--- 河牌圈 ---")
            ) {
              this.sound.playCard();
            }
          }
          // *** 结束新增 ***

          // *** 修复: 将高光列表的更新移至最前方 ***
          this.highlightCards = new Set(state.highlightCards || []);
          // *** 结束修复 ***

          // --- 恢复的逻辑: 更新玩家计数 ---
          // *** 修改: (请求 #1) 计数器现在应该计算 players, 而不是 playerOrder, 因为 playerOrder 在等待时是完整的 ***
          const playerCount = state.playerOrder ? state.playerOrder.length : 0;
          const countEl = document.getElementById("active-players-count");
          if (countEl) countEl.innerText = playerCount;
          // --- 结束 ---

          // --- 修复: 比较 All-in 特效 ---
          // 必须在 this.lastState 被覆盖之前进行比较
          // 修正了之前 (state.lastAllInPlayer !== this.lastState.lastAllInPlayer) 永远为 false 的 bug
          if (
            state.lastAllInPlayer &&
            (!this.lastState ||
              state.lastAllInPlayer !== this.lastState.lastAllInPlayer)
          ) {
            // 确保我们只在 lastAllInPlayer *改变* 时触发
            if (state.lastAllInPlayer !== this.lastAllInPlayerTriggered) {
              this.showAllInEffect(state.lastAllInPlayer);
              this.lastAllInPlayerTriggered = state.lastAllInPlayer; // 标记已触发
            }
          }
          // 回合结束时清除标记
          if (state.phase === "showdown") {
            this.lastAllInPlayerTriggered = null;
          }
          // --- 修复结束 ---

          this.lastState = state; // 现在才更新 lastState
          this.localPlayerId = localId;
          const localPlayer = state.players[localId];

          // 1. 更新顶部信息
          document.getElementById("pot-display").innerText = state.pot;
          document.getElementById("phase-display").innerText =
            PHASE_NAME_MAP[state.phase] || "未知";

          // 2. 渲染牌桌
          this.renderTableLayout(state, localId);

          // 3. 渲染公共牌
          const commDiv = document.getElementById("community-cards");
          commDiv.innerHTML = "";
          const row1 = document.createElement("div");
          row1.className = "flex space-x-2";
          const row2 = document.createElement("div");
          row2.className = "flex space-x-2";

          // *** 修复: 移除了 this.highlightCards 的重复设置 ***

          state.communityCards.forEach((c, i) => {
            const cardEl = this.createCardEl(c);
            if (i < 3) row1.appendChild(cardEl);
            else row2.appendChild(cardEl);
          });
          commDiv.appendChild(row1);
          if (state.communityCards.length > 3) commDiv.appendChild(row2);

          // 4. 更新日志
          const logDiv = document.getElementById("game-log");
          logDiv.innerHTML = state.logs
            .map((msg) => `<div>> ${msg}</div>`)
            .join("");
          logDiv.scrollTop = logDiv.scrollHeight;

          // 5. 更新玩家座位信息 (已在 renderTableLayout 中处理)

          // 6. 更新控制按钮
          this.updateControls(state);

          // *** 修复: 移除了旧的房主控制逻辑 (Section 7) ***

          // 8. All-in 特效 (逻辑已移到本函数开头)

          // 9. 游戏结束画面
          // *** 修复: (请求 #4) 检查逻辑 ***
          const screen = document.getElementById("game-over-screen");
          if (localPlayer && screen.classList.contains("hidden")) {
            // Only trigger if hidden
            // *** 修改: (请求 #1) 游戏结束现在是 'waiting' 状态 ***
            // const isGameFinished = (state.status === 'finished'); // 旧逻辑
            // 现在的 "游戏结束" 是指 "我被淘汰了"
            const isEliminated =
              localPlayer.status === "淘汰" && localPlayer.chips === 0;

            // *** 修改: (请求 #1) 游戏冠军现在在 'waiting' 状态下判断 ***
            const isChampion =
              state.status === "waiting" &&
              state.highlightWinner === localId &&
              state.logs[state.logs.length - 2].includes("游戏结束");

            if (isChampion) {
              // Game just finished, and I am the champion.
              this.showGameOver(true, true, localPlayer); // (isWin, isGameFinished, player)
            } else if (isEliminated && state.status === "playing") {
              // Game is ongoing, but I am out.
              this.showGameOver(false, false, localPlayer); // (isWin=false, isGameFinished=false, player)
            } else if (isEliminated && state.status === "waiting") {
              // Game finished, but I lost earlier.
              this.showGameOver(false, true, localPlayer); // (isWin=false, isGameFinished=true, player)
            }
          }

          // *** (请求 #1) 如果重置了, 隐藏结束画面 ***
          // *** 修改: 自动隐藏所有人的结束画面 (冠军/输家)，以显示等待室 ***
          if (
            state.status === "waiting" &&
            !screen.classList.contains("hidden")
          ) {
            // 检查是否是由"游戏结束"（即有赢家高亮）触发的
            if (state.highlightWinner) {
              // showGameOver 刚刚被调用, 检查它是否设置了 "isGameFinished" 状态
              // 我们可以通过检查 msg 文本来判断
              const msg = document.getElementById("game-over-msg").innerText;
              if (msg.includes("房间已重置")) {
                setTimeout(() => {
                  // 确保它仍然没有被用户手动隐藏
                  if (!screen.classList.contains("hidden")) {
                    screen.classList.add("hidden");
                    this.showMessage("游戏结束，等待房主重新开始...");
                  }
                }, 4000); // 延迟4秒隐藏
              }
            } else {
              // 如果不是游戏结束（例如玩家刚加入），立即隐藏
              screen.classList.add("hidden");
            }
          }

          // 10. *** 新增: 等待室 UI ***
          const waitOverlay = document.getElementById("waiting-room-overlay");
          if (state.status === "waiting") {
            waitOverlay.classList.remove("hidden");
            network.updateWaitingRoomUI(state, localId); // *** 修复: 改为调用 network.updateWaitingRoomUI ***
          } else {
            waitOverlay.classList.add("hidden");
          }
        }

        // --- 渲染牌桌布局 (根据状态) ---
        renderTableLayout(state, localId) {
          const container = document.getElementById("seats-container");
          container.innerHTML = ""; // 清空

          // *** 修改: (请求 #1) 在 'waiting' 状态, playerOrder 包含所有人 ***
          // *** 我们只渲染 'playing' 状态下的 playerOrder ***
          const playerIdsToRender =
            state.phase === "waiting" || state.status === "waiting"
              ? state.playerOrder // 在等待时，渲染所有人
              : state.playerOrder; // 在游戏中，playerOrder 已经是 activePlayers

          const num = playerIdsToRender.length;
          if (num === 0) return;

          const w = container.offsetWidth;
          const h = container.offsetHeight;
          const cx = w / 2;
          const cy = h / 2;
          const localIndex = playerIdsToRender.indexOf(localId);

          // 如果找不到本地玩家 (例如观战), 默认 localIndex 为 0
          const renderIndex = localIndex === -1 ? 0 : localIndex;

          // 动态调整半径和缩放
          let scale = 1;
          let radiusX = 0.38;
          let radiusY = 0.38;
          if (num > 6) {
            scale = 0.85;
            radiusX = 0.42;
            radiusY = 0.42;
          }
          if (num >= 9) {
            scale = 0.75;
            radiusX = 0.44;
            radiusY = 0.44;
          }
          if (w < 768) {
            if (num > 5) scale = 0.75;
            if (num > 8) scale = 0.65;
            radiusX = 0.4;
          }
          const rx = w * radiusX;
          const ry = h * radiusY;

          playerIdsToRender.forEach((uid, i) => {
            const p = state.players[uid];
            if (!p) return; // 玩家可能已离开

            // 计算位置，确保本地玩家总在最下方
            const offsetIndex = (i - renderIndex + num) % num;
            const angle = Math.PI / 2 + (offsetIndex * (2 * Math.PI)) / num;
            const x = cx + rx * Math.cos(angle);
            const y = cy + ry * Math.sin(angle);

            const div = document.createElement("div");
            div.id = `seat-${p.uid}`; // *** 修改: ID 匹配 ***
            div.className = "player-seat";
            div.style.left = `${x - 60}px`;
            div.style.top = `${y - 55}px`;
            div.style.transform = `scale(${scale})`;

            // --- 渲染手牌 ---
            let cardsHTML = "";
            if (!p.folded && p.holeCards && p.holeCards.length > 0) {
              if (p.uid === localId || state.phase === "showdown") {
                cardsHTML = p.holeCards
                  .map((c) => this.createCardEl(c).outerHTML)
                  .join("");
              } else {
                cardsHTML =
                  this.createBackEl().outerHTML + this.createBackEl().outerHTML;
              }
            }

            // --- 渲染座位 ---
            div.innerHTML = `
                        <div id="cards-${
                          p.uid
                        }" class="absolute flex space-x-1 z-10 transition-all" style="top:-50px;">
                            ${cardsHTML}
                        </div>
                        
                        <div class="player-info-box relative z-20">
                            <div id="dealer-${p.uid}" class="dealer-btn ${
              i === state.dealerIndex ? "" : "hidden"
            }">D</div>
                            <div class="font-bold text-yellow-400 truncate text-sm tracking-wide">${
                              p.name
                            }</div>
                            <div class="text-white text-xs font-mono">$<span id="chips-${
                              p.uid
                            }">${p.chips}</span></div>
                            <div id="status-${
                              p.uid
                            }" class="text-gray-400 text-[10px] h-4 truncate font-bold uppercase mt-1">
                                ${
                                  p.currentBet > 0
                                    ? `下注 $${p.currentBet}`
                                    : p.status || ""
                                }
                            </div>
                        </div>`;
            container.appendChild(div);

            // --- 应用高亮 ---
            const seat = document.getElementById(`seat-${p.uid}`);
            if (
              state.playerOrder[state.currentPlayerIndex] === p.uid &&
              state.phase !== "showdown"
            ) {
              seat.classList.add("active-player");
            } else {
              seat.classList.remove("active-player");
            }

            if (state.highlightWinner === p.uid) {
              seat.classList.add("winner-highlight");
            } else {
              seat.classList.remove("winner-highlight");
            }

            seat.style.opacity = p.folded ? 0.4 : 1;
          });
        }

        // --- 更新控制按钮 (客户端) ---
        updateControls(state) {
          // *** 修复: 确保在调用前 lastState 和 localPlayerId 已设置 ***
          if (!state || !state.players || !this.localPlayerId) return;
          const localPlayer = state.players[this.localPlayerId];
          if (!localPlayer) return; // 如果玩家数据不存在，则退出
          // *** 结束修复 ***

          const controls = document.getElementById("player-controls");

          // 1. 检查是否轮到本地玩家
          const isMyTurn =
            state.playerOrder[state.currentPlayerIndex] === this.localPlayerId;
          const canAct =
            isMyTurn &&
            !localPlayer.folded &&
            localPlayer.chips > 0 &&
            state.phase !== "showdown";

          if (!canAct) {
            controls.classList.add(
              "opacity-50",
              "pointer-events-none",
              "translate-y-2"
            );
            return;
          }

          controls.classList.remove(
            "opacity-50",
            "pointer-events-none",
            "translate-y-2"
          );
          // this.initSound(); // *** 移除: 已移至 renderGameState (请求 #1) ***
          gameUI.showMessage("你的回合");

          // 2. 计算按钮状态
          const diff = state.currentMaxBet - localPlayer.currentBet;
          const btnCheck = document.getElementById("btn-check");
          const btnCall = document.getElementById("btn-call");
          const btnRaise = document.getElementById("btn-raise");
          const slider = document.getElementById("raise-slider");
          const valDisplay = document.getElementById("raise-val-display");

          // 3. 处理 "过牌" / "跟注"
          if (diff === 0) {
            btnCheck.classList.remove("hidden");
            btnCall.classList.add("hidden");
          } else {
            btnCheck.classList.add("hidden");
            btnCall.classList.remove("hidden");
            if (localPlayer.chips <= diff) btnCall.innerText = "全押";
            else btnCall.innerText = `跟注 $${diff}`;
          }

          // 4. 处理 "加注" (No-Limit 逻辑)
          // *** 修复: 完全还原为 读博.html (原版) 的加注逻辑 ***

          // 2. 计算最小和最大的 *行动* 加注额

          // 最小 *额外* 加注额 (等于上一次的加注差额)
          const minRaiseAmount = state.lastRaiseAmount;

          // 最小合法 *行动* 加注额 (跟注额 + 最小额外加注额)
          // (注意: 这里的 diff 是跟注额, 所以 slider.value 是 *本次行动* 的总支付额)
          const minPossibleActionRaise = diff + minRaiseAmount;

          // 玩家能下注的最大 *行动* 额 (即全押, 支付所有剩余筹码)
          const maxPossibleActionRaise = localPlayer.chips;

          // 3. 根据筹码情况决定 "加注" 按钮的状态

          // 场景 1: 跟注就是全押 (筹码 <= 跟注额)
          if (localPlayer.chips <= diff) {
            btnRaise.classList.add("hidden");
            document
              .getElementById("raise-slider-container")
              .classList.add("hidden");

            // 场景 2: 筹码不足以进行最小 *额外* 加注 (maxPossibleActionRaise < minPossibleActionRaise)
          } else if (maxPossibleActionRaise < minPossibleActionRaise) {
            // 玩家不能进行 "最小加注", 但 *可以* "全押"
            btnRaise.classList.remove("hidden");
            btnRaise.innerText = "全押"; // 强制文本为 "全押"

            document
              .getElementById("raise-slider-container")
              .classList.remove("hidden");
            // 滑块现在代表 *行动* 金额.
            // 最小值, 最大值, 和当前值都是 maxPossibleActionRaise (即玩家的全部筹码)
            slider.min = maxPossibleActionRaise;
            slider.max = maxPossibleActionRaise;
            slider.value = maxPossibleActionRaise;
            valDisplay.innerText = `$${maxPossibleActionRaise}`; // 显示行动的金额
            slider.disabled = true; // 禁用滑块

            // (onclick 已被 network.handleHumanAction('raise') 绑定, 无需重写)

            // 场景 3: 筹码充足, 可以正常加注
          } else {
            btnRaise.classList.remove("hidden");
            document
              .getElementById("raise-slider-container")
              .classList.remove("hidden");

            // 滑块范围现在是 *行动* 的加注额
            slider.min = minPossibleActionRaise;
            slider.max = maxPossibleActionRaise;

            // 步进必须为 1 (原版 读博.html 也是 1)
            slider.step = 1;

            // *** 修改: (请求 #2) 始终将滑块重置为最小值 ***
            slider.value = slider.min;
            // *** 结束修改 (请求 #2) ***

            slider.disabled = false; // 确保滑块启用

            // (onclick 已被 network.handleHumanAction('raise') 绑定, 无需重写)

            const updateBtnText = () => {
              const raiseVal = parseInt(slider.value); // 这是 *行动* 的金额

              // 显示 *行动* 的金额
              valDisplay.innerText = `$${raiseVal}`;

              if (raiseVal === maxPossibleActionRaise) {
                btnRaise.innerText = "全押";
              } else {
                // 按钮文本显示 "加注 X" (X=行动金额)
                btnRaise.innerText = `加注 $${raiseVal}`;
              }
            };

            // *** 修复: 移除 slider.oninput 的重复绑定 (已在构造函数中绑定) ***
            updateBtnText(); // 立即执行一次
          }
          // *** 修复结束 ***
        }

        // --- 调整加注滑块 ---
        adjustRaise(direction) {
          const slider = document.getElementById("raise-slider");
          if (!slider || slider.disabled) return;
          const currentVal = parseInt(slider.value);
          // *** 修复: 步进改为 1 (匹配原版 读博.html) ***
          const step = 1;
          // *** 结束修复 ***
          const min = parseInt(slider.min);
          const max = parseInt(slider.max);
          let newVal = currentVal + direction * step;
          if (newVal < min) newVal = min;
          if (newVal > max) newVal = max;
          slider.value = newVal;
          // 手动触发 input 事件来更新显示
          slider.dispatchEvent(new Event("input"));
        }

        // --- 显示消息 ---
        showMessage(msg) {
          const el = document.getElementById("game-message");
          el.innerText = msg;
          el.style.opacity = 1;
          clearTimeout(this.msgTimeout);
          this.msgTimeout = setTimeout(() => (el.style.opacity = 0), 3000);
        }

        // --- All-in 特效 ---
        showAllInEffect(playerName) {
          return new Promise((resolve) => {
            const overlay = document.createElement("div");
            overlay.className = "all-in-fullscreen-overlay";
            const bar = document.createElement("div");
            bar.className = "all-in-bar";
            const text = document.createElement("div");
            text.className = "all-in-text";
            // *** 修改: 移除 playerName (请求 #2) ***
            text.innerText = `ALL-IN`;
            bar.appendChild(text);
            overlay.appendChild(bar);
            document.body.appendChild(overlay);
            this.sound.playAllIn();
            setTimeout(() => {
              overlay.style.transition = "opacity 0.3s";
              overlay.style.opacity = "0";
              setTimeout(() => {
                overlay.remove();
                resolve();
              }, 300);
            }, 2500);
          });
        }

        // --- 游戏结束 ---
        // *** 修复: (请求 #4) 修正函数位置，移到 GameUIManager 内部 ***
        showGameOver(isWin, isGameFinished, player) {
          const screen = document.getElementById("game-over-screen");
          const title = document.getElementById("game-over-title");
          const msg = document.getElementById("game-over-msg");
          const btnContainer = document.getElementById("game-over-buttons"); // *** 新增 ***

          screen.classList.remove("hidden");

          if (isWin) {
            // *** 冠军 (请求 #4) ***
            title.innerText = "冠军";
            title.className = "text-6xl font-black mb-4 text-yellow-500";
            msg.innerText = `你击败了所有对手！房间已重置。`; // *** 修改: (请求 #1) ***
            sound.playWin();

            // *** 修改: 游戏结束自动重置, 移除按钮 ***
            btnContainer.innerHTML = `<p class="text-gray-500 text-sm">将在4秒后自动返回等待室...</p>`;
          } else {
            // *** 破产 (请求 #4) ***
            title.innerText = "破产";
            title.className = "text-6xl font-black mb-4 text-red-600";
            msg.innerText = "你的筹码已耗尽。";
            sound.playLose();

            if (isGameFinished) {
              // 游戏结束了，我是输家
              msg.innerText = "你的筹码已耗尽。房间已重置。"; // *** 修改: (请求 #1) ***
              // *** 修改: 游戏结束自动重置, 移除按钮 ***
              btnContainer.innerHTML = `<p class="text-gray-500 text-sm">将在4秒后自动返回等待室...</p>`;
            } else {
              // 游戏还在继续，我可以观战 (保持按钮)
              btnContainer.innerHTML = `
                            <button onclick="network.leaveRoom()" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg">返回大厅</button>
                            <button onclick="gameUI.spectate(false)" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-8 rounded-lg shadow-lg">继续观战</button>
                        `;
            }
          }
        }

        // *** 修复: (请求 #4) 修正函数位置，移到 GameUIManager 内部 ***
        spectate(isGameFinished) {
          document.getElementById("game-over-screen").classList.add("hidden");
          if (isGameFinished) {
            this.showMessage("游戏已结束。等待房主重新开始...");
          } else {
            this.showMessage("观战中... (筹码已耗尽)");
          }
          // 玩家仍在房间内, 仍会接收 onSnapshot 更新
        }

        // --- 创建卡牌元素 ---
        createCardEl(c) {
          const d = document.createElement("div");
          d.className = `card ${c.color}`;
          if (this.highlightCards.has(c.id)) d.classList.add("winning-card");
          d.innerHTML = `<span class="absolute top-0 left-1 text-xs">${c.rank}</span><span class="text-2xl">${c.suit}</span>`;
          return d;
        }
        createBackEl() {
          const d = document.createElement("div");
          d.className = "card card-back";
          return d;
        }
      }

      // --- 网络和 Firebase 交互 ---
      class NetworkManager {
        constructor(gameUI) {
          this.gameUI = gameUI;
          this.db = null;
          this.auth = null;
          this.appId = appId;
          this.localUserId = null;
          this.currentRoomId = null;
          this.unsubscribeRoom = null;
          this.nextRoundTimeout = null;
          this.nextPhaseTimeout = null; // *** 新增: 自动推进计时器 ***
          // *** 移除: AI 思考锁 ***
        }

        async init() {
          try {
            setLogLevel("Debug"); // 开启 Firebase 调试日志
            this.app = initializeApp(firebaseConfig);
            this.db = getFirestore(this.app);
            this.auth = getAuth(this.app);

            console.log("Firebase 初始化... AppID:", this.appId);

            onAuthStateChanged(this.auth, async (user) => {
              if (user) {
                this.localUserId = user.uid;
                console.log("Firebase 已认证:", this.localUserId);
                document.getElementById("user-id-display").innerText =
                  this.localUserId;
                document
                  .getElementById("firebase-loader")
                  .classList.add("hidden");
                document
                  .getElementById("room-screen")
                  .classList.remove("hidden");
              } else {
                console.log("用户未登录，尝试登录...");
                await this.signIn();
              }
            });
          } catch (error) {
            console.error("Firebase 初始化失败:", error);
            document.getElementById("firebase-loader").innerText =
              "连接失败，请刷新。";
          }
        }

        // --- 新增: 更新等待室 UI ---
        updateWaitingRoomUI(state, localId) {
          const listEl = document.getElementById("wait-player-list");
          const hostControls = document.getElementById("wait-host-controls");
          const btnStartGame = document.getElementById("btn-start-game");
          const playerCountEl = document.getElementById("wait-player-count");
          const waitMessage = document.getElementById("wait-message");

          listEl.innerHTML = ""; // 清空
          // *** 修改: (请求 #1) playerOrder 现在包含所有人 ***
          const playerCount = state.playerOrder.length;
          playerCountEl.innerText = playerCount;

          // *** 修改: (请求 #1) 遍历 playerOrder 来保证顺序 ***
          state.playerOrder.forEach((uid) => {
            const p = state.players[uid];
            if (!p) return; // 以防万一

            const pEl = document.createElement("div");
            pEl.className =
              "text-gray-300 text-sm flex justify-between items-center bg-gray-700 p-2 rounded";

            let icon = p.uid === state.hostId ? "👑" : "👤";
            let name = p.name;
            if (p.uid === localId) name = `${name} (你)`;

            pEl.innerHTML = `<span>${icon} ${name}</span>`;

            // *** 移除: AI 移除按钮 ***
            listEl.appendChild(pEl);
          });

          // 切换房主控件
          if (state.hostId === localId) {
            hostControls.classList.remove("hidden");
            waitMessage.innerText = "你是房主，等人齐后请开始游戏。";

            // *** 移除: AI 按钮检查 ***

            if (playerCount < 2) {
              btnStartGame.classList.add("btn-disabled");
              btnStartGame.innerText = `开始游戏 (至少2人)`;
            } else {
              btnStartGame.classList.remove("btn-disabled");
              btnStartGame.innerText = `开始游戏 (${playerCount}人)`;
            }
          } else {
            hostControls.classList.add("hidden");
            waitMessage.innerText = "等待房主开始游戏...";
          }
        }

        async signIn() {
          try {
            // 优先使用 Canvas 提供的令牌
            if (initialAuthToken) {
              console.log("使用 __initial_auth_token 登录...");
              await signInWithCustomToken(this.auth, initialAuthToken);
            } else {
              // 否则，匿名登录
              console.log("使用匿名登录...");
              await signInAnonymously(this.auth);
            }
          } catch (error) {
            console.error("Firebase 登录失败:", error);
          }
        }

        getRoomRef(roomId) {
          return doc(
            this.db,
            "artifacts",
            this.appId,
            "public/data/poker-rooms",
            roomId
          );
        }

        validateInputs() {
          const name = document
            .getElementById("player-name-input")
            .value.trim();
          const room = document.getElementById("room-id-input").value.trim();
          const errEl = document.getElementById("room-error");

          if (name.length < 2 || name.length > 10) {
            errEl.innerText = "昵称必须在 2-10 个字符之间";
            return null;
          }
          if (room.length < 1 || room.length > 20) {
            errEl.innerText = "房间 ID 不能为空";
            return null;
          }

          localPlayerName = name; // 存储昵称
          errEl.innerText = "";
          return room;
        }

        // --- 创建房间 ---
        async createRoom() {
          const roomId = this.validateInputs();
          if (!roomId) return;

          this.disableRoomButtons(true);
          const roomRef = this.getRoomRef(roomId);

          try {
            const docSnap = await getDoc(roomRef);
            if (docSnap.exists()) {
              document.getElementById("room-error").innerText =
                "房间已存在，请换个ID";
              this.disableRoomButtons(false);
              return;
            }

            // 创建新玩家
            const newPlayer = {
              uid: this.localUserId,
              id: 0, // 房主总是 0
              name: localPlayerName,
              chips: 1000,
              holeCards: [],
              folded: false,
              currentBet: 0,
              accumulatedBet: 0,
              status: "等待中",
            };

            // 创建新房间状态
            const initialState = {
              status: "waiting", // waiting, playing, finished
              hostId: this.localUserId,
              players: {
                [this.localUserId]: newPlayer,
              },
              playerOrder: [this.localUserId], // 玩家加入顺序
              communityCards: [],
              pot: 0,
              dealerIndex: 0,
              currentPlayerIndex: -1, // -1 表示游戏未开始
              currentMaxBet: 0,
              phase: "waiting",
              lastRaiseAmount: BIG_BLIND,
              deck: [], // 游戏开始时再洗牌
              logs: [`${localPlayerName} 创建了房间.`],
              highlightWinner: null,
              highlightCards: [],
              nextRoundTimer: 0,
              nextPhaseTimer: 0, // *** 新增: 计时器 ***
            };

            await setDoc(roomRef, initialState);
            console.log("房间创建成功:", roomId);
            this.subscribeToRoom(roomId);
          } catch (error) {
            console.error("创建房间失败:", error);
            document.getElementById("room-error").innerText = "创建房间失败";
            this.disableRoomButtons(false);
          }
        }

        // --- 加入房间 ---
        async joinRoom() {
          const roomId = this.validateInputs();
          if (!roomId) return;

          this.disableRoomButtons(true);
          const roomRef = this.getRoomRef(roomId);

          try {
            await runTransaction(this.db, async (transaction) => {
              const roomDoc = await transaction.get(roomRef);
              if (!roomDoc.exists()) {
                throw new Error("房间不存在");
              }

              let state = roomDoc.data();

              // 检查是否已在房间内
              if (state.players[this.localUserId]) {
                console.log("已在房间内，重新加入...");
                // *** 修改: (请求 #1) 如果玩家已存在, 确保他们重置 ***
                if (state.status === "waiting") {
                  state.players[this.localUserId].chips = 1000;
                  state.players[this.localUserId].status = "等待中";
                }
                // *** 结束修改 ***
                transaction.set(roomRef, state); // 确保更新状态
                return; // 直接加入
              }

              // 检查房间状态
              if (state.status !== "waiting") {
                throw new Error("游戏已开始，无法加入");
              }

              // 检查人数
              if (Object.keys(state.players).length >= 10) {
                throw new Error("房间已满");
              }

              // 加入新玩家
              const newPlayerId = Object.keys(state.players).length;
              const newPlayer = {
                uid: this.localUserId,
                id: newPlayerId,
                name: localPlayerName,
                chips: 1000,
                holeCards: [],
                folded: false,
                currentBet: 0,
                accumulatedBet: 0,
                status: "等待中",
              };

              state.players[this.localUserId] = newPlayer;
              state.playerOrder.push(this.localUserId);
              state.logs.push(`${localPlayerName} 加入了房间.`);

              transaction.set(roomRef, state);
            });

            console.log("加入房间成功:", roomId);
            this.subscribeToRoom(roomId);
          } catch (error) {
            console.error("加入房间失败:", error);
            document.getElementById("room-error").innerText =
              error.message || "加入房间失败";
            this.disableRoomButtons(false);
          }
        }

        // --- 退出房间 ---
        async leaveRoom() {
          if (this.unsubscribeRoom) {
            this.unsubscribeRoom(); // 停止监听
            this.unsubscribeRoom = null;
          }

          const roomId = this.currentRoomId;
          const userId = this.localUserId;

          if (roomId && userId) {
            const roomRef = this.getRoomRef(roomId);
            try {
              // 尝试从房间中移除自己
              await runTransaction(this.db, async (transaction) => {
                const roomDoc = await transaction.get(roomRef);
                if (!roomDoc.exists()) return;

                let state = roomDoc.data();

                // 1. 从 players 和 playerOrder 移除
                if (state.players[userId]) {
                  const playerName = state.players[userId].name;
                  delete state.players[userId];
                  state.playerOrder = state.playerOrder.filter(
                    (uid) => uid !== userId
                  );
                  state.logs.push(`${playerName} 离开了房间.`); // 使用
                }

                // 2. 检查是否需要删除房间
                if (state.playerOrder.length === 0) {
                  transaction.delete(roomRef);
                  console.log("房间空了，自动删除");
                }
                // 3. 检查房主是否离开
                else if (state.hostId === userId) {
                  // 移交房主给下一个人
                  state.hostId = state.playerOrder[0];
                  state.logs.push(
                    `房主移交给 ${state.players[state.hostId].name}.`
                  );
                  transaction.set(roomRef, state);
                }
                // 4. 正常离开
                else {
                  transaction.set(roomRef, state);
                }
              });
            } catch (error) {
              console.error("离开房间时出错:", error);
            }
          }

          // 重置 UI
          this.currentRoomId = null;
          if (this.nextRoundTimeout) clearTimeout(this.nextRoundTimeout);
          if (this.nextPhaseTimeout) clearTimeout(this.nextPhaseTimeout); // *** 新增: 清除计时器 ***

          document.getElementById("game-area").classList.add("hidden");
          document.getElementById("game-over-screen").classList.add("hidden");
          document.getElementById("room-screen").classList.remove("hidden");
          this.disableRoomButtons(false);
        }

        // --- 订阅房间更新 ---
        subscribeToRoom(roomId) {
          this.currentRoomId = roomId;
          document.getElementById("room-screen").classList.add("hidden");
          document.getElementById("game-area").classList.remove("hidden");
          this.gameUI.initSound();
          this.gameUI.occlusionManager.start();

          const roomRef = this.getRoomRef(roomId);
          this.unsubscribeRoom = onSnapshot(
            roomRef,
            (doc) => {
              if (!doc.exists()) {
                // 房间被删除了
                console.log("房间不存在或已被删除。");
                this.gameUI.showMessage("房主已解散房间");
                setTimeout(() => this.leaveRoom(), 2000);
                return;
              }

              const state = doc.data();

              // --- 核心：渲染状态 ---
              this.gameUI.renderGameState(state, this.localUserId);

              // --- 修改: 运行房主控制逻辑 (仅限计时器) ---
              this.runHostTimerController(state);
            },
            (error) => {
              console.error("监听房间失败:", error);
              this.leaveRoom();
            }
          );
        }

        // --- 修改: 房主计时器控制逻辑 (移除了 AI) ---
        runHostTimerController(state) {
          // 1. 检查是否轮到房主自动推进 All-in 阶段
          if (state.nextPhaseTimer > 0 && state.hostId === this.localUserId) {
            if (!this.nextPhaseTimeout) {
              // 防止重复设置
              this.nextPhaseTimeout = setTimeout(async () => {
                console.log("房主：自动推进All-in阶段");
                this.nextPhaseTimeout = null;
                const roomRef = this.getRoomRef(this.currentRoomId);
                try {
                  let currentState = (await getDoc(roomRef)).data();
                  // 确保计时器仍然有效
                  if (currentState.nextPhaseTimer > 0) {
                    currentState.nextPhaseTimer = 0; // 清除计时器
                    // 再次调用 runAutoShowdown, 它会自动处理下一阶段 (turn -> river -> showdown)
                    const nextState = runAutoShowdown(currentState);
                    await setDoc(roomRef, nextState);
                  }
                } catch (error) {
                  console.error("推进All-in阶段失败:", error);
                }
              }, state.nextPhaseTimer);
            }
          } else if (state.nextPhaseTimer === 0 && this.nextPhaseTimeout) {
            // 状态已被其他人清除, 取消本地计时器
            clearTimeout(this.nextPhaseTimeout);
            this.nextPhaseTimeout = null;
          }

          // 2. 检查是否轮到房主自动开始新回合
          if (state.phase === "showdown" && state.hostId === this.localUserId) {
            if (state.nextRoundTimer > 0 && !this.nextRoundTimeout) {
              this.nextRoundTimeout = setTimeout(async () => {
                console.log("房主：自动开始新回合");
                this.nextRoundTimeout = null;
                const roomRef = this.getRoomRef(this.currentRoomId);
                try {
                  // 获取最新状态
                  const currentState = (await getDoc(roomRef)).data();
                  // 确保仍然是摊牌阶段
                  if (currentState.phase === "showdown") {
                    const nextState = startNewRound(currentState);
                    await setDoc(roomRef, nextState);
                  }
                } catch (error) {
                  console.error("开始新回合失败:", error);
                }
              }, state.nextRoundTimer);
            }
          }

          // 3. 移除了 AI 行动检查
        }

        // --- 房主开始游戏 ---
        async startGame() {
          if (
            !this.currentRoomId ||
            this.localUserId !== this.gameUI.lastState.hostId
          )
            return;

          const btn = document.getElementById("btn-start-game");
          if (btn.classList.contains("btn-disabled")) return;

          btn.classList.add("btn-disabled");

          const roomRef = this.getRoomRef(this.currentRoomId);
          try {
            const currentState = this.gameUI.lastState; // 使用本地的最新状态
            if (currentState.status !== "waiting") return;

            // 1. 标记游戏开始
            currentState.status = "playing";

            // 2. 调用新回合逻辑
            const nextState = startNewRound(currentState);

            // 3. 写入 Firestore
            await setDoc(roomRef, nextState);
          } catch (error) {
            console.error("开始游戏失败:", error);
            btn.classList.remove("btn-disabled");
          }
        }

        // --- 玩家提交动作 ---
        async handleHumanAction(action) {
          const state = this.gameUI.lastState;
          if (
            !state ||
            state.playerOrder[state.currentPlayerIndex] !== this.localUserId
          ) {
            return; // 不是你的回合
          }

          // 禁用按钮，防止重复提交
          this.gameUI.updateControls({ ...state, currentPlayerIndex: -1 }); // 假装不是你的回合

          let actionAmount = 0;
          if (action === "raise") {
            // *** 修复: actionAmount 是 "行动金额" (来自 读博.html 逻辑) ***
            actionAmount = parseInt(
              document.getElementById("raise-slider").value
            );
          }

          const roomRef = this.getRoomRef(this.currentRoomId);

          try {
            // 使用事务来处理动作，防止冲突
            await runTransaction(this.db, async (transaction) => {
              const roomDoc = await transaction.get(roomRef);
              if (!roomDoc.exists()) throw new Error("房间不存在");

              const currentState = roomDoc.data();

              // 再次验证是否是该玩家的回合
              if (
                currentState.playerOrder[currentState.currentPlayerIndex] !==
                this.localUserId
              ) {
                console.warn("动作提交时已不是你的回合");
                // 此时 UI 应该已经更新，但我们不处理这个旧动作
                return;
              }

              // *** 修复: 将 "行动金额" (actionAmount) 转换为 "总金额" (totalAmount) ***
              // processAction 期望的 'amount' 是玩家下注后的 *总金额*
              let totalAmount = 0;
              const player = currentState.players[this.localUserId];

              if (action === "raise") {
                // "行动金额" (actionAmount) 是玩家 *本次* 支付的钱
                // "总金额" (totalAmount) 是玩家支付后 *总共* 在桌上的钱
                totalAmount = player.currentBet + actionAmount;
              }
              // *** 结束修复 ***

              // --- 核心：调用纯函数计算下一个状态 ---
              // *** 修复: 传递 totalAmount ***
              const nextState = processAction(
                currentState,
                this.localUserId,
                action,
                totalAmount
              );

              // 写入新状态
              transaction.set(roomRef, nextState);
            });
          } catch (error) {
            console.error("处理动作失败:", error);
            // 重新启用按钮 (在下一次 onSnapshot 更新时会自动处理)
          }
        }

        // --- 移除: submitBotAction 函数 ---

        // --- 移除: addAiPlayer 函数 ---

        // --- 移除: removePlayer 函数 ---

        // --- 移除: getAiAction 函数 ---

        disableRoomButtons(disabled) {
          document.getElementById("btn-join-room").disabled = disabled;
          document.getElementById("btn-create-room").disabled = disabled;
          if (disabled) {
            document
              .getElementById("btn-join-room")
              .classList.add("btn-disabled");
            document
              .getElementById("btn-create-room")
              .classList.add("btn-disabled");
          } else {
            document
              .getElementById("btn-join-room")
              .classList.remove("btn-disabled");
            document
              .getElementById("btn-create-room")
              .classList.remove("btn-disabled");
          }
        }
      }

      // --- (从单机版复制的辅助类) ---
      class SoundManager {
        constructor() {
          this.ctx = null;
          this.enabled = false;
        }
        init() {
          if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true;
          }
          if (this.ctx.state === "suspended") this.ctx.resume();
        }
        playTone(freq, type, duration, vol = 0.1, when = 0) {
          if (!this.enabled) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime + when);
          gain.gain.setValueAtTime(vol, this.ctx.currentTime + when);
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            this.ctx.currentTime + when + duration
          );
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start(this.ctx.currentTime + when);
          osc.stop(this.ctx.currentTime + when + duration);
        }
        playChip() {
          this.playTone(2000, "square", 0.05, 0.03);
        }
        playCard() {
          this.playTone(800, "sine", 0.1, 0.02);
        }
        playCheck() {
          this.playTone(300, "sine", 0.05, 0.1);
          this.playTone(300, "sine", 0.05, 0.1, 0.1);
        }
        playFold() {
          this.playTone(150, "triangle", 0.3, 0.1);
        }
        playAllIn() {
          if (!this.enabled) return;
          const t = this.ctx.currentTime;
          this.playTone(100, "sawtooth", 0.4, 0.4, 0);
          this.playTone(50, "square", 1.0, 0.5, 0.1);
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(800, t);
          osc.frequency.exponentialRampToValueAtTime(100, t + 0.3);
          gain.gain.setValueAtTime(0.1, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.3);
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start();
          osc.stop(t + 0.3);
        }
        playRaise() {
          this.playTone(1500, "square", 0.08, 0.04);
          this.playTone(1000, "square", 0.08, 0.04, 0.05);
        }

        // --- 恢复的逻辑: 局结束音效 (来自 读博.html) ---
        playHandEnd() {
          this.playTone(440, "sine", 0.2, 0.1);
        }
        // --- 结束 ---

        playWin() {
          [523, 659, 784, 1046].forEach((f, i) =>
            this.playTone(f, "triangle", 0.4, 0.15, i * 0.15)
          );
        }
        playLose() {
          this.playTone(100, "sawtooth", 1.0, 0.2);
          this.playTone(80, "sawtooth", 1.0, 0.2, 0.3);
        }
      }
      class OcclusionManager {
        constructor() {
          this.communityArea = document.getElementById("community-area");
          this.gameMessage = document.getElementById("game-message");
          this.isRunning = false;
          this.checkLoop = null;
        }
        start() {
          if (this.isRunning) return;
          this.isRunning = true;
          this.checkLoop = setInterval(() => this.check(), 100);
        }
        stop() {
          this.isRunning = false;
          clearInterval(this.checkLoop);
        }
        getOverlapRatio(r1, r2) {
          if (!r1 || !r2) return 0;
          const overlapLeft = Math.max(r1.left, r2.left);
          const overlapRight = Math.min(r1.right, r2.right);
          const overlapTop = Math.max(r1.top, r2.top);
          const overlapBottom = Math.min(r1.bottom, r2.bottom);
          if (overlapLeft >= overlapRight || overlapTop >= overlapBottom)
            return 0;
          const overlapArea =
            (overlapRight - overlapLeft) * (overlapBottom - overlapTop);
          const area1 = r1.width * r1.height;
          const area2 = r2.width * r2.height;
          return overlapArea / Math.min(area1, area2);
        }
        check() {
          const seats = document.querySelectorAll(".player-seat");
          if (seats.length === 0) return;
          const cardTargets = [];
          seats.forEach((seat) => {
            const cardsDiv = seat.querySelector('div[id^="cards-"]');
            if (cardsDiv && cardsDiv.children.length > 0)
              cardTargets.push(cardsDiv.getBoundingClientRect());
          });
          const commRect = this.communityArea.getBoundingClientRect();
          if (commRect.width > 10 && commRect.height > 10) {
            let commObstructed = false;
            for (const targetRect of cardTargets) {
              if (this.getOverlapRatio(targetRect, commRect) > 0.2) {
                commObstructed = true;
                break;
              }
            }
            if (!commObstructed) {
              seats.forEach((seat) => {
                const infoBox = seat.querySelector(".player-info-box");
                if (infoBox) {
                  if (
                    this.getOverlapRatio(
                      infoBox.getBoundingClientRect(),
                      commRect
                    ) > 0.2
                  )
                    commObstructed = true;
                }
              });
            }
            this.applyTransparency(this.communityArea, commObstructed);
          } else {
            this.applyTransparency(this.communityArea, false);
          }
          if (this.gameMessage && this.gameMessage.style.opacity !== "0") {
            let msgObstructed = false;
            const msgRect = this.gameMessage.getBoundingClientRect();
            if (commRect.width > 10 && commRect.height > 10) {
              if (this.getOverlapRatio(msgRect, commRect) > 0.2)
                msgObstructed = true;
            }
            if (!msgObstructed) {
              for (const targetRect of cardTargets) {
                if (this.getOverlapRatio(msgRect, targetRect) > 0.2) {
                  msgObstructed = true;
                  break;
                }
              }
            }
            this.applyTransparency(this.gameMessage, msgObstructed);
          }
        }
        applyTransparency(el, shouldBeTransparent) {
          if (shouldBeTransparent) {
            if (!el.classList.contains("smart-transparent"))
              el.classList.add("smart-transparent");
          } else {
            if (el.classList.contains("smart-transparent"))
              el.classList.remove("smart-transparent");
          }
        }
      }
      class TableDragSystem {
        constructor() {
          this.container = document.getElementById("table-area");
          this.table = document.getElementById("table");
          this.isDragging = false;
          this.startY = 0;
          this.currentY = 30;
          this.initialDragY = 0;
          this.init();
        }
        init() {
          this.container.addEventListener("mousedown", this.onStart.bind(this));
          window.addEventListener("mousemove", this.onMove.bind(this));
          window.addEventListener("mouseup", this.onEnd.bind(this));
          this.container.addEventListener(
            "touchstart",
            this.onStart.bind(this),
            { passive: false }
          );
          window.addEventListener("touchmove", this.onMove.bind(this), {
            passive: false,
          });
          window.addEventListener("touchend", this.onEnd.bind(this));
          this.updateTransform();
        }
        onStart(e) {
          if (e.target.closest("button") || e.target.closest("input")) return;
          this.isDragging = true;
          this.startY = this.getY(e);
          this.initialDragY = this.currentY;
          this.table.classList.remove("duration-500");
          this.table.classList.add("duration-0");
          this.container.classList.add("cursor-grabbing");
          this.container.classList.remove("cursor-grab");
        }
        onMove(e) {
          if (!this.isDragging) return;
          e.preventDefault();
          const y = this.getY(e);
          const diff = y - this.startY;
          this.currentY = this.initialDragY + diff;
          if (this.currentY > 180) this.currentY = 180;
          if (this.currentY < -120) this.currentY = -120;
          this.updateTransform();
          if (window.occlusionManager) window.occlusionManager.check();
        }
        onEnd() {
          if (!this.isDragging) return;
          this.isDragging = false;
          this.table.classList.remove("duration-0");
          this.table.classList.add("duration-500");
          this.container.classList.remove("cursor-grabbing");
          this.container.classList.add("cursor-grab");
        }
        getY(e) {
          return e.touches ? e.touches[0].clientY : e.clientY;
        }
        updateTransform() {
          this.table.style.transform = `translateY(${this.currentY}px)`;
        }
      }

      // *** 修复: 替换整个 HandEvaluator 类 ***
      class HandEvaluator {
        static evaluate(holeCards, communityCards) {
          if (!holeCards || holeCards.length === 0)
            return { score: 0, name: "无", bestCards: [] };

          // *** 修正: 标记手牌并优先排序 ***
          // 1. 合并所有牌，并标记来源 (isHole)
          const all = [
            ...holeCards.map((c) => ({ ...c, isHole: true })),
            ...communityCards.map((c) => ({ ...c, isHole: false })),
          ];

          // 2. 排序: 优先按点数，点数相同，手牌(true=1)优先于公共牌(false=0)
          all.sort((a, b) => {
            if (b.value !== a.value) return b.value - a.value;
            return b.isHole - a.isHole;
          });
          // *** 结束修正 ***

          // getKickers 会自动从排好序的 'all' 数组中取牌
          const getKickers = (excludeCards, count) => {
            const kickers = [];
            const excludeIds = new Set(excludeCards.map((c) => c.id));
            for (const c of all) {
              // 'all' 已经排好序
              if (!excludeIds.has(c.id)) {
                kickers.push(c);
                if (kickers.length === count) break;
              }
            }
            return kickers;
          };

          // calcScore 仅用于计算分数，不影响 'bestCards'
          const calcScore = (rankVal, mainCards, kickers) => {
            let s = rankVal * Math.pow(100, 5);
            mainCards.forEach((c, i) => {
              s += c.value * Math.pow(100, 4 - i);
            });
            kickers.forEach((c, i) => {
              s += c.value * Math.pow(100, 4 - mainCards.length - i);
            });
            return s;
          };

          // 寻找同花 (flushCards 也会保持 'all' 的排序)
          const suits = {};
          all.forEach((c) => {
            if (!suits[c.suit]) suits[c.suit] = [];
            suits[c.suit].push(c);
          });
          let flushCards = null;
          for (let s in suits) {
            if (suits[s].length >= 5) {
              flushCards = suits[s].slice(0, 5); // .slice(0,5) 保留了排序
              break;
            }
          }

          // 寻找顺子 (cardsToCheck 也会保持 'all' 的排序)
          const getStraightCards = (cardsToCheck) => {
            // .map 再 new Set 会丢失 isHole 排序, 但没关系
            const uniqueVals = [
              ...new Set(cardsToCheck.map((c) => c.value)),
            ].sort((a, b) => b - a);

            // A-5 顺子 (特殊处理)
            if (
              uniqueVals.includes(14) &&
              uniqueVals.includes(5) &&
              uniqueVals.includes(4) &&
              uniqueVals.includes(3) &&
              uniqueVals.includes(2)
            ) {
              const straightVals = [5, 4, 3, 2, 14];
              const best5 = [];
              const usedIds = new Set();
              straightVals.forEach((v) => {
                // .find() 会找到 'cardsToCheck' (已排序) 中的第一张
                const card = cardsToCheck.find(
                  (c) => c.value === v && !usedIds.has(c.id)
                );
                if (card) {
                  // 确保卡片被找到
                  best5.push(card);
                  usedIds.add(c.id);
                }
              });
              // *** 修复: 必须确保找到了5张牌 ***
              if (best5.length === 5) return { cards: best5, high: 5 };
              // *** 结束修复 ***
            }

            // K-Q-J-10-9 顺子
            for (let i = 0; i <= uniqueVals.length - 5; i++) {
              if (uniqueVals[i] - uniqueVals[i + 4] === 4) {
                const straightVals = uniqueVals.slice(i, i + 5);
                const best5 = [];
                const usedIds = new Set();
                straightVals.forEach((v) => {
                  // .find() 会找到 'cardsToCheck' (已排序) 中的第一张
                  const card = cardsToCheck.find(
                    (c) => c.value === v && !usedIds.has(c.id)
                  );
                  if (card) {
                    // 确保卡片被找到
                    best5.push(card);
                    usedIds.add(c.id);
                  }
                });
                // *** 修复: 必须确保找到了5张牌 ***
                if (best5.length === 5)
                  return { cards: best5, high: uniqueVals[i] };
                // *** 结束修复 ***
              }
            }
            return null;
          };

          // 1. 同花顺
          if (flushCards) {
            const sf = getStraightCards(flushCards); // flushCards 保持了 'isHole' 排序
            if (sf)
              return {
                score: calcScore(9, [sf.cards[0]], []),
                name: "同花顺",
                bestCards: sf.cards,
              };
          }

          // 2. 四条
          const counts = {};
          all.forEach((c) => (counts[c.value] = (counts[c.value] || 0) + 1));
          const fours = Object.keys(counts)
            .filter((v) => counts[v] === 4)
            .map(Number)
            .sort((a, b) => b - a);
          const threes = Object.keys(counts)
            .filter((v) => counts[v] === 3)
            .map(Number)
            .sort((a, b) => b - a);
          const pairs = Object.keys(counts)
            .filter((v) => counts[v] === 2)
            .map(Number)
            .sort((a, b) => b - a);
          if (fours.length > 0) {
            const fourVal = fours[0];
            const quadCards = all.filter((c) => c.value === fourVal); // .filter() 保持了 'isHole' 排序
            const kicker = getKickers(quadCards, 1); // getKickers 保持了 'isHole' 排序
            return {
              score: calcScore(8, [quadCards[0]], kicker),
              name: "四条",
              bestCards: [...quadCards, ...kicker],
            };
          }

          // 3. 葫芦
          if (threes.length > 0 && (threes.length > 1 || pairs.length > 0)) {
            const threeVal = threes[0];
            const pairVal = threes.length > 1 ? threes[1] : pairs[0];
            const threeCards = all
              .filter((c) => c.value === threeVal)
              .slice(0, 3); // .filter().slice() 保持了 'isHole' 排序
            const pairCards = all
              .filter((c) => c.value === pairVal)
              .slice(0, 2); // .filter().slice() 保持了 'isHole' 排序
            return {
              score: calcScore(7, [threeCards[0], pairCards[0]], []),
              name: "葫芦",
              bestCards: [...threeCards, ...pairCards],
            };
          }

          // 4. 同花
          if (flushCards) {
            return {
              score: calcScore(6, flushCards, []),
              name: "同花",
              bestCards: flushCards,
            }; // flushCards 保持了 'isHole' 排序
          }

          // 5. 顺子
          const straight = getStraightCards(all); // 'all' 保持了 'isHole' 排序
          if (straight) {
            return {
              score: calcScore(5, [straight.cards[0]], []),
              name: "顺子",
              bestCards: straight.cards,
            };
          }

          // 6. 三条
          if (threes.length > 0) {
            const threeVal = threes[0];
            const threeCards = all
              .filter((c) => c.value === threeVal)
              .slice(0, 3); // .filter().slice() 保持了 'isHole' 排序
            const kickers = getKickers(threeCards, 2); // getKickers 保持了 'isHole' 排序
            return {
              score: calcScore(4, [threeCards[0]], kickers),
              name: "三条",
              bestCards: [...threeCards, ...kickers],
            };
          }

          // 7. 两对
          if (pairs.length >= 2) {
            const p1 = pairs[0];
            const p2 = pairs[1];
            const pair1Cards = all.filter((c) => c.value === p1).slice(0, 2); // .filter().slice() 保持了 'isHole' 排序
            const pair2Cards = all.filter((c) => c.value === p2).slice(0, 2); // .filter().slice() 保持了 'isHole' 排序
            const kicker = getKickers([...pair1Cards, ...pair2Cards], 1); // getKickers 保持了 'isHole' 排序
            return {
              score: calcScore(3, [pair1Cards[0], pair2Cards[0]], kicker),
              name: "两对",
              bestCards: [...pair1Cards, ...pair2Cards, ...kicker],
            };
          }

          // 8. 一对
          if (pairs.length === 1) {
            const p1 = pairs[0];
            const pairCards = all.filter((c) => c.value === p1).slice(0, 2); // .filter().slice() 保持了 'isHole' 排序
            const kickers = getKickers(pairCards, 3); // getKickers 保持了 'isHole' 排序
            return {
              score: calcScore(2, [pairCards[0]], kickers),
              name: "一对",
              bestCards: [...pairCards, ...kickers],
            };
          }

          // 9. 高牌
          const highCards = all.slice(0, 5); // .slice() 保持了 'isHole' 排序
          return {
            score: calcScore(1, highCards, []),
            name: "高牌",
            bestCards: highCards,
          };
        }
      }

      // --- 游戏启动 ---

      // 将关键实例暴露给 window，以便 HTML onclick 事件可以调用
      const gameUI = new GameUIManager();
      const network = new NetworkManager(gameUI);

      window.network = network; // 暴露 network.createRoom, .joinRoom 等
      window.gameUI = gameUI; // 暴露 gameUI.adjustRaise

      // 启动 Firebase
      network.init();

      // 移除旧的单机版逻辑
      // (旧的 game = new PokerGame() 和 restartGame() 已被 network.leaveRoom 替代)
    </script>

    <!-- 移除旧的 <script> ... </script> 块 -->
  </body>
</html>
