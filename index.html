<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Texas Hold'em (Online)</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♠️</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Black+Ops+One&family=Noto+Sans+JP:wght@500;700&family=Noto+Sans+SC:wght@500;700&display=swap");

    body {
      font-family: "Inter", "Noto Sans JP", "Noto Sans SC", "Microsoft YaHei", sans-serif;
      background-color: #111827;
      color: white;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      height: 100dvh;
      width: 100vw;
    }

    /* --- Card Styles --- */
    .card {
      width: 42px;
      height: 60px;
      background-color: white;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 16px;
      position: relative;
      transition: transform 0.3s, box-shadow 0.3s;
      z-index: 10;
      border: 1px solid #e5e7eb;
    }

    @media (min-width: 768px) {
      .card {
        width: 56px;
        height: 78px;
        font-size: 20px;
        border-radius: 6px;
      }
    }

    .card.red {
      color: #dc2626;
    }

    .card.black {
      color: #1f2937;
    }

    .card-back {
      background: repeating-linear-gradient(45deg,
          #1e3a8a,
          #1e3a8a 10px,
          #172554 10px,
          #172554 20px);
      border: 2px solid #e2e8f0;
    }

    .card-back span {
      display: none;
    }

    .card-placeholder {
      width: 42px;
      height: 60px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      border: none;
      background: transparent;
    }

    .card-placeholder:empty {
      border: 2px dashed rgba(255, 255, 255, 0.2);
      background-color: rgba(0, 0, 0, 0.2);
      box-sizing: border-box;
    }

    @media (min-width: 768px) {
      .card-placeholder {
        width: 56px;
        height: 78px;
        border-radius: 6px;
      }
    }

    .card.winning-card {
      box-shadow: 0 0 15px 5px rgba(251, 191, 36, 0.9);
      border: 3px solid #fbbf24;
      z-index: 100;
    }

    /* --- Table --- */
    .poker-table {
      background: radial-gradient(circle, #15803d 0%, #064e3b 90%, #022c22 100%);
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.9), 0 0 0 12px #374151, 0 0 0 16px #1f2937;
      position: relative;
      border-radius: 180px;
      transform: translateY(0px);
      will-change: transform;
    }

    @media (min-width: 768px) {
      .poker-table {
        transform: translateY(30px);
      }
    }

    .cursor-grab {
      cursor: grab;
    }

    .cursor-grabbing {
      cursor: grabbing;
    }

    .player-seat {
      position: absolute;
      transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.6s, top 0.6s;
      width: 120px;
      height: 110px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transform-origin: center center;
      pointer-events: none;
    }

    .player-seat>* {
      pointer-events: auto;
    }

    .player-info-box {
      background: linear-gradient(180deg, rgba(31, 41, 55, 0.95) 0%, rgba(17, 24, 39, 0.98) 100%);
      border: 1px solid #4b5563;
      border-radius: 6px;
      padding: 4px 2px;
      width: 100%;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
      transition: all 0.3s ease;
      position: relative;
    }

    .dealer-btn {
      width: 20px;
      height: 20px;
      background: radial-gradient(circle at 30% 30%, #fff, #cbd5e0);
      color: #1a202c;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 900;
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      top: -8px;
      right: -6px;
      border: 1px solid #9ca3af;
      z-index: 30;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
    }

    .active-player .player-info-box {
      box-shadow: 0 0 0 2px #fbbf24, 0 0 20px rgba(251, 191, 36, 0.4);
      border-color: #f59e0b;
      background: linear-gradient(180deg, #374151 0%, #1f2937 100%);
      transform: translateY(-2px);
      z-index: 40;
    }

    .winner-highlight .player-info-box {
      box-shadow: 0 0 0 3px #22c55e, 0 0 30px rgba(34, 197, 94, 0.6);
      border-color: #22c55e;
      background: linear-gradient(180deg, #064e3b 0%, #065f46 100%);
      z-index: 50;
    }

    /* --- All-in VFX --- */
    .all-in-fullscreen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.3);
      animation: fadeIn 0.2s ease-out;
    }

    .all-in-bar {
      position: absolute;
      top: 50%;
      left: 0;
      width: 100%;
      height: 140px;
      background: rgba(0, 0, 0, 0.95);
      transform: translateY(-50%) translateX(-100%);
      animation: barSlideIn 0.4s cubic-bezier(0.05, 0.7, 0.1, 1) forwards;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
      border-top: 2px solid rgba(234, 179, 8, 0.6);
      border-bottom: 2px solid rgba(234, 179, 8, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    @keyframes barSlideIn {
      from {
        transform: translateY(-50%) translateX(-100%);
      }

      to {
        transform: translateY(-50%) translateX(0%);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .all-in-text {
      position: relative;
      font-family: "Black Ops One", system-ui, sans-serif;
      font-size: 90px;
      white-space: nowrap;
      text-transform: uppercase;
      letter-spacing: 4px;
      background: linear-gradient(to bottom, #fef08a 0%, #eab308 45%, #a16207 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 5px 3px rgba(0, 0, 0, 0.5));
      text-shadow: 0 0 30px rgba(234, 179, 8, 0.6);
      opacity: 0;
      transform: scale(2);
      animation: textImpact 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards 0.2s;
    }

    @keyframes textImpact {
      0% {
        opacity: 0;
        transform: scale(2);
        filter: blur(10px);
      }

      100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0px);
      }
    }

    .all-in-bar::after {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 30%;
      height: 100%;
      background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.4), transparent);
      transform: skewX(-25deg);
      animation: shine 1s infinite 0.5s;
    }

    @keyframes shine {
      0% {
        left: -50%;
      }

      100% {
        left: 150%;
      }
    }

    input[type="range"]::-webkit-slider-thumb {
      background: #fbbf24;
    }

    .adjust-btn:active {
      transform: scale(0.95);
      background-color: #4b5563;
    }

    .smart-transparent {
      opacity: 0.15 !important;
      transition: opacity 0.2s ease-out;
      pointer-events: none;
    }

    /* --- Loader & Screens --- */
    .firebase-loader {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #111827;
      z-index: 10000;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #4b5563;
      border-top-color: #f59e0b;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    #room-screen {
      z-index: 50;
      background: rgba(17, 24, 39, 0.95);
      backdrop-filter: blur(10px);
    }

    .btn-disabled {
      background-color: #4b5563 !important;
      border-color: #374151 !important;
      color: #9ca3af !important;
      cursor: not-allowed !important;
      transform: none !important;
    }

    #bottom-bar {
      padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
    }
  </style>
</head>

<body class="h-[100dvh] w-screen flex flex-col items-center justify-center bg-gray-950">
  <div id="firebase-loader" class="firebase-loader">
    <div class="spinner"></div>
    <p class="text-gray-400 mt-4 text-sm font-medium" data-i18n="connecting">Connecting to server...</p>
  </div>

  <!-- Room Selection Screen -->
  <div id="room-screen"
    class="hidden absolute z-50 bg-gray-900 p-8 rounded-xl shadow-2xl border border-gray-700 w-11/12 max-w-md">
    <!-- Language Selector -->
    <div class="absolute top-4 right-4">
      <select id="language-selector" onchange="updateLanguage(this.value)"
        class="bg-gray-800 text-gray-300 text-xs rounded px-2 py-1 border border-gray-600 focus:outline-none focus:border-yellow-500">
        <option value="en" selected>English</option>
        <option value="ja">日本語</option>
        <option value="zh">中文</option>
      </select>
    </div>

    <h1 class="text-3xl font-bold text-yellow-500 mb-6 tracking-tight text-center" data-i18n="gameTitle">
      Texas Hold'em
    </h1>

    <div class="mb-4">
      <label class="block text-gray-400 mb-2 text-sm font-bold" for="player-name-input" data-i18n="nicknameLabel">Your
        Nickname</label>
      <input type="text" id="player-name-input"
        class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
        placeholder="" />
    </div>
    <div class="mb-6">
      <label class="block text-gray-400 mb-2 text-sm font-bold" for="room-id-input" data-i18n="roomIdLabel">Room
        ID</label>
      <input type="text" id="room-id-input"
        class="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-yellow-500"
        placeholder="" />
    </div>
    <div class="flex space-x-4 mb-4">
      <button onclick="network.joinRoom()" id="btn-join-room" data-i18n="joinRoomBtn"
        class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">
        Join Room
      </button>
      <button onclick="network.createRoom()" id="btn-create-room" data-i18n="createRoomBtn"
        class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-lg border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1">
        Create Room
      </button>
    </div>
    <p id="room-error" class="text-red-400 text-sm h-5 text-center"></p>
    <p class="text-gray-500 text-xs mt-4 text-center">
      User ID: <span id="user-id-display">...</span>
    </p>
  </div>

  <!-- Game Area -->
  <div id="game-area" class="hidden w-full h-full relative flex flex-col">
    <div id="top-bar"
      class="h-16 bg-gray-900 w-full flex items-center justify-between px-6 shadow-lg z-10 border-b border-gray-800 relative z-50">
      <div class="flex items-center space-x-2">
        <div class="text-yellow-500 font-black text-2xl tracking-tight">
          <span data-i18n="pot">Pot</span>: $<span id="pot-display">0</span>
        </div>
      </div>

      <div class="flex items-center space-x-4">
        <div class="flex flex-col items-center mr-1 bg-gray-800 px-2 py-1 rounded border border-gray-700">
          <span class="text-gray-500 text-[10px] font-bold leading-none mb-1" data-i18n="room">Room</span>
          <span id="display-room-id" class="text-yellow-500 font-mono font-bold text-sm leading-none">---</span>
        </div>
        <div class="text-right hidden sm:block">
          <div id="blinds-display" class="text-gray-400 text-xs font-bold tracking-wider">
            Blinds $10/$20
          </div>
          <div class="text-gray-600 text-[10px]">
            <span data-i18n="online">Online</span>: <span id="active-players-count">0</span>
          </div>
        </div>

        <button id="btn-leave-room" onclick="network.leaveRoom()" data-i18n="leaveRoomBtn"
          class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-2 px-4 rounded-lg text-xs shadow-md">
          Leave
        </button>
      </div>
    </div>

    <div id="table-area"
      class="flex-grow relative overflow-hidden flex items-center justify-center bg-gray-950 cursor-grab active:cursor-grabbing">
      <div id="table"
        class="poker-table w-[95vw] h-[55vh] md:w-[800px] md:h-[450px] max-w-full relative transition-all duration-500">
        <div id="community-area"
          class="absolute top-[42%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 flex flex-col items-center z-20 transition-opacity duration-200">
          <div id="community-cards"
            class="flex flex-wrap justify-center items-center gap-1 sm:gap-2 max-w-[150px] md:max-w-none transition-all duration-300">
            <div id="comm-slot-0" class="card-placeholder"></div>
            <div id="comm-slot-1" class="card-placeholder"></div>
            <div id="comm-slot-2" class="card-placeholder"></div>
            <div id="comm-slot-3" class="card-placeholder"></div>
            <div id="comm-slot-4" class="card-placeholder"></div>
          </div>
        </div>
        <div id="game-message"
          class="absolute top-[23%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-yellow-100 font-bold text-xl text-center z-30 pointer-events-none drop-shadow-lg px-4 py-2 rounded whitespace-nowrap transition-opacity duration-300 opacity-0">
        </div>
        <div id="seats-container" class="w-full h-full relative"></div>
      </div>
    </div>

    <div id="bottom-bar"
      class="bg-gray-900 p-4 shadow-[0_-5px_15px_rgba(0,0,0,0.5)] z-20 border-t border-gray-800 relative z-50">
      <div id="game-log"
        class="h-16 overflow-y-auto text-xs text-gray-500 mb-3 font-mono bg-gray-950 p-2 rounded border border-gray-800 scroll-smooth leading-5">
        <div data-i18n="log_welcome">System: Welcome to Texas Hold'em.</div>
      </div>
      <div id="player-controls"
        class="flex flex-col items-center opacity-50 pointer-events-none transition-all duration-300 transform translate-y-2">
        <div id="raise-slider-container" class="w-full max-w-md mb-4 flex items-center space-x-2 px-2">
          <span class="text-xs text-gray-500 font-bold tracking-wider w-8 text-center" data-i18n="raiseLabel">Bet</span>
          <button onclick="gameUI.adjustRaise(-1)"
            class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700">
            -
          </button>
          <input type="range" id="raise-slider" step="1"
            class="flex-grow h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mx-2" />
          <button onclick="gameUI.adjustRaise(1)"
            class="adjust-btn w-8 h-8 bg-gray-800 hover:bg-gray-700 rounded-full text-yellow-500 font-bold flex items-center justify-center shadow border border-gray-700">
            +
          </button>
          <span id="raise-val-display" class="text-sm text-yellow-400 w-14 text-right font-mono font-bold">$0</span>
        </div>
        <div class="flex justify-center space-x-3 w-full max-w-lg">
          <button onclick="network.handleHumanAction('fold')" data-i18n="foldBtn"
            class="flex-1 bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">
            Fold
          </button>
          <button onclick="network.handleHumanAction('check')" id="btn-check" data-i18n="checkBtn"
            class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1">
            Check
          </button>
          <button onclick="network.handleHumanAction('call')" id="btn-call" data-i18n="callBtn"
            class="flex-1 bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-blue-900 active:border-b-0 active:translate-y-1 hidden">
            Call
          </button>
          <button onclick="network.handleHumanAction('raise')" id="btn-raise" data-i18n="raiseBtn"
            class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 rounded-md shadow-md text-sm border-b-4 border-yellow-800 active:border-b-0 active:translate-y-1">
            Raise
          </button>
        </div>
      </div>
      <div class="text-center mt-2 text-gray-700 text-[10px] font-mono tracking-wider">
        <span data-i18n="phaseLabel">Phase</span>: <span id="phase-display" class="text-gray-500"
          data-i18n="waiting">Waiting</span>
      </div>
    </div>

    <div id="waiting-room-overlay"
      class="hidden absolute top-0 left-0 w-full h-full z-40 flex flex-col items-center justify-center pointer-events-none">
      <div id="wait-host-controls"
        class="hidden pointer-events-auto flex flex-col items-center gap-4 transition-transform duration-300 mb-28">

        <div id="host-settings-panel"
          class="bg-gray-800/80 p-4 rounded-lg border border-gray-600 w-72 backdrop-blur-sm shadow-lg">

          <div class="mb-3">
            <div class="flex justify-between items-center mb-1">
              <label class="block text-yellow-500 text-xs font-bold" data-i18n="initialChips">Initial Chips</label>
              <span id="error-chips-inline" class="text-red-500 text-[10px] font-bold animate-pulse"></span>
            </div>
            <input type="number" id="setting-initial-chips" value="2000" step="100"
              class="w-full bg-gray-900 text-white border border-gray-600 rounded px-2 py-1 text-sm focus:border-yellow-500 outline-none font-mono">
          </div>

          <div>
            <div class="flex justify-between items-center mb-1">
              <label class="block text-yellow-500 text-xs font-bold" data-i18n="bigBlind">Big Blind</label>
              <span id="error-blind-inline" class="text-red-500 text-[10px] font-bold animate-pulse"></span>
            </div>
            <input type="number" id="setting-big-blind" value="20" step="2" min="2"
              class="w-full bg-gray-900 text-white border border-gray-600 rounded px-2 py-1 text-sm focus:border-yellow-500 outline-none font-mono">
            <p class="text-gray-400 text-[10px] mt-1 text-right"><span data-i18n="smallBlindAuto">SB Auto</span>: <span
                id="setting-sb-display" class="text-white font-bold">10</span></p>
          </div>
        </div>

        <div id="host-start-btn-container"></div>
      </div>

      <p id="wait-message"
        class="mt-8 text-yellow-400 font-bold text-xl drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)] pointer-events-auto bg-black/40 px-6 py-2 rounded-lg backdrop-blur-sm border border-white/10"
        data-i18n="waitForHost">
        Waiting for host to start...
      </p>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction, deleteDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firestoreUpdateDoc = updateDoc;

    // --- I18N SYSTEM (ENHANCED) ---
    const TRANSLATIONS = {
      en: {
        connecting: "Connecting to server...",
        gameTitle: "Texas Hold'em",
        nicknameLabel: "Your Nickname",
        roomIdLabel: "Room ID",
        joinRoomBtn: "Join Room",
        createRoomBtn: "Create Room",
        pot: "Pot",
        room: "Room",
        online: "Players",
        leaveRoomBtn: "Leave",
        raiseLabel: "Bet",
        foldBtn: "Fold",
        checkBtn: "Check",
        callBtn: "Call",
        raiseBtn: "Raise",
        allInBtn: "All-in",
        phaseLabel: "Phase",
        waiting: "Waiting",
        initialChips: "Initial Chips",
        bigBlind: "Big Blind",
        smallBlindAuto: "SB Auto",
        waitForHost: "Waiting for host...",
        startGameBtn: "Start Game",
        waitPlayerBtn: "Waiting Players",
        error_blind_min: "Min 2",
        error_blind_even: "Even # only",
        error_chips_too_low: "Must be > BB",
        // Status & Phase
        status_fold: "Fold",
        status_check: "Check",
        status_call: "Call",
        status_raise: "Raise",
        status_all_in: "All-in",
        status_small_blind: "Small Blind",
        status_big_blind: "Big Blind",
        status_eliminated: "Eliminated",
        status_won: "Won",
        phase_preflop: "Preflop",
        phase_flop: "Flop",
        phase_turn: "Turn",
        phase_river: "River",
        phase_showdown: "Showdown",
        // Hands
        hand_high_card: "High Card",
        hand_pair: "Pair",
        hand_two_pairs: "Two Pairs",
        hand_three_of_a_kind: "Three of a Kind",
        hand_straight: "Straight",
        hand_flush: "Flush",
        hand_full_house: "Full House",
        hand_four_of_a_kind: "Four of a Kind",
        hand_straight_flush: "Straight Flush",
        // Messages
        msg_your_turn: "Your Turn",
        msg_thinking: " Thinking",
        msg_winner: "Winner!",
        msg_bankruptcy: "You are bankrupt. Spectating.",
        msg_game_reset: "Game resetting...",
        error_nickname: "Nickname 2-10 chars",
        error_room_id: "Room ID required",
        error_room_dead: "Room expired/dead",
        error_room_full: "Room full",
        error_game_started: "Game already started",
        error_join_fail: "Join Failed",
        bet_prefix: "Bet",
        call_prefix: "Call",
        // Dynamic Logs
        log_welcome: "System: Welcome to Texas Hold'em.",
        log_join: "{name} joined.",
        log_leave: "{name} left.",
        log_create: "{name} created room.",
        log_fold: "{name} Folded",
        log_check: "{name} Checked",
        log_call: "{name} Called ${amount}",
        log_raise: "{name} Raised to ${amount}",
        log_all_in: "{name} All-in ${amount}",
        log_phase_flop: "--- Flop ---",
        log_phase_turn: "--- Turn ---",
        log_phase_river: "--- River ---",
        log_refund: "Refunding ${amount} to {name}",
        log_win_sole: "--- {name} Wins ${amount} ---",
        log_round_end_no_winner: "--- Round End (No Winner?) ---",
        log_showdown_result: "{potName}(${amount}): {winners} Wins",
        log_game_over: "--- Game Over! {name} Wins! ---",
        log_auto_all_in: "--- Auto All-in (Blinds) ---",
        log_new_round: "--- New Round ---",
        log_host_change: "Host is now {name}.",
        main_pot: "Main Pot",
        side_pot: "Side Pot"
      },
      ja: {
        connecting: "サーバーに接続中...",
        gameTitle: "テキサスホールデム",
        nicknameLabel: "ニックネーム",
        roomIdLabel: "ルームID",
        joinRoomBtn: "参加する",
        createRoomBtn: "作成する",
        pot: "ポット",
        room: "部屋",
        online: "人数",
        leaveRoomBtn: "退出",
        raiseLabel: "額",
        foldBtn: "降りる",
        checkBtn: "チェック",
        callBtn: "コール",
        raiseBtn: "レイズ",
        allInBtn: "オールイン",
        phaseLabel: "フェーズ",
        waiting: "待機中",
        initialChips: "初期チップ",
        bigBlind: "ビッグブラインド",
        smallBlindAuto: "SB自動",
        waitForHost: "ホストの開始待ち...",
        startGameBtn: "ゲーム開始",
        waitPlayerBtn: "参加者待ち",
        status_fold: "フォールド",
        status_check: "チェック",
        status_call: "コール",
        status_raise: "レイズ",
        status_all_in: "オールイン",
        status_small_blind: "SB",
        status_big_blind: "BB",
        status_eliminated: "敗退",
        status_won: "勝利",
        phase_preflop: "プリフロップ",
        phase_flop: "フロップ",
        phase_turn: "ターン",
        phase_river: "リバー",
        phase_showdown: "ショーダウン",
        hand_high_card: "ハイカード",
        hand_pair: "ワンペア",
        hand_two_pairs: "ツーペア",
        hand_three_of_a_kind: "スリーカード",
        hand_straight: "ストレート",
        hand_flush: "フラッシュ",
        hand_full_house: "フルハウス",
        hand_four_of_a_kind: "フォーカード",
        hand_straight_flush: "ストレートフラッシュ",
        msg_your_turn: "あなたの番です",
        msg_thinking: " 思考中...",
        msg_winner: "優勝！",
        msg_bankruptcy: "破産しました。観戦モードへ。",
        msg_game_reset: "リセット中...",
        error_nickname: "名前は2〜10文字",
        error_room_id: "IDを入力してください",
        error_room_dead: "部屋が無効です",
        error_room_full: "満員です",
        error_game_started: "ゲーム進行中",
        error_join_fail: "参加失敗",
        bet_prefix: "ベット",
        call_prefix: "コール",
        error_blind_min: "最小2",
        error_blind_even: "偶数のみ",
        error_chips_too_low: "BBより大きく",
        // Dynamic Logs
        log_welcome: "システム: テキサスホールデムへようこそ。",
        log_join: "{name} が参加しました。",
        log_leave: "{name} が退出しました。",
        log_create: "{name} が部屋を作成しました。",
        log_fold: "{name} 降りる",
        log_check: "{name} チェック",
        log_call: "{name} コール ${amount}",
        log_raise: "{name} レイズ ${amount}",
        log_all_in: "{name} オールイン ${amount}",
        log_phase_flop: "--- フロップ ---",
        log_phase_turn: "--- ターン ---",
        log_phase_river: "--- リバー ---",
        log_refund: "{name}に ${amount} を返却",
        log_win_sole: "--- {name} が ${amount} を獲得 ---",
        log_round_end_no_winner: "--- 勝者なし？終了 ---",
        log_showdown_result: "{potName}(${amount}): {winners} 勝利",
        log_game_over: "--- ゲーム終了! 優勝は {name}! ---",
        log_auto_all_in: "--- 自動オールイン ---",
        log_new_round: "--- 新しいラウンド ---",
        log_host_change: "ホストが {name} になりました。",
        main_pot: "メインポット",
        side_pot: "サイドポット"
      },
      zh: {
        connecting: "连接服务器中...",
        gameTitle: "德州扑克",
        nicknameLabel: "你的昵称",
        roomIdLabel: "房间 ID",
        joinRoomBtn: "加入房间",
        createRoomBtn: "创建房间",
        pot: "底池",
        room: "房间",
        online: "在线",
        leaveRoomBtn: "退出",
        raiseLabel: "加注",
        foldBtn: "弃牌",
        checkBtn: "过牌",
        callBtn: "跟注",
        raiseBtn: "加注",
        allInBtn: "全押",
        phaseLabel: "阶段",
        waiting: "等待中",
        initialChips: "初始筹码",
        bigBlind: "大盲注",
        smallBlindAuto: "小盲自动",
        waitForHost: "等待房主开始...",
        startGameBtn: "开始游戏",
        waitPlayerBtn: "等待玩家",
        status_fold: "弃牌",
        status_check: "过牌",
        status_call: "跟注",
        status_raise: "加注",
        status_all_in: "全押",
        status_small_blind: "小盲",
        status_big_blind: "大盲",
        status_eliminated: "淘汰",
        status_won: "获胜",
        phase_preflop: "翻牌前",
        phase_flop: "翻牌",
        phase_turn: "转牌",
        phase_river: "河牌",
        phase_showdown: "摊牌",
        hand_high_card: "高牌",
        hand_pair: "一对",
        hand_two_pairs: "两对",
        hand_three_of_a_kind: "三条",
        hand_straight: "顺子",
        hand_flush: "同花",
        hand_full_house: "葫芦",
        hand_four_of_a_kind: "四条",
        hand_straight_flush: "同花顺",
        msg_your_turn: "你的回合",
        msg_thinking: " 思考中",
        msg_winner: "你是冠军！",
        msg_bankruptcy: "你已破产，进入观战模式",
        msg_game_reset: "游戏即将重置...",
        error_nickname: "昵称必须2-10字符",
        error_room_id: "请输入房间ID",
        error_room_dead: "房间已失效",
        error_room_full: "房间已满",
        error_game_started: "游戏已开始",
        error_join_fail: "加入失败",
        bet_prefix: "下注",
        call_prefix: "跟注",
        error_blind_min: "最小为2",
        error_blind_even: "必须为偶数",
        error_chips_too_low: "须大于大盲",
        // Dynamic Logs
        log_welcome: "系统: 欢迎游玩德州扑克。",
        log_join: "{name} 加入了房间。",
        log_leave: "{name} 离开了房间。",
        log_create: "{name} 创建了房间。",
        log_fold: "{name} 弃牌",
        log_check: "{name} 过牌",
        log_call: "{name} 跟注 ${amount}",
        log_raise: "{name} 加注至 ${amount}",
        log_all_in: "{name} 全押 ${amount}",
        log_phase_flop: "--- 翻牌 ---",
        log_phase_turn: "--- 转牌 ---",
        log_phase_river: "--- 河牌 ---",
        log_refund: "退还 ${amount} 给 {name}",
        log_win_sole: "--- {name} 获胜, 赢得 ${amount} ---",
        log_round_end_no_winner: "--- 无人获胜？回合结束 ---",
        log_showdown_result: "{potName}(${amount}): {winners} 获胜",
        log_game_over: "--- 游戏结束! {name} 获胜! ---",
        log_auto_all_in: "--- 盲注导致全押 ---",
        log_new_round: "--- 新回合开始 ---",
        log_host_change: "房主移交给 {name}。",
        main_pot: "主池",
        side_pot: "边池"
      }
    };

    let currentLang = "en";

    // Enhanced t() to support argument replacement
    const t = (key, args = {}) => {
      let text = TRANSLATIONS[currentLang][key] || key;
      Object.keys(args).forEach(argKey => {
        text = text.replace(`{${argKey}}`, args[argKey]);
      });
      return text;
    };

    // Helper to create structured log objects (saved as JSON string)
    const createLog = (key, args = {}) => {
      return JSON.stringify({ key, args });
    };

    window.updateLanguage = (lang) => {
      currentLang = lang;
      document.documentElement.lang = lang;
      document.querySelectorAll("[data-i18n]").forEach(el => {
        const key = el.getAttribute("data-i18n");
        // For simple static texts, no args needed
        el.innerText = t(key);
      });
      // Re-render to update logs and dynamic texts
      if (gameUI && gameUI.lastState) {
        gameUI.renderGameState(gameUI.lastState, network.localUserId);
      }
    };

    // --- CONSTANTS & UTILS ---
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    const SUITS = ["♠", "♥", "♣", "♦"];
    const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    const RANK_VALUES = { 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, J: 11, Q: 12, K: 13, A: 14 };

    const PHASE_KEY_MAP = {
      waiting: "waiting",
      preflop: "phase_preflop",
      flop: "phase_flop",
      turn: "phase_turn",
      river: "phase_river",
      showdown: "phase_showdown",
    };

    // --- FIREBASE GLOBALS ---
    let db, auth, app;
    let localUserId = null;
    let localPlayerName = "Guest";
    let sound;

    const firebaseConfig = typeof __firebase_config !== "undefined" ? JSON.parse(__firebase_config) : {
      apiKey: "AIzaSyBX_mHFj3VHsx6U38Ib9pDJWCrnlSlR_g4",
      authDomain: "texas-hold-em-poker-1.firebaseapp.com",
      projectId: "texas-hold-em-poker-1",
      storageBucket: "texas-hold-em-poker-1.firebasestorage.app",
      messagingSenderId: "401916350194",
      appId: "1:401916350194:web:2b38d3da714968c8cd0a6b"
    };

    const appId = typeof __app_id !== "undefined" ? __app_id : "poker-game-test";
    const initialAuthToken = typeof __initial_auth_token !== "undefined" ? __initial_auth_token : null;

    // --- GAME LOGIC (PURE FUNCTIONS) ---

    function processAction(currentState, actingUserId, action, amount = 0) {
      let newState = JSON.parse(JSON.stringify(currentState));
      // Fix: Ensure config is present, otherwise use current state variables to guess or default safely
      const config = newState.config || { bigBlind: 20 };
      let player = newState.players[actingUserId];

      const currentPlayerId = newState.playerOrder[newState.currentPlayerIndex];
      if (currentPlayerId !== actingUserId) return currentState;

      if (player.folded || (player.chips === 0 && newState.phase !== "waiting")) {
        newState.currentPlayerIndex = (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
        return newState;
      }

      const diff = newState.currentMaxBet - player.currentBet;
      let triggerAllInEffect = false;
      let logJson = "";

      if (action === "fold") {
        player.folded = true;
        player.status = "status_fold";
        logJson = createLog("log_fold", { name: player.name });
      } else if (action === "check") {
        if (diff > 0) return currentState;
        player.status = "status_check";
        logJson = createLog("log_check", { name: player.name });
      } else if (action === "call") {
        let callAmount = Math.min(diff, player.chips);
        let isAllIn = callAmount === player.chips && diff > 0;
        player.chips -= callAmount;
        player.currentBet += callAmount;
        newState.pot += callAmount;
        player.status = isAllIn ? "status_all_in" : "status_call";
        const logKey = isAllIn ? "log_all_in" : "log_call";
        logJson = createLog(logKey, { name: player.name, amount: callAmount });
        if (isAllIn) triggerAllInEffect = true;
      } else if (action === "raise") {
        let raiseAmount = amount - player.currentBet;
        let actualAmount = amount;

        if (actualAmount <= newState.currentMaxBet && actualAmount < player.chips) return currentState;
        const extraRaise = actualAmount - newState.currentMaxBet;

        // Use the state's lastRaiseAmount directly to avoid config sync issues
        if (extraRaise < newState.lastRaiseAmount && actualAmount < player.chips) return currentState;

        let isAllIn = raiseAmount >= player.chips;
        if (isAllIn) {
          actualAmount = player.chips + player.currentBet;
          raiseAmount = player.chips;
          triggerAllInEffect = true;
        }

        player.chips -= raiseAmount;
        player.currentBet = actualAmount;
        newState.pot += raiseAmount;

        const newRaiseAmount = actualAmount - newState.currentMaxBet;
        if (!isAllIn || newRaiseAmount >= newState.lastRaiseAmount) {
          newState.lastRaiseAmount = newRaiseAmount;
        }
        newState.currentMaxBet = actualAmount;
        newState.playersActed.length = 0;

        player.status = isAllIn ? "status_all_in" : "status_raise";
        const logKey = isAllIn ? "log_all_in" : "log_raise";
        logJson = createLog(logKey, { name: player.name, amount: actualAmount });
      }

      if (logJson) {
        newState.logs.push(logJson);
        if (newState.logs.length > 20) newState.logs.shift();
      }

      if (!newState.playersActed.includes(actingUserId)) {
        newState.playersActed.push(actingUserId);
      }

      const activePlayers = newState.playerOrder.map(uid => newState.players[uid]).filter(p => !p.folded);
      const playersWithChips = activePlayers.filter(p => p.chips > 0);

      const isRoundComplete = activePlayers.every(p => {
        const isAllIn = p.chips === 0 && !p.folded;
        const matchBet = p.currentBet === newState.currentMaxBet;
        const hasActed = newState.playersActed.includes(p.uid);
        if (isAllIn) return true;

        // --- FIX START: Robust Big Blind Index Calculation ---
        // Check if it's Preflop AND the betting level matches the Big Blind (no raises yet)
        if (newState.phase === 'preflop' && newState.currentMaxBet === config.bigBlind) {
          let bbIndex;
          // Correctly calculate BB index for 2 players vs 3+ players
          if (newState.playerOrder.length === 2) {
            bbIndex = (newState.dealerIndex + 1) % 2;
          } else {
            bbIndex = (newState.dealerIndex + 2) % newState.playerOrder.length;
          }

          // If player is BB, they MUST have acted (even if they just Check)
          if (p.uid === newState.playerOrder[bbIndex] && !hasActed) return false;
        }
        // --- FIX END ---

        return hasActed && matchBet;
      });

      if (activePlayers.length === 1) {
        newState = advanceToShowdown(newState, activePlayers[0]);
      }
      else if (isRoundComplete && playersWithChips.length <= 1 && newState.phase !== "showdown") {
        newState = runAutoShowdown(newState);
      }
      else if (isRoundComplete) {
        newState = advanceToNextPhase(newState);
      }
      else {
        let loops = 0;
        do {
          newState.currentPlayerIndex = (newState.currentPlayerIndex + 1) % newState.playerOrder.length;
          const nextPlayer = newState.players[newState.playerOrder[newState.currentPlayerIndex]];
          if (nextPlayer.folded || nextPlayer.chips === 0) {
            loops++;
            continue;
          }
          break;
        } while (loops <= newState.playerOrder.length * 2);
      }

      if (triggerAllInEffect) {
        newState.lastAllInPlayer = player.uid + "_" + Date.now();
      }
      return newState;
    }

    function advanceToNextPhase(currentState) {
      let newState = JSON.parse(JSON.stringify(currentState));
      const config = newState.config || { bigBlind: 20 };
      newState = returnExcessBets(newState);

      newState.playerOrder.forEach(uid => {
        const p = newState.players[uid];
        p.accumulatedBet += p.currentBet;
        p.currentBet = 0;
        p.status = "";
      });

      newState.currentMaxBet = 0;
      newState.lastRaiseAmount = config.bigBlind;
      newState.playersActed = [];

      if (newState.phase === "preflop") {
        newState.phase = "flop";
        newState.communityCards.push(newState.deck.pop(), newState.deck.pop(), newState.deck.pop());
        newState.logs.push(createLog("log_phase_flop"));
      } else if (newState.phase === "flop") {
        newState.phase = "turn";
        newState.communityCards.push(newState.deck.pop());
        newState.logs.push(createLog("log_phase_turn"));
      } else if (newState.phase === "turn") {
        newState.phase = "river";
        newState.communityCards.push(newState.deck.pop());
        newState.logs.push(createLog("log_phase_river"));
      } else if (newState.phase === "river") {
        newState = advanceToShowdown(newState);
        return newState;
      }

      let nextIdx = (newState.dealerIndex + 1) % newState.playerOrder.length;
      let loops = 0;
      while (loops <= newState.playerOrder.length) {
        const p = newState.players[newState.playerOrder[nextIdx]];
        if (!p.folded && p.chips > 0) break;
        nextIdx = (nextIdx + 1) % newState.playerOrder.length;
        loops++;
      }
      newState.currentPlayerIndex = nextIdx;
      return newState;
    }

    function runAutoShowdown(currentState) {
      let newState = JSON.parse(JSON.stringify(currentState));
      newState = returnExcessBets(newState);

      newState.playerOrder.forEach(uid => {
        const p = newState.players[uid];
        p.accumulatedBet += p.currentBet;
        p.currentBet = 0;
        p.status = p.chips === 0 && !p.folded ? "status_all_in" : p.status;
      });

      newState.currentPlayerIndex = -1;

      if (newState.phase === "preflop") {
        newState.phase = "flop";
        newState.communityCards.push(newState.deck.pop(), newState.deck.pop(), newState.deck.pop());
        newState.logs.push(createLog("log_phase_flop"));
        newState.nextPhaseTimer = 1500;
      } else if (newState.phase === "flop") {
        newState.phase = "turn";
        newState.communityCards.push(newState.deck.pop());
        newState.logs.push(createLog("log_phase_turn"));
        newState.nextPhaseTimer = 1500;
      } else if (newState.phase === "turn") {
        newState.phase = "river";
        newState.communityCards.push(newState.deck.pop());
        newState.logs.push(createLog("log_phase_river"));
        newState.nextPhaseTimer = 1500;
      } else if (newState.phase === "river") {
        newState.nextPhaseTimer = 0;
        newState = advanceToShowdown(newState);
      }
      return newState;
    }

    function returnExcessBets(currentState) {
      let newState = JSON.parse(JSON.stringify(currentState));
      const activePlayers = newState.playerOrder.map(uid => newState.players[uid]).filter(p => !p.folded);
      if (activePlayers.length < 2) return newState;

      const sortedPlayers = [...activePlayers].sort((a, b) => b.currentBet - a.currentBet);
      const highest = sortedPlayers[0];
      const secondHighest = sortedPlayers[1];

      if (highest.currentBet > secondHighest.currentBet) {
        const refund = highest.currentBet - secondHighest.currentBet;
        const playerToRefund = newState.players[highest.uid];
        playerToRefund.chips += refund;
        playerToRefund.currentBet -= refund;
        newState.pot -= refund;
        newState.logs.push(createLog("log_refund", { amount: refund, name: playerToRefund.name }));
      }
      return newState;
    }

    function advanceToShowdown(currentState, soleWinner = null) {
      let newState = JSON.parse(JSON.stringify(currentState));
      newState.phase = "showdown";
      newState.currentPlayerIndex = -1;

      if (soleWinner) {
        const winnerPlayer = newState.players[soleWinner.uid];
        newState.playerOrder.forEach(uid => newState.players[uid].currentBet = 0);
        winnerPlayer.chips += newState.pot;
        newState.logs.push(createLog("log_win_sole", { name: winnerPlayer.name, amount: newState.pot }));
        newState.highlightWinner = winnerPlayer.uid;
      }
      else {
        let finalPot = 0;
        newState.playerOrder.forEach(uid => {
          const p = newState.players[uid];
          p.accumulatedBet += p.currentBet;
          finalPot += p.accumulatedBet;
          p.currentBet = 0;
        });
        newState.pot = finalPot;
        const allPlayers = newState.playerOrder.map(uid => newState.players[uid]);
        const activePlayers = allPlayers.filter(p => !p.folded);

        if (activePlayers.length === 0) {
          newState.logs.push(createLog("log_round_end_no_winner"));
        } else {
          activePlayers.forEach(p => {
            p.bestHand = HandEvaluator.evaluate(p.holeCards, newState.communityCards);
          });

          let distinctBets = [...new Set(activePlayers.map(p => p.accumulatedBet))].filter(bet => bet > 0).sort((a, b) => a - b);
          let winnerLogs = [];
          newState.highlightCards = new Set();

          let prevBet = 0;
          distinctBets.forEach((betLevel, index) => {
            let potAmount = 0;
            allPlayers.forEach(p => {
              if (p.accumulatedBet >= betLevel) potAmount += betLevel - prevBet;
              else if (p.accumulatedBet > prevBet) potAmount += p.accumulatedBet - prevBet;
            });

            let contributors = activePlayers.filter(p => p.accumulatedBet >= betLevel);
            if (potAmount > 0 && contributors.length > 0) {
              let bestScore = -1;
              let winners = [];

              contributors.forEach(p => {
                if (p.bestHand.score > bestScore) {
                  bestScore = p.bestHand.score;
                  winners = [p];
                } else if (Math.abs(p.bestHand.score - bestScore) < 0.1) {
                  winners.push(p);
                }
              });

              const winPer = Math.floor(potAmount / winners.length);
              let remainder = potAmount % winners.length;

              // potName needs to be translated during render, we save a key or handle index logic in translation
              // For simplicity, we'll save a constructed string args or custom key logic
              // Better approach: Save raw info and format in render. But strict keys are better.
              // Let's use a trick: index === 0 ? t('main_pot') : t('side_pot') + index
              const potNameKey = index === 0 ? "main_pot" : "side_pot";
              let winnerNames = winners.map(w => w.name).join(", ");

              // We'll inject the translated pot name via args in render? No, complex.
              // Let's store enough data to reconstruct:
              // { key: 'log_showdown_result', args: { potIndex: index, amount: potAmount, winners: winnerNames } }
              // And then update TRANSLATIONS to handle potIndex... actually, `t` helper is simple.
              // Let's do: potName string injection for now, but using keys
              // Note: Since log arguments are strings, we can't easily inject dynamic keys unless we nest `t` calls which isn't possible in pure JSON.
              // Compromise: We will store "Main Pot" or "Side Pot 1" as an english string argument, OR we handle this specific log uniquely.
              // Let's handle uniquely in render.

              winnerLogs.push(createLog("log_showdown_result", {
                potName: index === 0 ? "Main" : `Side ${index}`, // This is a slight compromise, but 'Main'/'Side' are common enough.
                amount: potAmount,
                winners: winnerNames
              }));

              winners.forEach(w => {
                let winnings = winPer;
                if (remainder > 0) { winnings++; remainder--; }
                newState.players[w.uid].chips += winnings;
                newState.highlightWinner = w.uid;
                if (w.bestHand.bestCards) w.bestHand.bestCards.forEach(c => newState.highlightCards.add(c.id));
              });
            }
            prevBet = betLevel;
          });

          newState.highlightCards = Array.from(newState.highlightCards);
          newState.logs.push(...winnerLogs);
        }
      }
      newState.nextRoundTimer = 6000;
      sound.playHandEnd();
      return newState;
    }

    function startNewRound(currentState) {
      let newState = JSON.parse(JSON.stringify(currentState));
      // 确保配置中的盲注是数字类型
      const config = newState.config || { initialChips: 2000, smallBlind: 10, bigBlind: 20 };
      const bigBlindVal = parseInt(config.bigBlind) || 20;
      const smallBlindVal = parseInt(config.smallBlind) || 10;

      let activePlayerIds = [];
      const allPlayerIds = currentState.playerOrder;

      // 1. 筛选存活玩家
      allPlayerIds.forEach(uid => {
        if (newState.players[uid].chips > 0) activePlayerIds.push(uid);
        else {
          newState.players[uid].folded = true;
          newState.players[uid].status = "status_eliminated";
        }
      });

      // 2. 如果只剩1人，游戏结束
      if (activePlayerIds.length < 2) {
        const winnerId = activePlayerIds.length > 0 ? activePlayerIds[0] : null;
        const winnerName = winnerId ? newState.players[winnerId].name : "No one";
        let newLogs = [...newState.logs];
        newLogs.push(createLog("log_game_over", { name: winnerName }));

        const resetPlayers = {};
        allPlayerIds.forEach(uid => {
          const p = newState.players[uid];
          if (p) {
            resetPlayers[uid] = { ...p, chips: config.initialChips, holeCards: [], folded: false, currentBet: 0, accumulatedBet: 0, status: "waiting", bestHand: null };
          }
        });

        return {
          status: "waiting",
          hostId: newState.hostId,
          config: config,
          players: resetPlayers,
          playerOrder: allPlayerIds,
          communityCards: [],
          pot: 0,
          dealerIndex: 0,
          currentPlayerIndex: -1,
          currentMaxBet: 0,
          phase: "waiting",
          lastRaiseAmount: bigBlindVal,
          deck: [],
          logs: newLogs,
          highlightWinner: winnerId,
          highlightCards: [],
          nextRoundTimer: 0,
          nextPhaseTimer: 0,
          lastAllInPlayer: null
        };
      }

      // 3. 初始化新回合状态
      newState.playerOrder = activePlayerIds;
      newState.communityCards = [];
      newState.pot = 0;
      newState.currentMaxBet = 0;
      newState.lastRaiseAmount = bigBlindVal;
      newState.phase = "preflop";
      newState.playersActed = [];
      newState.highlightWinner = null;
      newState.highlightCards = [];
      newState.nextRoundTimer = 0;
      newState.nextPhaseTimer = 0;
      newState.lastAllInPlayer = null; // 重置特效触发器

      newState.playerOrder.forEach(uid => {
        const p = newState.players[uid];
        p.holeCards = [];
        p.folded = false;
        p.currentBet = 0;
        p.accumulatedBet = 0;
        p.status = "";
        p.bestHand = null;
      });

      // 4. 洗牌
      let deck = [];
      for (let suit of SUITS) {
        for (let rank of RANKS) {
          deck.push({ suit, rank, value: RANK_VALUES[rank], color: suit === "♥" || suit === "♦" ? "red" : "black", id: Math.random().toString(36).substr(2, 9) });
        }
      }
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
      newState.deck = deck;

      // 5. 移动 Dealer
      const oldOrder = currentState.playerOrder;
      const oldDealerIndex = currentState.dealerIndex;
      let nextDealerId = null;
      let checkIndex = oldDealerIndex;
      for (let i = 0; i < oldOrder.length; i++) {
        checkIndex = (checkIndex + 1) % oldOrder.length;
        const candidateId = oldOrder[checkIndex];
        if (activePlayerIds.includes(candidateId)) {
          nextDealerId = candidateId;
          break;
        }
      }
      const newDealerIndex = newState.playerOrder.indexOf(nextDealerId);
      newState.dealerIndex = newDealerIndex !== -1 ? newDealerIndex : 0;
      const numPlayers = newState.playerOrder.length;

      // 6. 确定大小盲位置 (2人局特殊规则)
      let sbIndex, bbIndex;
      if (numPlayers === 2) {
        sbIndex = newState.dealerIndex; // Heads-up: Dealer is SB
        bbIndex = (newState.dealerIndex + 1) % numPlayers;
      } else {
        sbIndex = (newState.dealerIndex + 1) % numPlayers;
        bbIndex = (newState.dealerIndex + 2) % numPlayers;
      }

      const sbPlayer = newState.players[newState.playerOrder[sbIndex]];
      const bbPlayer = newState.players[newState.playerOrder[bbIndex]];

      // --- 扣除小盲注 ---
      // 强制计算：如果有 100，SB是10，取10。如果有 5，SB是10，取5 (All-in)。
      const sbAmount = Math.min(smallBlindVal, sbPlayer.chips);
      sbPlayer.chips -= sbAmount;
      sbPlayer.currentBet = sbAmount;
      
      if (sbPlayer.chips === 0) {
        sbPlayer.status = "status_all_in";
        newState.lastAllInPlayer = sbPlayer.uid + "_" + Date.now(); // 触发特效
      } else {
        sbPlayer.status = "status_small_blind";
      }

      // --- 扣除大盲注 (修复核心) ---
      // 逻辑：哪怕他只有 15 (大盲20)，Math.min(20, 15) 也会返回 15，让他 All-in。
      const bbAmount = Math.min(bigBlindVal, bbPlayer.chips);
      bbPlayer.chips -= bbAmount;
      bbPlayer.currentBet = bbAmount;

      if (bbPlayer.chips === 0) {
        bbPlayer.status = "status_all_in";
        newState.lastAllInPlayer = bbPlayer.uid + "_" + Date.now(); // 触发特效
      } else {
        bbPlayer.status = "status_big_blind";
      }

      // 设置底池和当前最大下注
      newState.pot = sbAmount + bbAmount;
      // 关键点：即使大盲玩家 All-in 了（比如只下了 15），当前桌面的“标准注额”依然是大盲注（20）
      // 这意味着后续玩家如果要 Call，必须 Call 到 20，而不是 15。
      newState.currentMaxBet = bigBlindVal;

      // 7. 发牌
      for (let i = 0; i < 2; i++) {
        for (let uid of newState.playerOrder) newState.players[uid].holeCards.push(newState.deck.pop());
      }

      // 8. 确定行动者 (大盲注的下一位)
      let nextIdx = (bbIndex + 1) % numPlayers;
      let loopCount = 0;
      while (loopCount < numPlayers) {
        const p = newState.players[newState.playerOrder[nextIdx]];
        if (p.chips > 0) break;
        nextIdx = (nextIdx + 1) % numPlayers;
        loopCount++;
      }
      newState.currentPlayerIndex = nextIdx;

      // 9. 检查自动 Showdown (如果除了 All-in 玩家外只剩0-1人)
      const activePlayersInGame = newState.playerOrder.map(uid => newState.players[uid]).filter(p => !p.folded);
      const playersWithChips = activePlayersInGame.filter(p => p.chips > 0);
      if (activePlayersInGame.length >= 2 && playersWithChips.length <= 1) {
        newState.logs.push(createLog("log_auto_all_in"));
        return runAutoShowdown(newState);
      }

      newState.logs.push(createLog("log_new_round"));
      return newState;
    }

    // --- UI MANAGER ---
    class GameUIManager {
      constructor() {
        this.sound = new SoundManager();
        this.dragSystem = new TableDragSystem();
        this.occlusionManager = new OcclusionManager();
        this.lastState = null;
        this.localPlayerId = null;
        this.lastActivePlayerId = null;
        this.highlightCards = new Set();
        this.bankruptcyScreenShown = false;
        this.lastAllInPlayerTriggered = null;
        this.isSliderReset = false;

        document.getElementById("raise-slider").oninput = () => {
          const slider = document.getElementById("raise-slider");
          const btnRaise = document.getElementById("btn-raise");
          const valDisplay = document.getElementById("raise-val-display");
          if (slider && btnRaise && valDisplay && !slider.disabled) {
            const raiseVal = parseInt(slider.value);
            const maxVal = parseInt(slider.max);
            valDisplay.innerText = `$${raiseVal}`;
            btnRaise.innerText = raiseVal === maxVal ? t("allInBtn") : `${t("raiseBtn")} $${raiseVal}`;
          }
        };
      }

      initSound() {
        this.sound.init();
        sound = this.sound;
      }

      renderGameState(state, localId) {
        if (!state) return;
        this.initSound();

        const lastLogStr = state.logs.length > 0 ? state.logs[state.logs.length - 1] : "";
        const prevLogStr = (this.lastState && this.lastState.logs.length > 0) ? this.lastState.logs[this.lastState.logs.length - 1] : "";

        // Check for new log
        const hasNewLog = this.lastState && (state.logs.length > this.lastState.logs.length || (state.logs.length > 0 && lastLogStr !== prevLogStr));

        if (hasNewLog) {
          let logKey = "";
          try {
            const logObj = JSON.parse(lastLogStr);
            logKey = logObj.key;
          } catch (e) {
            logKey = lastLogStr; // Fallback for legacy strings
          }

          // Play sounds based on keys
          if (logKey === "log_fold") this.sound.playFold();
          else if (logKey === "log_check") this.sound.playCheck();
          else if (logKey === "log_call") this.sound.playChip();
          else if (logKey === "log_raise") this.sound.playRaise();
          // Check for "---" equivalent keys
          if (["log_phase_flop", "log_phase_turn", "log_phase_river"].includes(logKey)) this.sound.playCard();
        }

        this.highlightCards = new Set(state.highlightCards || []);
        const playerCount = state.playerOrder ? state.playerOrder.length : 0;
        const countEl = document.getElementById("active-players-count");
        if (countEl) countEl.innerText = playerCount;

        if (state.lastAllInPlayer && (!this.lastState || state.lastAllInPlayer !== this.lastState.lastAllInPlayer)) {
          if (state.lastAllInPlayer !== this.lastAllInPlayerTriggered) {
            this.showAllInEffect(state.lastAllInPlayer);
            this.lastAllInPlayerTriggered = state.lastAllInPlayer;
          }
        }
        if (state.phase === "showdown") this.lastAllInPlayerTriggered = null;

        this.lastState = state;
        this.localPlayerId = localId;
        const localPlayer = state.players[localId];

        document.getElementById("pot-display").innerText = state.pot;

        const phaseKey = PHASE_KEY_MAP[state.phase] || state.phase;
        document.getElementById("phase-display").innerText = t(phaseKey);

        if (state.config) {
          const blindsEl = document.getElementById("blinds-display");
          if (blindsEl) blindsEl.innerText = `${t("bigBlind")} $${state.config.bigBlind}`;
        }

        this.renderTableLayout(state, localId);

        for (let i = 0; i < 5; i++) {
          const slot = document.getElementById(`comm-slot-${i}`);
          if (!slot) continue;
          const cardData = state.communityCards[i];
          if (cardData) {
            let cardEl = slot.firstElementChild;
            if (!cardEl) {
              cardEl = this.createCardEl(cardData);
              slot.appendChild(cardEl);
            }
            if (this.highlightCards.has(cardData.id)) {
              if (!cardEl.classList.contains("winning-card")) cardEl.classList.add("winning-card");
            } else {
              if (cardEl.classList.contains("winning-card")) cardEl.classList.remove("winning-card");
            }
          } else {
            slot.innerHTML = "";
          }
        }

        // --- Render Logs with Translation ---
        const logDiv = document.getElementById("game-log");
        logDiv.innerHTML = state.logs.map((logStr) => {
          let displayMsg = logStr;
          try {
            const logObj = JSON.parse(logStr);
            if (logObj.key) {
              displayMsg = t(logObj.key, logObj.args);
              // Hack for Pot Names if they were "Main" or "Side X" in English
              if (logObj.key === "log_showdown_result") {
                const potNameRaw = logObj.args.potName; // "Main" or "Side 1"
                let translatedPot = potNameRaw;
                if (potNameRaw === "Main") translatedPot = t("main_pot");
                else if (potNameRaw && potNameRaw.startsWith("Side")) translatedPot = t("side_pot") + " " + potNameRaw.split(" ")[1];
                // Re-interpolate because potName was already in args
                displayMsg = displayMsg.replace(potNameRaw, translatedPot);
              }
            }
          } catch (e) {
            // Fallback: try to detect legacy log patterns if necessary, or just show raw
          }
          return `<div>> ${displayMsg}</div>`;
        }).join("");
        logDiv.scrollTop = logDiv.scrollHeight;

        this.updateControls(state);

        if (localPlayer) {
          // Check for win in logs (searching for log_game_over key)
          // This is slightly fragile checking array content, but works for sound trigger logic previously
          const lastLog = state.logs.length > 0 ? state.logs[state.logs.length - 1] : "";
          const isChampion = state.status === "waiting" && state.highlightWinner === localId && lastLog.includes("log_game_over");

          const isEliminated = localPlayer.status === "status_eliminated" && localPlayer.chips === 0;

          if (isChampion) {
            if (!this.bankruptcyScreenShown) {
              this.sound.playWin();
              this.showMessage(t("msg_winner"));
              this.bankruptcyScreenShown = true;
            }
          }
          else if (isEliminated && state.status === "playing") {
            if (!this.bankruptcyScreenShown) {
              this.sound.playLose();
              this.showMessage(t("msg_bankruptcy"));
              this.bankruptcyScreenShown = true;
            }
          }
          else if (state.status === "waiting" && !isChampion) {
            this.bankruptcyScreenShown = false;
          }
        }

        const waitOverlay = document.getElementById("waiting-room-overlay");
        if (state.status === "waiting") {
          waitOverlay.classList.remove("hidden");
          network.updateWaitingRoomUI(state, localId);
        } else {
          waitOverlay.classList.add("hidden");
        }
      }

      renderTableLayout(state, localId) {
        const container = document.getElementById("seats-container");
        const playerIdsToRender = state.phase === "waiting" || state.status === "waiting" ? state.playerOrder : state.playerOrder;
        const num = playerIdsToRender.length;
        if (num === 0) {
          container.innerHTML = "";
          return;
        }
        const w = container.offsetWidth;
        const h = container.offsetHeight;
        const cx = w / 2;
        const cy = h / 2;
        const localIndex = playerIdsToRender.indexOf(localId);
        const renderIndex = localIndex === -1 ? 0 : localIndex;

        let scale = 1, radiusX = 0.38, radiusY = 0.38;
        if (num > 6) { scale = 0.85; radiusX = 0.42; radiusY = 0.42; }
        if (num >= 9) { scale = 0.75; radiusX = 0.44; radiusY = 0.44; }
        if (w < 768) {
          if (num > 5) scale = 0.75;
          if (num > 8) scale = 0.65;
          radiusX = 0.4;
        }
        const rx = w * radiusX;
        const ry = h * radiusY;
        const activeSeatIds = new Set();

        playerIdsToRender.forEach((uid, i) => {
          const p = state.players[uid];
          if (!p) return;

          const seatId = `seat-${p.uid}`;
          activeSeatIds.add(seatId);

          let seatDiv = document.getElementById(seatId);
          if (!seatDiv) {
            seatDiv = document.createElement("div");
            seatDiv.id = seatId;
            seatDiv.className = "player-seat";
            seatDiv.innerHTML = `
              <div id="cards-${p.uid}" class="absolute flex space-x-1 z-10 transition-all" style="top:-50px;"></div>
              <div class="player-info-box relative z-20">
                  <div id="dealer-${p.uid}" class="dealer-btn hidden">D</div>
                  <div id="name-${p.uid}" class="font-bold text-yellow-400 truncate text-sm tracking-wide"></div>
                  <div class="text-white text-xs font-mono">$<span id="chips-${p.uid}"></span></div>
                  <div id="status-${p.uid}" class="text-gray-400 text-[10px] h-4 truncate font-bold uppercase mt-1"></div>
              </div>`;
            container.appendChild(seatDiv);
          }

          const offsetIndex = (i - renderIndex + num) % num;
          const angle = Math.PI / 2 + (offsetIndex * (2 * Math.PI)) / num;
          const x = cx + rx * Math.cos(angle);
          const y = cy + ry * Math.sin(angle);

          seatDiv.style.left = `${x - 60}px`;
          seatDiv.style.top = `${y - 55}px`;
          seatDiv.style.transform = `scale(${scale})`;

          // --- 更新文本信息 ---
          seatDiv.querySelector(`#name-${p.uid}`).innerText = p.name;
          seatDiv.querySelector(`#chips-${p.uid}`).innerText = p.chips;

          const dealerBtn = seatDiv.querySelector(`#dealer-${p.uid}`);
          if (i === state.dealerIndex) dealerBtn.classList.remove("hidden");
          else dealerBtn.classList.add("hidden");

          let statusText = "";
          if (p.currentBet > 0) statusText = `${t("bet_prefix")} $${p.currentBet}`;
          else if (p.status) {
            statusText = t(p.status);
            if (p.status.startsWith("hand_")) statusText = t(p.status);
          }
          seatDiv.querySelector(`#status-${p.uid}`).innerText = statusText;

          // --- 更新高亮状态 (座位本身) ---
          if (state.playerOrder[state.currentPlayerIndex] === p.uid && state.phase !== "showdown") {
            seatDiv.classList.add("active-player");
          } else {
            seatDiv.classList.remove("active-player");
          }
          if (state.highlightWinner === p.uid) seatDiv.classList.add("winner-highlight");
          else seatDiv.classList.remove("winner-highlight");
          seatDiv.style.opacity = p.folded ? 0.4 : 1;

          // --- 【关键修改3】智能更新卡牌 (复用 DOM 以触发 Transition) ---
          const cardsContainer = document.getElementById(`cards-${p.uid}`);
          const activePlayersCount = Object.values(state.players).filter(player => !player.folded).length;
          const shouldShowFace = !p.folded && p.holeCards && p.holeCards.length > 0 &&
            (p.uid === localId || (state.phase === "showdown" && activePlayersCount > 1));

          if (shouldShowFace) {
            if (cardsContainer.querySelector('.card-back')) cardsContainer.innerHTML = "";

            p.holeCards.forEach((c, cardIdx) => {
              let cardEl = cardsContainer.children[cardIdx];

              if (!cardEl || cardEl.dataset.cid !== c.id) {
                const newCard = this.createCardEl(c);
                newCard.dataset.cid = c.id; // 标记 ID
                if (cardEl) cardsContainer.replaceChild(newCard, cardEl);
                else cardsContainer.appendChild(newCard);
                cardEl = newCard;
              }

              if (this.highlightCards.has(c.id)) {
                if (!cardEl.classList.contains("winning-card")) cardEl.classList.add("winning-card");
              } else {
                cardEl.classList.remove("winning-card");
              }
            });

            while (cardsContainer.children.length > p.holeCards.length) {
              cardsContainer.removeChild(cardsContainer.lastChild);
            }
          } else if (!p.folded && p.holeCards && p.holeCards.length > 0) {
            if (cardsContainer.children.length !== 2 || !cardsContainer.children[0].classList.contains('card-back')) {
              cardsContainer.innerHTML = "";
              cardsContainer.appendChild(this.createBackEl());
              cardsContainer.appendChild(this.createBackEl());
            }
          } else {
            cardsContainer.innerHTML = "";
          }
        });

        Array.from(container.children).forEach(child => {
          if (!activeSeatIds.has(child.id)) {
            container.removeChild(child);
          }
        });
      }

      updateControls(state) {
        if (!state || !state.players || !this.localPlayerId) return;
        const localPlayer = state.players[this.localPlayerId];
        const currentTurnPlayerId = state.playerOrder[state.currentPlayerIndex];
        const currentTurnPlayer = state.players[currentTurnPlayerId];

        if (state.status === "playing" && state.phase !== "showdown" && state.phase !== "waiting") {
          if (this.lastActivePlayerId !== currentTurnPlayerId) {
            this.lastActivePlayerId = currentTurnPlayerId;
            if (currentTurnPlayerId === this.localPlayerId) {
              this.showMessage(t("msg_your_turn"));
            } else {
              const name = currentTurnPlayer ? currentTurnPlayer.name : "Player";
              this.showMessage(`${name} ${t("msg_thinking")}`);
            }
          }
        } else {
          this.lastActivePlayerId = null;
        }

        const controls = document.getElementById("player-controls");
        const isMyTurn = currentTurnPlayerId === this.localPlayerId;
        const canAct = isMyTurn && !localPlayer.folded && localPlayer.chips > 0 && state.phase !== "showdown";

        if (!canAct) {
          controls.classList.add("opacity-50", "pointer-events-none", "translate-y-2");
          this.isSliderReset = false;
          return;
        }
        controls.classList.remove("opacity-50", "pointer-events-none", "translate-y-2");

        const diff = state.currentMaxBet - localPlayer.currentBet;
        const btnCheck = document.getElementById("btn-check");
        const btnCall = document.getElementById("btn-call");
        const btnRaise = document.getElementById("btn-raise");
        const slider = document.getElementById("raise-slider");
        const valDisplay = document.getElementById("raise-val-display");

        btnCheck.innerText = t("checkBtn");
        btnCall.innerText = t("callBtn");
        btnRaise.innerText = t("raiseBtn");
        document.querySelector('[data-i18n="foldBtn"]').innerText = t("foldBtn");

        if (diff === 0) {
          btnCheck.classList.remove("hidden");
          btnCall.classList.add("hidden");
        } else {
          btnCheck.classList.add("hidden");
          btnCall.classList.remove("hidden");
          if (localPlayer.chips <= diff) btnCall.innerText = t("allInBtn");
          else btnCall.innerText = `${t("callBtn")} $${diff}`;
        }

        const minRaiseAmount = state.lastRaiseAmount;
        const minPossibleActionRaise = diff + minRaiseAmount;
        const maxPossibleActionRaise = localPlayer.chips;

        if (localPlayer.chips <= diff) {
          btnRaise.classList.add("hidden");
          document.getElementById("raise-slider-container").classList.add("hidden");
        } else if (maxPossibleActionRaise < minPossibleActionRaise) {
          btnRaise.classList.remove("hidden");
          btnRaise.innerText = t("allInBtn");
          document.getElementById("raise-slider-container").classList.remove("hidden");
          slider.min = maxPossibleActionRaise;
          slider.max = maxPossibleActionRaise;
          slider.value = maxPossibleActionRaise;
          valDisplay.innerText = `$${maxPossibleActionRaise}`;
          slider.disabled = true;
        } else {
          btnRaise.classList.remove("hidden");
          document.getElementById("raise-slider-container").classList.remove("hidden");
          slider.min = minPossibleActionRaise;
          slider.max = maxPossibleActionRaise;
          slider.step = 1;
          if (!this.isSliderReset) {
            slider.value = slider.min;
            this.isSliderReset = true; // 标记已重置，防止拖动时被归位
          }
          slider.disabled = false;
          const updateBtnText = () => {
            const raiseVal = parseInt(slider.value);
            valDisplay.innerText = `$${raiseVal}`;
            if (raiseVal === maxPossibleActionRaise) btnRaise.innerText = t("allInBtn");
            else btnRaise.innerText = `${t("raiseBtn")} $${raiseVal}`;
          };
          updateBtnText();
        }
      }

      adjustRaise(direction) {
        const slider = document.getElementById("raise-slider");
        if (!slider || slider.disabled) return;
        const currentVal = parseInt(slider.value);
        const step = 1;
        const min = parseInt(slider.min);
        const max = parseInt(slider.max);
        let newVal = currentVal + direction * step;
        if (newVal < min) newVal = min;
        if (newVal > max) newVal = max;
        slider.value = newVal;
        slider.dispatchEvent(new Event("input"));
      }

      showMessage(msg) {
        const el = document.getElementById("game-message");
        if (!el) return;
        el.innerText = msg;
        el.style.opacity = 1;
        if (this.msgTimeout) {
          clearTimeout(this.msgTimeout);
          this.msgTimeout = null;
        }
        this.msgTimeout = setTimeout(() => {
          el.style.opacity = 0;
        }, 3000);
      }

      showAllInEffect(playerName) {
        return new Promise((resolve) => {
          const overlay = document.createElement("div");
          overlay.className = "all-in-fullscreen-overlay";
          const bar = document.createElement("div");
          bar.className = "all-in-bar";
          const text = document.createElement("div");
          text.className = "all-in-text";
          text.innerText = `ALL-IN`;
          bar.appendChild(text);
          overlay.appendChild(bar);
          document.body.appendChild(overlay);
          this.sound.playAllIn();
          setTimeout(() => {
            overlay.style.transition = "opacity 0.3s";
            overlay.style.opacity = "0";
            setTimeout(() => {
              overlay.remove();
              resolve();
            }, 300);
          }, 1250);
        });
      }

      createCardEl(c) {
        const d = document.createElement("div");
        d.className = `card ${c.color}`;
        if (this.highlightCards.has(c.id)) d.classList.add("winning-card");
        d.innerHTML = `<span class="absolute top-0 left-1 text-xs">${c.rank}</span><span class="text-2xl">${c.suit}</span>`;
        return d;
      }
      createBackEl() {
        const d = document.createElement("div");
        d.className = "card card-back";
        return d;
      }
    }

    class NetworkManager {
      constructor(gameUI) {
        this.gameUI = gameUI;
        this.db = null;
        this.auth = null;
        this.appId = appId;
        this.localUserId = null;
        this.currentRoomId = null;
        this.unsubscribeRoom = null;
        this.nextRoundTimeout = null;
        this.nextPhaseTimeout = null;
        this.heartbeatInterval = null;
      }

      async init() {
        try {
          setLogLevel("Debug");
          this.app = initializeApp(firebaseConfig);
          this.db = getFirestore(this.app);
          this.auth = getAuth(this.app);
          onAuthStateChanged(this.auth, async (user) => {
            if (user) {
              this.localUserId = user.uid;
              document.getElementById("user-id-display").innerText = this.localUserId;
              document.getElementById("firebase-loader").classList.add("hidden");
              document.getElementById("room-screen").classList.remove("hidden");
            } else {
              await this.signIn();
            }
          });
        } catch (error) {
          document.getElementById("firebase-loader").innerText = "Failed. Refresh.";
        }
      }

      updateWaitingRoomUI(state, localId) {
        const hostControls = document.getElementById("wait-host-controls");
        const btnContainer = document.getElementById("host-start-btn-container");

        if (state.hostId === localId) {
          hostControls.classList.remove("hidden");
          const playerCount = state.playerOrder.length;
          if (playerCount < 2) {
            if (btnContainer) {
              btnContainer.innerHTML = `
                  <button disabled class="bg-gray-500 text-gray-300 font-black text-2xl py-4 px-12 rounded-full shadow-none border-b-4 border-gray-700 cursor-not-allowed opacity-50">
                    ${t("waitPlayerBtn")} (${playerCount}/10)
                  </button>`;
            }
          } else {
            if (btnContainer) {
              btnContainer.innerHTML = `
                  <button id="btn-start-game" onclick="network.startGame()" 
                    class="bg-red-600 hover:bg-red-500 text-white font-black text-2xl py-4 px-12 rounded-full shadow-xl border-b-4 border-red-800 active:border-b-0 active:translate-y-1 transition-all">
                    ${t("startGameBtn")} (${playerCount}/10)
                  </button>`;
            }
          }
          const bbInput = document.getElementById("setting-big-blind");
          const chipsInput = document.getElementById("setting-initial-chips");
          const sbDisplay = document.getElementById("setting-sb-display");
          const errChips = document.getElementById("error-chips-inline");
          const errBlind = document.getElementById("error-blind-inline");
          const startBtn = document.getElementById("btn-start-game");
          const validateInputs = () => {
            let isValid = true;

            const chipsVal = parseInt(chipsInput.value) || 0;
            const bbVal = parseInt(bbInput.value) || 0;
            if (bbVal < 2) {
              errBlind.innerText = t("error_blind_min");
              isValid = false;
            } else if (bbVal % 2 !== 0) {
              errBlind.innerText = t("error_blind_even");
              isValid = false;
            } else {
              errBlind.innerText = "";
            }
            if (sbDisplay) sbDisplay.innerText = Math.floor(bbVal / 2);
            if (chipsVal <= bbVal) {
              errChips.innerText = t("error_chips_too_low");
              isValid = false;
            } else {
              errChips.innerText = "";
            }
            if (startBtn) {
              if (!isValid) {
                startBtn.disabled = true;
                startBtn.classList.add("opacity-50", "cursor-not-allowed", "grayscale");
              } else {
                startBtn.disabled = false;
                startBtn.classList.remove("opacity-50", "cursor-not-allowed", "grayscale");
              }
            }
          };
          if (chipsInput) {
            chipsInput.oninput = () => {
              chipsInput.value = chipsInput.value.replace(/[^\d]/g, '');
              validateInputs();
            };
          }

          if (bbInput) {
            bbInput.oninput = () => {
              bbInput.value = bbInput.value.replace(/[^\d]/g, '');
              validateInputs();
            };
          }
          validateInputs();
        } else {
          hostControls.classList.add("hidden");
          if (btnContainer) btnContainer.innerHTML = "";
          const hostPlayer = state.players[state.hostId];
          const hostName = hostPlayer ? hostPlayer.name : "Host";
          const waitMessage = document.getElementById("wait-message");
          if (waitMessage) {
            waitMessage.classList.remove("hidden");
            waitMessage.innerText = `${t("waitForHost")} (${hostName})`;
          }
        }
      }

      async signIn() {
        try {
          if (initialAuthToken) await signInWithCustomToken(this.auth, initialAuthToken);
          else await signInAnonymously(this.auth);
        } catch (error) { console.error(error); }
      }

      getRoomRef(roomId) {
        return doc(this.db, "artifacts", this.appId, "public/data/poker-rooms", roomId);
      }

      validateInputs() {
        const name = document.getElementById("player-name-input").value.trim();
        const room = document.getElementById("room-id-input").value.trim();
        const errEl = document.getElementById("room-error");
        if (name.length < 2 || name.length > 10) {
          errEl.innerText = t("error_nickname");
          return null;
        }
        if (room.length < 1 || room.length > 20) {
          errEl.innerText = t("error_room_id");
          return null;
        }
        localPlayerName = name;
        errEl.innerText = "";
        return room;
      }

      async createRoom() {
        const roomId = this.validateInputs();
        if (!roomId) return;
        this.disableRoomButtons(true);
        const roomRef = this.getRoomRef(roomId);
        try {
          const docSnap = await getDoc(roomRef);
          if (docSnap.exists()) {
            const data = docSnap.data();
            if (data.lastActive && Date.now() - data.lastActive > 30000) {
              await deleteDoc(roomRef);
            } else {
              document.getElementById("room-error").innerText = t("error_game_started");
              this.disableRoomButtons(false);
              return;
            }
          }
          const newPlayer = {
            uid: this.localUserId,
            id: 0,
            name: localPlayerName,
            chips: 2000,
            holeCards: [],
            folded: false,
            currentBet: 0,
            accumulatedBet: 0,
            status: "waiting"
          };
          const initialState = {
            status: "waiting",
            hostId: this.localUserId,
            lastActive: Date.now(),
            config: { initialChips: 2000, smallBlind: 10, bigBlind: 20 },
            players: { [this.localUserId]: newPlayer },
            playerOrder: [this.localUserId],
            communityCards: [],
            pot: 0,
            dealerIndex: 0,
            currentPlayerIndex: -1,
            currentMaxBet: 0,
            phase: "waiting",
            lastRaiseAmount: 20,
            deck: [],
            // Use JSON string for initial log
            logs: [createLog("log_create", { name: localPlayerName })],
            highlightWinner: null,
            highlightCards: [],
            nextRoundTimer: 0,
            nextPhaseTimer: 0,
          };
          await setDoc(roomRef, initialState);
          this.subscribeToRoom(roomId);
        } catch (error) {
          document.getElementById("room-error").innerText = "Create failed";
          this.disableRoomButtons(false);
        }
      }

      async joinRoom() {
        const roomId = this.validateInputs();
        if (!roomId) return;
        this.disableRoomButtons(true);
        const roomRef = this.getRoomRef(roomId);
        try {
          await runTransaction(this.db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) throw new Error("Room not found");
            let state = roomDoc.data();
            if (state.lastActive && Date.now() - state.lastActive > 30000) throw new Error("ROOM_IS_DEAD");
            if (state.players[this.localUserId]) {
              if (state.status === "waiting") {
                state.players[this.localUserId].chips = 2000;
                state.players[this.localUserId].status = "waiting";
              }
              transaction.set(roomRef, state);
              return;
            }
            if (state.status !== "waiting") throw new Error(t("error_game_started"));
            if (Object.keys(state.players).length >= 10) throw new Error(t("error_room_full"));
            const newPlayer = {
              uid: this.localUserId,
              id: Object.keys(state.players).length,
              name: localPlayerName,
              chips: 2000,
              holeCards: [],
              folded: false,
              currentBet: 0,
              accumulatedBet: 0,
              status: "waiting"
            };
            state.players[this.localUserId] = newPlayer;
            state.playerOrder.push(this.localUserId);
            state.logs.push(createLog("log_join", { name: localPlayerName }));
            transaction.set(roomRef, state);
          });
          this.subscribeToRoom(roomId);
        } catch (error) {
          if (error.message.includes("ROOM_IS_DEAD")) {
            await deleteDoc(roomRef);
            document.getElementById("room-error").innerText = t("error_room_dead");
          } else {
            document.getElementById("room-error").innerText = error.message || t("error_join_fail");
          }
          this.disableRoomButtons(false);
        }
      }

      async leaveRoom() {
        this.stopHeartbeat();
        if (this.unsubscribeRoom) {
          this.unsubscribeRoom();
          this.unsubscribeRoom = null;
        }
        const roomId = this.currentRoomId;
        const userId = this.localUserId;

        if (roomId && userId) {
          const roomRef = this.getRoomRef(roomId);
          try {
            await runTransaction(this.db, async (transaction) => {
              const roomDoc = await transaction.get(roomRef);
              if (!roomDoc.exists()) return;
              let state = roomDoc.data();

              if (state.players[userId]) {
                const playerName = state.players[userId].name;
                delete state.players[userId];
                state.playerOrder = state.playerOrder.filter((uid) => uid !== userId);
                state.logs.push(createLog("log_leave", { name: playerName }));
              }

              if (state.playerOrder.length === 0) {
                transaction.delete(roomRef);
                return;
              }

              if (state.status === 'playing' && state.playerOrder.length < 2) {
                state.status = 'waiting';
                state.phase = 'waiting';
                state.pot = 0;
                state.communityCards = [];
                state.currentMaxBet = 0;
                state.currentPlayerIndex = -1;
                state.dealerIndex = 0;
                state.logs.push(createLog("log_round_end_no_winner"));
                state.highlightWinner = null;
                state.highlightCards = [];
                state.nextRoundTimer = 0;
                state.nextPhaseTimer = 0;

                state.playerOrder.forEach(uid => {
                  if (state.players[uid]) {
                    state.players[uid].chips = 2000;
                    state.players[uid].holeCards = [];
                    state.players[uid].folded = false;
                    state.players[uid].currentBet = 0;
                    state.players[uid].accumulatedBet = 0;
                    state.players[uid].status = "waiting";
                    state.players[uid].bestHand = null;
                  }
                });
              }

              if (state.hostId === userId) {
                state.hostId = state.playerOrder[0];
                state.logs.push(createLog("log_host_change", { name: state.players[state.hostId].name }));
              }
              transaction.set(roomRef, state);
            });
          } catch (e) { console.error(e); }
        }

        this.currentRoomId = null;
        if (this.nextRoundTimeout) clearTimeout(this.nextRoundTimeout);
        if (this.nextPhaseTimeout) clearTimeout(this.nextPhaseTimeout);
        this.gameUI.bankruptcyScreenShown = false;
        document.getElementById("game-area").classList.add("hidden");
        document.getElementById("room-screen").classList.remove("hidden");
        this.disableRoomButtons(false);
      }

      startHeartbeat(roomId) {
        this.stopHeartbeat();
        this.heartbeatInterval = setInterval(async () => {
          if (!this.currentRoomId || !this.localUserId) return;
          const state = this.gameUI.lastState;
          if (state && state.hostId === this.localUserId) {
            const roomRef = this.getRoomRef(roomId);
            try {
              await window.firestoreUpdateDoc(roomRef, { lastActive: Date.now() });
            } catch (e) { }
          }
        }, 5000);
      }

      stopHeartbeat() {
        if (this.heartbeatInterval) {
          clearInterval(this.heartbeatInterval);
          this.heartbeatInterval = null;
        }
      }

      subscribeToRoom(roomId) {
        this.currentRoomId = roomId;
        document.getElementById("display-room-id").innerText = roomId;
        document.getElementById("room-screen").classList.add("hidden");
        document.getElementById("game-area").classList.remove("hidden");
        this.gameUI.initSound();
        this.gameUI.occlusionManager.start();
        this.startHeartbeat(roomId);

        this.unsubscribeRoom = onSnapshot(this.getRoomRef(roomId), (doc) => {
          if (!doc.exists()) {
            this.gameUI.showMessage("Room closed");
            setTimeout(() => this.leaveRoom(), 2000);
            return;
          }
          const state = doc.data();
          this.gameUI.renderGameState(state, this.localUserId);
          this.runHostTimerController(state);
        }, () => { this.leaveRoom(); });
      }

      runHostTimerController(state) {
        if (state.nextPhaseTimer > 0 && state.hostId === this.localUserId) {
          if (!this.nextPhaseTimeout) {
            this.nextPhaseTimeout = setTimeout(async () => {
              this.nextPhaseTimeout = null;
              const roomRef = this.getRoomRef(this.currentRoomId);
              try {
                let cur = (await getDoc(roomRef)).data();
                if (cur.nextPhaseTimer > 0) {
                  cur.nextPhaseTimer = 0;
                  const next = runAutoShowdown(cur);
                  await setDoc(roomRef, next);
                }
              } catch (e) { }
            }, state.nextPhaseTimer);
          }
        } else if (state.nextPhaseTimer === 0 && this.nextPhaseTimeout) {
          clearTimeout(this.nextPhaseTimeout);
          this.nextPhaseTimeout = null;
        }

        if (state.phase === "showdown" && state.hostId === this.localUserId) {
          if (state.nextRoundTimer > 0 && !this.nextRoundTimeout) {
            this.nextRoundTimeout = setTimeout(async () => {
              this.nextRoundTimeout = null;
              const roomRef = this.getRoomRef(this.currentRoomId);
              try {
                const cur = (await getDoc(roomRef)).data();
                if (cur.phase === "showdown") {
                  const next = startNewRound(cur);
                  await setDoc(roomRef, next);
                }
              } catch (e) { }
            }, state.nextRoundTimer);
          }
        }
      }

      async startGame() {
        if (!this.currentRoomId || !this.gameUI.lastState) return;
        if (this.localUserId !== this.gameUI.lastState.hostId) return;

        const chipsInput = document.getElementById("setting-initial-chips");
        const blindInput = document.getElementById("setting-big-blind");
        let newInitChips = chipsInput ? parseInt(chipsInput.value) : 2000;
        let newBigBlind = blindInput ? parseInt(blindInput.value) : 20;

        newInitChips = Math.floor(newInitChips);
        newBigBlind = Math.floor(newBigBlind);

        if (newBigBlind < 2 || newBigBlind % 2 !== 0) return;
        if (newInitChips <= newBigBlind) return;

        const btn = document.getElementById("btn-start-game");
        if (!btn || this.gameUI.lastState.playerOrder.length < 2) return;

        btn.disabled = true;
        const roomRef = this.getRoomRef(this.currentRoomId);
        try {
          const currentState = this.gameUI.lastState;
          if (currentState.status !== "waiting") return;

          currentState.config = {
            initialChips: newInitChips,
            bigBlind: newBigBlind,
            smallBlind: Math.floor(newBigBlind / 2)
          };

          Object.keys(currentState.players).forEach(uid => {
            currentState.players[uid].chips = newInitChips;
            currentState.players[uid].currentBet = 0;
          });

          for (let i = currentState.playerOrder.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [currentState.playerOrder[i], currentState.playerOrder[j]] = [currentState.playerOrder[j], currentState.playerOrder[i]];
          }

          currentState.status = "playing";
          const nextState = startNewRound(currentState);
          await setDoc(roomRef, nextState);
        } catch (error) {
          btn.disabled = false;
          this.gameUI.showMessage("Start failed");
        }
      }

      async handleHumanAction(action) {
        const state = this.gameUI.lastState;
        if (!state || state.playerOrder[state.currentPlayerIndex] !== this.localUserId) return;

        this.gameUI.updateControls({ ...state, currentPlayerIndex: -1 });
        let actionAmount = 0;
        if (action === "raise") {
          const slider = document.getElementById("raise-slider");
          if (slider) actionAmount = parseInt(slider.value);
        }

        const roomRef = this.getRoomRef(this.currentRoomId);
        try {
          await runTransaction(this.db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) throw new Error("Room missing");

            const currentState = roomDoc.data();
            if (currentState.playerOrder[currentState.currentPlayerIndex] !== this.localUserId) return;

            let totalAmount = 0;
            const player = currentState.players[this.localUserId];
            if (action === "raise") totalAmount = player.currentBet + actionAmount;

            const nextState = processAction(currentState, this.localUserId, action, totalAmount);
            transaction.set(roomRef, nextState);
          });
        } catch (error) {
          this.gameUI.showMessage("Action failed");
          if (this.gameUI.lastState && this.localUserId) {
            this.gameUI.updateControls(this.gameUI.lastState);
          }
        }
      }

      disableRoomButtons(disabled) {
        document.getElementById("btn-join-room").disabled = disabled;
        document.getElementById("btn-create-room").disabled = disabled;
        const method = disabled ? "add" : "remove";
        document.getElementById("btn-join-room").classList[method]("btn-disabled");
        document.getElementById("btn-create-room").classList[method]("btn-disabled");
      }
    }

    class SoundManager {
      constructor() {
        this.ctx = null;
        this.enabled = false;
      }

      init() {
        if (!this.ctx) {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.enabled = true;
          const resumeAudio = () => {
            if (this.ctx && this.ctx.state === "suspended") {
              this.ctx.resume();
            }
          };
          document.addEventListener("click", resumeAudio);
          document.addEventListener("touchstart", resumeAudio);
        }
        if (this.ctx.state === "suspended") {
          this.ctx.resume();
        }
      }

      playTone(freq, type, duration, vol = 0.1, when = 0) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime + when);

        gain.gain.setValueAtTime(vol, this.ctx.currentTime + when);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + when + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.start(this.ctx.currentTime + when);
        osc.stop(this.ctx.currentTime + when + duration);
      }

      playChip() {
        this.playTone(2000, "square", 0.05, 0.03);
      }

      playCard() {
        this.playTone(800, "sine", 0.1, 0.02);
      }

      playCheck() {
        this.playTone(300, "sine", 0.05, 0.1);
        this.playTone(300, "sine", 0.05, 0.1, 0.1);
      }

      playFold() {
        this.playTone(150, "triangle", 0.3, 0.1);
      }

      playAllIn() {
        if (!this.enabled) return;
        const t = this.ctx.currentTime;
        this.playTone(100, "sawtooth", 0.4, 0.4, 0);
        this.playTone(50, "square", 1.0, 0.5, 0.1);

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.3);

        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.3);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(t + 0.3);
      }

      playRaise() {
        this.playTone(1500, "square", 0.08, 0.04);
        this.playTone(1000, "square", 0.08, 0.04, 0.05);
      }

      playHandEnd() {
        this.playTone(440, "sine", 0.2, 0.1);
      }

      playWin() {
        [523, 659, 784, 1046].forEach((f, i) => this.playTone(f, "triangle", 0.4, 0.15, i * 0.15));
      }

      playLose() {
        this.playTone(100, "sawtooth", 1.0, 0.2);
        this.playTone(80, "sawtooth", 1.0, 0.2, 0.3);
      }
    }

    class OcclusionManager {
      constructor() {
        this.communityArea = document.getElementById("community-area");
        this.gameMessage = document.getElementById("game-message");
        this.isRunning = false;
        this.checkLoop = null;
      }

      start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.checkLoop = setInterval(() => this.check(), 100);
      }

      stop() {
        this.isRunning = false;
        clearInterval(this.checkLoop);
      }

      getOverlapRatio(r1, r2) {
        if (!r1 || !r2) return 0;
        const overlapLeft = Math.max(r1.left, r2.left);
        const overlapRight = Math.min(r1.right, r2.right);
        const overlapTop = Math.max(r1.top, r2.top);
        const overlapBottom = Math.min(r1.bottom, r2.bottom);

        if (overlapLeft >= overlapRight || overlapTop >= overlapBottom) return 0;

        const overlapArea = (overlapRight - overlapLeft) * (overlapBottom - overlapTop);
        const area1 = r1.width * r1.height;
        const area2 = r2.width * r2.height;
        return overlapArea / Math.min(area1, area2);
      }

      check() {
        const seats = document.querySelectorAll(".player-seat");
        if (seats.length === 0) return;

        const cardTargets = [];
        seats.forEach((seat) => {
          const cardsDiv = seat.querySelector('div[id^="cards-"]');
          if (cardsDiv && cardsDiv.children.length > 0) {
            cardTargets.push(cardsDiv.getBoundingClientRect());
          }
        });

        const commRect = this.communityArea.getBoundingClientRect();
        if (commRect.width > 10 && commRect.height > 10) {
          let commObstructed = false;
          for (const targetRect of cardTargets) {
            if (this.getOverlapRatio(targetRect, commRect) > 0.2) {
              commObstructed = true;
              break;
            }
          }
          if (!commObstructed) {
            seats.forEach((seat) => {
              const infoBox = seat.querySelector(".player-info-box");
              if (infoBox) {
                if (this.getOverlapRatio(infoBox.getBoundingClientRect(), commRect) > 0.2) {
                  commObstructed = true;
                }
              }
            });
          }
          this.applyTransparency(this.communityArea, commObstructed);
        } else {
          this.applyTransparency(this.communityArea, false);
        }

        if (this.gameMessage && this.gameMessage.style.opacity !== "0") {
          let msgObstructed = false;
          const msgRect = this.gameMessage.getBoundingClientRect();
          if (commRect.width > 10 && commRect.height > 10) {
            if (this.getOverlapRatio(msgRect, commRect) > 0.2) msgObstructed = true;
          }
          if (!msgObstructed) {
            for (const targetRect of cardTargets) {
              if (this.getOverlapRatio(msgRect, targetRect) > 0.2) {
                msgObstructed = true;
                break;
              }
            }
          }
          this.applyTransparency(this.gameMessage, msgObstructed);
        }
      }

      applyTransparency(el, shouldBeTransparent) {
        if (shouldBeTransparent) {
          if (!el.classList.contains("smart-transparent")) el.classList.add("smart-transparent");
        } else {
          if (el.classList.contains("smart-transparent")) el.classList.remove("smart-transparent");
        }
      }
    }

    class TableDragSystem {
      constructor() {
        this.container = document.getElementById("table-area");
        this.table = document.getElementById("table");
        this.isDragging = false;
        this.startY = 0;
        this.currentY = 30;
        this.initialDragY = 0;
        this.init();
      }

      init() {
        this.container.addEventListener("mousedown", this.onStart.bind(this));
        window.addEventListener("mousemove", this.onMove.bind(this));
        window.addEventListener("mouseup", this.onEnd.bind(this));

        this.container.addEventListener("touchstart", this.onStart.bind(this), { passive: false });
        window.addEventListener("touchmove", this.onMove.bind(this), { passive: false });
        window.addEventListener("touchend", this.onEnd.bind(this));

        this.updateTransform();
      }

      onStart(e) {
        if (e.target.closest("button") || e.target.closest("input")) return;
        this.isDragging = true;
        this.startY = this.getY(e);
        this.initialDragY = this.currentY;

        this.table.classList.remove("duration-500");
        this.table.classList.add("duration-0");
        this.container.classList.add("cursor-grabbing");
        this.container.classList.remove("cursor-grab");
      }

      onMove(e) {
        if (!this.isDragging) return;
        e.preventDefault();
        const y = this.getY(e);
        const diff = y - this.startY;
        this.currentY = this.initialDragY + diff;

        if (this.currentY > 180) this.currentY = 180;
        if (this.currentY < -120) this.currentY = -120;

        this.updateTransform();
        if (window.occlusionManager) window.occlusionManager.check();
      }

      onEnd() {
        if (!this.isDragging) return;
        this.isDragging = false;
        this.table.classList.remove("duration-0");
        this.table.classList.add("duration-500");
        this.container.classList.remove("cursor-grabbing");
        this.container.classList.add("cursor-grab");
      }

      getY(e) {
        return e.touches ? e.touches[0].clientY : e.clientY;
      }

      updateTransform() {
        this.table.style.transform = `translateY(${this.currentY}px)`;
      }
    }

    class HandEvaluator {
      static evaluate(holeCards, communityCards) {
        if (!holeCards || holeCards.length === 0) {
          return { score: 0, name: "hand_high_card", bestCards: [] };
        }

        const all = [
          ...holeCards.map((c) => ({ ...c, isHole: true })),
          ...communityCards.map((c) => ({ ...c, isHole: false }))
        ];

        all.sort((a, b) => {
          if (b.value !== a.value) return b.value - a.value;
          return b.isHole - a.isHole;
        });

        const getKickers = (excludeCards, count) => {
          const kickers = [];
          const excludeIds = new Set(excludeCards.map((c) => c.id));
          for (const c of all) {
            if (!excludeIds.has(c.id)) {
              kickers.push(c);
              if (kickers.length === count) break;
            }
          }
          return kickers;
        };

        const calcScore = (rankVal, mainCards, kickers) => {
          let s = rankVal * Math.pow(100, 5);
          mainCards.forEach((c, i) => { s += c.value * Math.pow(100, 4 - i); });
          kickers.forEach((c, i) => { s += c.value * Math.pow(100, 4 - mainCards.length - i); });
          return s;
        };

        const suits = {};
        all.forEach((c) => {
          if (!suits[c.suit]) suits[c.suit] = [];
          suits[c.suit].push(c);
        });

        let flushCards = null;
        for (let s in suits) {
          if (suits[s].length >= 5) {
            flushCards = suits[s].slice(0, 5);
            break;
          }
        }

        const getStraightCards = (cardsToCheck) => {
          const uniqueVals = [...new Set(cardsToCheck.map((c) => c.value))].sort((a, b) => b - a);

          // A-5 Straight
          if (uniqueVals.includes(14) && uniqueVals.includes(5) && uniqueVals.includes(4) && uniqueVals.includes(3) && uniqueVals.includes(2)) {
            const straightVals = [5, 4, 3, 2, 14];
            const best5 = [];
            const usedIds = new Set();

            straightVals.forEach((v) => {
              const card = cardsToCheck.find((c) => c.value === v && !usedIds.has(c.id));
              if (card) {
                best5.push(card);
                usedIds.add(card.id);
              }
            });
            if (best5.length === 5) return { cards: best5, high: 5 };
          }

          // Normal Straight
          for (let i = 0; i <= uniqueVals.length - 5; i++) {
            if (uniqueVals[i] - uniqueVals[i + 4] === 4) {
              const straightVals = uniqueVals.slice(i, i + 5);
              const best5 = [];
              const usedIds = new Set();

              straightVals.forEach((v) => {
                const card = cardsToCheck.find((c) => c.value === v && !usedIds.has(c.id));
                if (card) {
                  best5.push(card);
                  usedIds.add(card.id);
                }
              });
              if (best5.length === 5) return { cards: best5, high: uniqueVals[i] };
            }
          }
          return null;
        };

        if (flushCards) {
          const sf = getStraightCards(flushCards);
          if (sf) {
            return {
              score: calcScore(9, [sf.cards[0]], []),
              name: "hand_straight_flush",
              bestCards: sf.cards
            };
          }
        }

        const counts = {};
        all.forEach((c) => (counts[c.value] = (counts[c.value] || 0) + 1));

        const fours = Object.keys(counts).filter((v) => counts[v] === 4).map(Number).sort((a, b) => b - a);
        const threes = Object.keys(counts).filter((v) => counts[v] === 3).map(Number).sort((a, b) => b - a);
        const pairs = Object.keys(counts).filter((v) => counts[v] === 2).map(Number).sort((a, b) => b - a);

        if (fours.length > 0) {
          const fourVal = fours[0];
          const quadCards = all.filter((c) => c.value === fourVal);
          const kicker = getKickers(quadCards, 1);
          return {
            score: calcScore(8, [quadCards[0]], kicker),
            name: "hand_four_of_a_kind",
            bestCards: [...quadCards, ...kicker]
          };
        }

        if (threes.length > 0 && (threes.length > 1 || pairs.length > 0)) {
          const threeVal = threes[0];
          const pairVal = threes.length > 1 ? threes[1] : pairs[0];
          const threeCards = all.filter((c) => c.value === threeVal).slice(0, 3);
          const pairCards = all.filter((c) => c.value === pairVal).slice(0, 2);
          return {
            score: calcScore(7, [threeCards[0], pairCards[0]], []),
            name: "hand_full_house",
            bestCards: [...threeCards, ...pairCards]
          };
        }

        if (flushCards) {
          return {
            score: calcScore(6, flushCards, []),
            name: "hand_flush",
            bestCards: flushCards
          };
        }

        const straight = getStraightCards(all);
        if (straight) {
          return {
            score: calcScore(5, [straight.cards[0]], []),
            name: "hand_straight",
            bestCards: straight.cards
          };
        }

        if (threes.length > 0) {
          const threeVal = threes[0];
          const threeCards = all.filter((c) => c.value === threeVal).slice(0, 3);
          const kickers = getKickers(threeCards, 2);
          return {
            score: calcScore(4, [threeCards[0]], kickers),
            name: "hand_three_of_a_kind",
            bestCards: [...threeCards, ...kickers]
          };
        }

        if (pairs.length >= 2) {
          const p1 = pairs[0];
          const p2 = pairs[1];
          const pair1Cards = all.filter((c) => c.value === p1).slice(0, 2);
          const pair2Cards = all.filter((c) => c.value === p2).slice(0, 2);
          const kicker = getKickers([...pair1Cards, ...pair2Cards], 1);
          return {
            score: calcScore(3, [pair1Cards[0], pair2Cards[0]], kicker),
            name: "hand_two_pairs",
            bestCards: [...pair1Cards, ...pair2Cards, ...kicker]
          };
        }

        if (pairs.length === 1) {
          const p1 = pairs[0];
          const pairCards = all.filter((c) => c.value === p1).slice(0, 2);
          const kickers = getKickers(pairCards, 3);
          return {
            score: calcScore(2, [pairCards[0]], kickers),
            name: "hand_pair",
            bestCards: [...pairCards, ...kickers]
          };
        }

        const highCards = all.slice(0, 5);
        return {
          score: calcScore(1, highCards, []),
          name: "hand_high_card",
          bestCards: highCards
        };
      }
    }

    const gameUI = new GameUIManager();
    const network = new NetworkManager(gameUI);
    window.network = network;
    window.gameUI = gameUI;
    network.init();
  </script>
</body>

</html>
